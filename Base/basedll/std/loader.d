
// Написано на языке программирования Динрус. Разработчик Виталий Кулич.

module std.loader;
	import std.x.loader;

	цел иницМодуль(){return std.x.loader.ExeModule_Init();}
	проц деиницМодуль(){return std.x.loader.ExeModule_Uninit();}
	ук загрузиМодуль(in ткст имямод){return cast(ук) адаптВыхУкз(std.x.loader.ExeModule_Load(имямод));}
	ук добавьСсылНаМодуль(ук умодуль){return cast(ук) std.x.loader.ExeModule_AddRef(cast(HXModule) умодуль);}
	проц отпустиМодуль(inout ук умодуль){return std.x.loader.ExeModule_Release(cast(HXModule) умодуль);}
	ук дайСимволИМодуля(inout ук умодуль, in ткст имяСимвола){return std.x.loader.ExeModule_GetSymbol(cast(HXModule) умодуль, имяСимвола);}
	ткст ошибкаИМодуля(){return std.x.loader.ExeModule_Error();}

	//Загрузчик от Derelict'а	........................................

char* toCString(char[] str)
{
    return std.x.string.toStringz(str);
}

char[] toDString(char* cstr)
{
        return std.x.string.toString(cstr);
}

int findStr(char[] str, char[] match)
{
        return std.x.string.find(str, match);
}

char[][] splitStr(char[] str, char[] delim)
{
    return std.x.string.split(str, delim);
}

char[] stripWhiteSpace(char[] str)
{
        return std.x.string.strip(str);
}


class ИсключениеЗагрузкиБиблиотеки
{

    ткст м_назвСовмБиб;

  static проц выведи(in ткст[] назвыБиб, in ткст[] причины)
    {
        ткст сооб = "Не удалось загрузить одну (или более) ДЛЛ:";
        foreach(i, n; назвыБиб)
        {
            сооб ~= "\n\t" ~ n ~ " - ";
            if(i < причины.length)
                сооб ~= причины[i];
            else
                сооб ~= "Неизвестно";
        }
        throw new Исключение(сооб);
    }

    this(ткст сооб)
    {
	м_назвСовмБиб = "";
        throw new Исключение(сооб,__FILE__, __LINE__);

    }

    this(ткст сооб, ткст назвСовмБиб)
    {
	м_назвСовмБиб = назвСовмБиб;
        throw new Исключение(сооб,__FILE__, __LINE__);

    }

    ткст имяБиб()
    {
        return м_назвСовмБиб;
    }


}

class ИсключениеНеверногоУкНаБиб
{
public:

    this(ткст назвСовмБиб)
    {
        throw new Исключение("Попытка применить указатель на незагруженную ДЛЛ " ~ назвСовмБиб,__FILE__, __LINE__);
        м_назвСовмБиб = назвСовмБиб;
    }

    ткст имяБиб()
    {
        return м_назвСовмБиб;
    }

private:
    ткст м_назвСовмБиб;
}

export ткст дайТкстОшибки()
    {
        // adapted from Tango

        бцел ошкод = ДайПоследнююОшибку();

        ткст буфСооб;
        бцел i = ФорматируйСообА(
            ПФорматСооб.РазмБуф | ПФорматСооб.ИзСист | ПФорматСооб.ИгнорВставки,
            null,
            ошкод,
            СДЕЛАЙИДЪЯЗ(ПЯзык.НЕЙТРАЛЬНЫЙ, ППодъяз.ДЕФОЛТ),
            буфСооб,
            0,
            null);

        ткст text = буфСооб;
        ОсвободиЛок(cast(лук) буфСооб);

        if(i >= 2)
            i -= 2;
        return text[0 .. i];
    }

export extern(D)
 class Биб
{
private{
    ук _укз;
    ткст _имя;
	}
export:
    ткст имя()
    {
        return _имя;
    }

  this(ук укз, ткст имя)
    {
        _укз = адаптВхоУкз(укз);
        _имя = имя;
    }
}

export extern(D)
 Биб загрузиБиб(ткст имяб)
in
{
    assert(имяб !is null);
}
body
{
    ук хэндл = ЗагрузиБиблиотекуА(имяб);
    if(хэндл is null)
        throw new Исключение("Не удалось загрузить библиотеку " ~ имяб ~ ": " ~ дайТкстОшибки(),__FILE__, __LINE__);
    return new Биб(хэндл, имяб);
}

export extern(D)
 Биб загрузиБиб(ткст[] именаб)
in
{
   try	{
   assert(именаб !is null);
   }
   catch(Исключение пи){инфо("Не заданы имена для загрузки в функции загрузиБиб"); выход(0);}
}
body
{
    char[][] незагрБибы;
    char[][] причины;

    foreach(ткст имяб; именаб)
    {
        ук хэндл = ЗагрузиБиблиотекуА(имяб);
        if(хэндл !is null)
        {
            return new Биб(хэндл, имяб);
        }
        else
        {
            незагрБибы ~= имяб;
            причины ~= дайТкстОшибки();
        }

    }
    ИсключениеЗагрузкиБиблиотеки.выведи(незагрБибы, причины);
    return null; // to shut the compiler up
}

export extern(D)
 проц выгрузиБиб(Биб биб)
{
    if(биб !is null && биб._укз !is null)
        ОсвободиБиблиотеку(биб._укз);
        биб._укз = null;
}

export extern(D)
 ук дайПроцИзБиб(Биб биб, ткст имяПроц)
in
{
    assert(биб !is null);
    assert(имяПроц !is null);
}
body
{
    if(биб._укз is null)
        new ИсключениеНеверногоУкНаБиб(биб._имя);
		ук proc = ДайАдресПроц(биб._укз, имяПроц);
        if(null is proc)
            ОбработайНедостачуПроц(биб._имя, имяПроц);

        return proc;
}

alias бул function(ткст имяБиб, ткст имяПроц) ОбрвызНедостСимвола;
alias ОбрвызНедостСимвола ОбрвызНедостПроц;

private ОбрвызНедостСимвола обрвызНедостПроц;

проц ОбработайНедостачуПроц(ткст имяБиб, ткст имяСимвола)
{
    бул результат = нет;
    if(обрвызНедостПроц !is null)
        результат = обрвызНедостПроц(имяБиб, имяСимвола);
    if(!результат)
        new ИсключениеЗагрузкиБиблиотеки(имяБиб, имяСимвола);
}

export extern(D)
 struct ЖанБибгр {
export:

   проц заряжай(ткст винБибы, проц function(Биб) пользовательскийЗагр, ткст текстВерсии = "") {
        assert (пользовательскийЗагр !is null);
        this.винБибы = винБибы;
        this.пользовательскийЗагр = пользовательскийЗагр;
        this.текстВерсии = текстВерсии;
    }

    проц загружай(ткст текстНазвБиб = null)
    {
        if (мояБиб !is null) return;
        зарегестрированныеЗагрузчики ~= this;
        if (текстНазвБиб is null) текстНазвБиб = винБибы;

            if(текстНазвБиб is null || текстНазвБиб == "")
            {
                throw new Исключение("stdrus.ЖанБибгр.загружай: Название несуществующей библиотеки!");
            }

        ткст[] назвыБиб = текстНазвБиб.splitStr(",");
        foreach (б; назвыБиб)
			{
				б = б.stripWhiteSpace();
			}

        загружай(назвыБиб);
    }

    проц загружай(ткст[] назвыБиб)
    {
        мояБиб = загрузиБиб(назвыБиб);

        if(пользовательскийЗагр is null)
        {
            // this should never, ever, happen
            throw new Исключение("stdrus.ЖанБибгр.загружай: Кошмар! Внутренняя функция загрузки сконфигурирована с ошибками...",__FILE__, __LINE__);
        }

        пользовательскийЗагр(мояБиб);

    }

    ткст строкаВерсии()
    {
        return текстВерсии;
    }

    проц выгружай()
    {
        if (мояБиб !is null) {
            выгрузиБиб(мояБиб);
            мояБиб = null;
        }
    }

    бул загружено()
    {
        return (мояБиб !is null);
    }

    ткст имяБиб()
    {
        return загружено ? мояБиб.имя : null;
    }

    static ~this()
    {
        foreach (x; зарегестрированныеЗагрузчики) {
            x.выгружай();
        }
    }

    private {
        static ЖанБибгр*[] зарегестрированныеЗагрузчики;

        Биб мояБиб;
        ткст винБибы;
        ткст текстВерсии = "";

        проц function(Биб) пользовательскийЗагр;
    }
}

export extern(D)
 struct ЗавЖанБибгр {
export:

    проц заряжай(ЖанБибгр* dependence,  проц function(Биб) пользовательскийЗагр) {
        assert (dependence !is null);
        assert (пользовательскийЗагр !is null);

        this.dependence = dependence;
        this.пользовательскийЗагр = пользовательскийЗагр;
    }

    проц загружай()
    {
        assert (dependence.загружено);
        пользовательскийЗагр(dependence.мояБиб);
    }

    ткст строкаВерсии()
    {
        return dependence.строкаВерсии;
    }

    проц выгружай()
    {
    }

    бул загружено()
    {
        return dependence.загружено;
    }

    ткст имяБиб()
    {
        return dependence.имяБиб;
    }

    private {
        ЖанБибгр*              dependence;
        проц function(Биб)    пользовательскийЗагр;
    }
}

struct Вяз(T) {
    проц opCall(ткст n, Биб lib) {
        *fptr = дайПроцИзБиб(lib, n);
    }
        ук* fptr;
}


template вяжи(T) {
    Вяз!(T) вяжи(inout T a) {
        Вяз!(T) рез;
        рез.fptr = cast(ук*)&a;
        return рез;
    }
}

export extern(D)
 бул создайБибИзДлл(ткст имяБ, ткст имяД = null, ткст путь = null, ткст расшД = "dll")
{

if(имяД == null) имяД = имяБ;
сис(фм("implib/system %s.lib %s%s.%s", имяБ, путь, имяД, расшД));
return да;
}

export extern(D)
 бул создайЛистинг(ткст имяБ)
{
сис(фм("d:\\dinrus\\bin\\lib -l %s.lib", имяБ));
if(естьФайл(имяБ~".lst"))удалиФайл(имяБ~".lib");
	else throw new Исключение("Неудачная генерация листинга",имяБ, __LINE__);
return  да;
}

export extern(D)
 цел генМакетИмпорта(ткст имяМ, ткст[] список)
{
	СИСТВРЕМЯ систВремя;
	цел счёт = 1;

	ДайМестнВремя(&систВремя);
	ткст дата = вТкст(систВремя.день)~"."~вТкст(систВремя.месяц)~"."~вТкст(систВремя.год);
	ткст время = вТкст(систВремя.час)~" ч. "~вТкст(систВремя.минута)~" мин.";

	ткст заг = фм("
	/*******************************************************************************
	*  Файл генерирован автоматически с помощью либпроцессора Динрус               *
	*  Дата:%s                                           Время: %s\n
	*******************************************************************************/

", дата, время);

	ткст имп = фм("
	module lib.%s;

	import stdrus;

	проц грузи(Биб биб)
	{

	", имяМ);

	ткст связка(ткст[] список)
	{
	ткст вяз;

		foreach(выр; список)
			{
			auto рез = убери(выр);
			вяз ~= фм("
		//вяжи(функция_%s)(%s биб);\r\n", счёт, рез);
			счёт++;
			}
		return вяз;
	}

	ткст вяз = связка(список);

	ткст имя = stdrus.взаг(имяМ);

	ткст закр ="
	}\r\n\r\n";


	ткст жб = фм("ЖанБибгр %s;\r\n", имя);

	ткст гр = фм("
		static this()
		{
			%s.заряжай(\"%s.dll\", &грузи );
		}\r\n",имя, имяМ);

	ткст гн = "
	extern(C)
	{\r\n\r\n";

	ткст функ()
	{
	ткст ф;
		for(цел ц = 1; ц < счёт; ц++ )
		{
		  ф ~= фм("
		//проц function() функция_%s; \r\n", ц);
		}
		return  ф;
	}

	ткст ф = функ();

	ткст итог = заг~имп~вяз~закр~жб~гр~гн~ф~закр;

	пишиФайл(имяМ~".d", итог);
	инфо(фм("Сгенерирован макет импорта динамической библиотеки %s,
			результирующий текст которого был записан в файл %s",stdrus.взаг(имяМ), имяМ~".d"));
	return 0;
}

ткст удалитьДубликатыИзТМас(ткст текст)
{
    ткст строка_итог;
    ткст[] список;
	список = разбейнастр(текст);
	цел и;
	int[ткст] предшстр;
	ткст следщстр = "";
	цел проходка = 0;
	цел взято = -1;
	бул взят = нет;

	for( ; и < список.length ; )
	{
	//if(auto т = _сравни(строка, предшстр) == 0) delete список[и]; предшстр = "";

		foreach(строка; список)
		{
			while(проходка == 0){ goto старт;}


		if(строка in предшстр) {delete строка; //_скажинс("удалена предшествующая");
		}

		старт:

			if(строка == следщстр || строка != пусто)
			{
				while(!взят)
				{
				if(строка  in предшстр)
							{
								//_скажинс("А я  тоже грю, конца не будет! ");
							    следщстр = пусто;
								взят = да;
								break;
							}
				//if(строка in предшстр){ _скажинс("бряк!"); break;}
					if(auto т = сравни(строка, список[и]) == 0  )
					{
					//_скажинс(фм("да: %s = %s ; и она будет взята из списка в результат\n", строка, список[и])) ;
					строка_итог ~= строка~"\r\n";
					взято++;
					предшстр[строка] = взято;

				    	foreach(стр; список)
						{

							if(!(стр  in предшстр))
							{
									//_скажинс("Я нужен! А он? ");

									следщстр = стр;
									взят = да;
									break;
							}
						}
					//_скажинс("Бастилия взята!");
					взят = да;

					}
				}

			}
			взят = нет;
			if(!(строка in предшстр) && строка != следщстр && строка != пусто)
			{
			следщстр = строка;
			//_скажинс("Я нужен!");
			}
			else {
			     foreach(стрк; список)
						{
							if(стрк  in предшстр)
								//_скажинс("Типа конец, что ли? ");
							    следщстр = пусто;
								взят = да;
								break;
                        }
					}
			проходка++;
			и++;
			//_скажинс(фм("проходка %s\n, следщстр = %s", проходка, следщстр)) ;
		}

	}
return строка_итог;
}

ткст[] обработатьЛистинг(ткст имяЛ)
{
 ткст буф = cast(ткст) читайФайл(имяЛ~".lst");
  win.скажинс(буф);
  ткст[] список = разбейнастр(буф);
  ткст строка_итог;


  foreach(строка; список)
	{
	auto рез = убери(строка);
	if(рез == "Publics by name		module"||рез == "Publics by module"||рез == "") {рез = пусто;}
	if(рез != пусто) строка_итог ~= рез~"\n";

	}

	список = пусто;
	список = разбей(строка_итог);
	строка_итог = пусто;

	foreach(строка; список)
	{
	auto рез = убери(строка);
	if(рез != пусто) строка_итог ~= "\""~рез~"\",\r\n";

	}
	auto итог = удалитьДубликатыИзТМас(строка_итог);
	 удалиФайл(имяЛ~".lst");
	список = пусто;
	список = разбей(итог);
 return список;
}

export extern(D) проц обработай(ткст имяБ,ткст расшД = "dll", ткст путь = пусто, ткст имяД = пусто )
{
ткст[] список;
if(естьФайл(имяБ~".d")) удалиФайл(имяБ~".d");
if(создайБибИзДлл(имяБ, имяД, путь,расшД))
{
   if(естьФайл(имяБ~".lib"))создайЛистинг(имяБ);
   else exception.ошибка("Листинг файла не найден");

     if(естьФайл(имяБ~".lst"))список = обработатьЛистинг(имяБ);
	 else exception.ошибка("Листинг файла не обработан");
 }
 else exception.ошибка("Не удалось создать библиотеку импорта");
if(список != пусто) генМакетИмпорта(имяБ, список);
//_удалиФайл(имяБ~".lst");
}
///////////////////////////////////////////////////////
