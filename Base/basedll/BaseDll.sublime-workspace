{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "module gc;\n\nprivate import exception, stdrus, sync, sys.WinConsts, cidrus, std.intrinsic, util, rt.lifetime;\n\n\n/************** Отладка ***************************/\n\n//debug = НА_КОНСОЛЬ;\t\t\t// включить эхо'ы\n//debug = COLLECT_PRINTF;\t\t// вкючить эхо'ы\n//debug = THREADINVARIANT;\t// проверить целостность нити\n//debug = LOGGING;\t\t// размещения журналов / освобождения\n//debug = MEMSTOMP;\t\t// stomp on memory\n//debug = SENTINEL;\t\t// добавить underrun/overrrun защиту\n//debug = PTRCHECK;\t\t// дополнительная проверка указателей\n//debug = PTRCHECK2;\t\t// тщательная, но медленная проверка указателей\n//debug = PROFILING;            // measure performance of various steps.\n/*************** Конфигурация *********************/\n//debug = SENTINEL;\n//debug = НА_КОНСОЛЬ;\nversion = СТЭК_РАСТЁТ_ВНИЗ;\t// наращивание стека означает вычитание от указателя стека\n\t\t\t\t// (используется для Intel X86 CPUs)\n\t\t\t\t// иначе наращивание стека означает прибавление к указателю стека\nversion = МНОГОПОТОЧНАЯ;\t// произвести многопоточную версию\n\n    version (МНОГОПОТОЧНАЯ)\n    {\n        extern  (C) бул нить_нужнаБлокировка();\n        extern  (C) проц нить_заморозьВсе();\n        extern  (C) проц нить_разморозьВсе();\n\n        extern  (C) проц нить_сканируйВсе( сканФн fn, ук текВерхСтека = null );\n\t\t\n\t\t//extern (C) бцел dThreadsNumber();\n    }\n/***************************************************/\nconst ИСПОЛЬЗОВАТЬ_КЭШ = true;\n\nconst МАКС_РЕКУРСИЙ_МЕЧЕНИЯ = 64;\n\nenum\n{\n    Б_16,\n    Б_32,\n    Б_64,\n    Б_128,\n    Б_256,\n    Б_512,\n    Б_1024,\n    Б_2048,\n    Б_СТР,             // начало большого размещения\n    Б_СТРПЛЮС,         // продолжение большого размещения\n    Б_ОСВОБ,             // освободить страницу\n    Б_НЕПОДАНО,      // память, не переданная для данной страницы\n    Б_МАКС\n}\n\n\nalias ббайт Бины;\n\n\nstruct Список\n{\n    Список *следщ;\n\tПул *пул;\n}\n\n\nconst т_мера бинразм[Б_МАКС] = [ 16,32,64,128,256,512,1024,2048,4096 ];\nconst т_мера небинразм[Б_МАКС] = [ ~(16-1),~(32-1),~(64-1),~(128-1),~(256-1),\n                                ~(512-1),~(1024-1),~(2048-1),~(4096-1) ];\n\t\t\t\t\t\t\t\t\n\n\n/*============= СМБиты ================================================*/\n\nversion (DigitalMars)\n{\n    version = bitops;\n}\nelse version (GNU)\n{\n    // use the unoptimized version\n}\nelse version(LDC)\n{\n    // ditto\n}\nelse version (D_InlineAsm_X86)\n{\n    version = Asm86;\n}\n\nstruct СМБиты\n{\n\nalias т_мера т_слово;\n    const БИТ_НА_СЛОВО =  (т_слово.sizeof * 8);\n    const СДВИГ_БИТ = (т_слово.sizeof == 8 ? 6 : 5);\n    const МАСКА_БИТ = (БИТ_НА_СЛОВО - 1);\n\tconst БИТЫ_1 = cast(т_слово)1;\n\n    т_слово*  данные = null;\n    т_мера члослов = 0;    // allocated words in данные[] excluding sentinals\n    т_мера члобит = 0;     // number of bits in данные[] excluding sentinals\n\n    проц Дтор()\n    {\n        if (данные)\n        {\n            cidrus.освободи(данные);\n            данные = null;\n        }\n    }\n\n    invariant\n    {\n       инвариант(); \n    }\n\t\nprivate проц инвариант()\n{\nif (данные)\n        {\n            assert(члослов * данные[0].sizeof * 8 >= члобит);\n        }\n\t}\n\n    проц размести(т_мера члобит)\n    {\n        this.члобит = члобит;\n        члослов = (члобит + (БИТ_НА_СЛОВО - 1)) >> СДВИГ_БИТ;\n        данные = cast(typeof(данные[0])*)cidrus.кразмести(члослов + 2, данные[0].sizeof);\n        if (!данные)\n            throw new ВнеПамИскл;\n    }\n\n    т_слово тестируй(т_мера инд)\n    in\n    {\n        assert(инд < члобит);\n    }\n    body\n    {\n        //return (cast(bit *)(данные + 1))[инд];\n        return данные[1 + (инд >> СДВИГ_БИТ)] & (БИТЫ_1 << (инд & МАСКА_БИТ));\n    }\n\n    проц установи(т_мера инд)\n    in\n    {\n        assert(инд < члобит);\n    }\n    body\n    {\n        //(cast(bit *)(данные + 1))[инд] = 1;\n        данные[1 + (инд >> СДВИГ_БИТ)] |= (БИТЫ_1 << (инд & МАСКА_БИТ));\n    }\n\n    проц сбрось(т_мера инд)\n    in\n    {\n        assert(инд < члобит);\n    }\n    body\n    {\n        //(cast(bit *)(данные + 1))[инд] = 0;\n        данные[1 + (инд >> СДВИГ_БИТ)] &= ~(БИТЫ_1 << (инд & МАСКА_БИТ));\n    }\n\n    т_слово тестСброс(т_мера инд)\n    {\n        version (bitops)\n        {\n            return std.intrinsic.btr(данные + 1, инд);\n        }\n        else version (Asm86)\n        {\n            asm\n            {\n                naked                   ;\n                mov     EAX,данные[EAX]   ;\n                mov     ECX,инд-4[ESP]    ;\n                btr     4[EAX],ECX      ;\n                sbb     EAX,EAX         ;\n                ret     4               ;\n            }\n        }\n        else\n        { \n\n            //результат = (cast(bit *)(данные + 1))[инд];\n            //(cast(bit *)(данные + 1))[инд] = 0;\n\n            auto p = &данные[1 + (инд >> СДВИГ_БИТ)];\n            auto  маска = (БИТЫ_1 << (инд & МАСКА_БИТ));\n            auto результат = *p & маска;\n            *p &= ~маска;\n            return результат;\n        }\n    }\n\n    т_слово тестУст(т_мера инд)\n    {\n        version (bitops)\n        {\n            return std.intrinsic.bts(данные + 1, инд);\n        }\n        else version (Asm86)\n        {\n            asm\n            {\n                naked                   ;\n                mov     EAX,данные[EAX]   ;\n                mov     ECX,инд-4[ESP]    ;\n                bts     4[EAX],ECX      ;\n                sbb     EAX,EAX         ;\n                ret     4               ;\n            }\n        }\n        else\n        {  \n            //результат = (cast(bit *)(данные + 1))[инд];\n            //(cast(bit *)(данные + 1))[инд] = 0;\n\n            auto p = &данные[1 + (инд >> СДВИГ_БИТ)];\n            auto  маска = (БИТЫ_1 << (инд & МАСКА_БИТ));\n            auto результат = *p & маска;\n            *p |= маска;\n            return результат;\n        }\n    }\n\n    проц обнули()\n    {\n        version(MEMCPY_NON_SIG_SAFE) {\n            бцел * d1=данные+1,dEnd=d1+члослов;\n            for (;d1!=dEnd;++d1)\n                *d1=0u;\n        } else {\n            cidrus.memset(данные + 1, 0, члослов * т_слово.sizeof);\n        }\n    }\n\n    проц копируй(СМБиты *f)\n    in\n    {\n        assert(члослов == f.члослов);\n    }\n    body\n    {\n        version(MEMCPY_NON_SIG_SAFE) {\n            бцел * d1=данные+1,d2=f.данные+1,dEnd=d1+члослов;\n            for (;d1!=dEnd;++d1,++d2)\n                *d1=*d2;\n        } else {\n            cidrus.memcpy(данные + 1, f.данные + 1, члослов * бцел.sizeof);\n        }\n    }\n\n    т_слово* основа()\n    in\n    {\n        assert(данные);\n    }\n    body\n    {\n        return данные + 1;\n    }\n}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n/* ======================= Детектор Утечки =========================== */\n\n\ndebug (LOGGING)\n{\n    struct Журнал\n    {\n        ук  p;\n        т_мера размер;\n        бдол  строка;\n        усим  файл;\n        ук  родитель;\n\n        проц выведи()\n        {\n            эхо(\"    p = %x, razmer = %d, roditel' = %x \", p, размер, родитель);\n            if (файл)\n            {\n                эхо(\"%s(%u)\", файл, строка);\n            }\n            эхо(\"\\n\");\n        }\n    }\n\n\n    struct МассивЖурналов\n    {\n        т_мера разм;\n        т_мера размпам;\n        Журнал *данные;\n\n        проц Дтор()\n        {\n            if (данные)\n                cidrus.освободи(данные);\n            данные = null;\n        }\n\n        проц резервируй(т_мера члозаписей)\n        {\n            assert(разм <= размпам);\n            if (размпам - разм < члозаписей)\n            {\n                размпам = (разм + члозаписей) * 2;\n                assert(разм + члозаписей <= размпам);\n                if (!данные)\n                {\n                    данные = cast(Журнал*)cidrus.празмести(размпам * Журнал.sizeof);\n                    if (!данные && размпам)\n                        throw new ВнеПамИскл;\n                }\n                else\n                {   Журнал *новданные;\n\n                    новданные = cast(Журнал*)cidrus.празмести(размпам * Журнал.sizeof);\n                    if (!новданные && размпам)\n                        throw new ВнеПамИскл;\n                    cidrus.memcpy(новданные, данные, разм * Журнал.sizeof);\n                    cidrus.освободи(данные);\n                    данные = новданные;\n                }\n            }\n        }\n\n        проц сунь(Журнал журнал)\n        {\n            резервируй(1);\n            данные[разм++] = журнал;\n        }\n\n        проц удали(т_мера инд)\n        {\n            cidrus.memmove(данные + инд, данные + инд + 1, (разм - инд) * Журнал.sizeof);\n            разм--;\n        }\n\n\n        т_мера найди(ук p)\n        {\n            for (т_мера инд = 0; инд < разм; инд++)\n            {\n                if (данные[инд].p == p)\n                    return инд;\n            }\n           return СБОЙ_ОП; // не найдено\n        }\n\n\n        проц копируй(МассивЖурналов *из)\n        {\n            резервируй(из.разм - разм);\n            assert(из.разм <= размпам);\n            cidrus.memcpy(данные, из.данные, из.разм * Журнал.sizeof);\n            разм = из.разм;\n        }\n    }\n}\n\nfinal class СМЗамок:Мютекс { }                // класс для получения глобального замка\n\n/**\n * Данная структура инкапсулирует в себе функциональность сборщика мусора\n * языка программирования Динрус.\n */\n \n const бцел ВЕРСИЯ = 1;  \n//////////////////////////////////////\n\n/*========= СБОРЩИК МУСОРА ==============*/\n\nalias СборщикМусора СМ, т_см;\nexport extern (D) class СборщикМусора\n{\n\n    // Для передачи отладочному коду\n    static т_мера  строка;\n    static усим  файл;\n\n\tGcx *gcx;                   // реализация\n    static ИнфОКлассе смЗамок;    // глобальный замок\n\t\nprivate т_см экз;\n\nthis()\n{\n\t\tClassInfo ci = СМ.classinfo;\n\t\tэкз = cast(т_см) cidrus.празмести(ci.init.length);\n\t\t(cast(байт*)экз)[0 .. ci.init.length] = ci.init[];\n\t\t//эхо(\"Returning from смНовый all\\n\");\n\t\tthis = cast(СМ) экз;\n\t\tthis.иниц();\n}\n\n~this()\n{\nthis.Дтор();\ncidrus.освободи(cast(ук )экз);\n}\n\nexport extern (D)  бцел версия(){return ВЕРСИЯ;}\n\nexport extern (D) проц иниц()\n    {\n        смЗамок = СМЗамок.classinfo;\n        gcx = cast(Gcx*)cidrus.кразмести(1, Gcx.sizeof);\n        if (!gcx)\n            throw new ВнеПамИскл;\n        gcx.иниц();\n        устНизСтэка(util.ртНизСтэка());\n\t\t//эхо(\"СМ initialized\");\n    }\n\t\n\t    export extern (D) проц Дтор()\n    {\n        if (gcx)\n        {\n            gcx.Дтор();\n            cidrus.освободи(gcx);\n            gcx = null;\n        }\n    }\n\t\n\t invariant\n    {\n\tинвариант();\n    }\n\t\nprivate проц инвариант()\n{\n        if (gcx)\n        {\n            gcx.инвариант_Нити();\n        }\n}\n\n\t\n\texport extern (D) проц монитор (проц delegate() начало, проц delegate(цел, цел) конец)\n    {\n        gcx.началоСборки = начало;\n        gcx.конецСборки = конец;\n    }\n\t\n    /**\n     * Активирует сборку мусора, если она ранее была приостановлена\n     *вызовом откл.  Это функция повторно-входимая, она должна\n     * вызываться единожды для каждого вызова откл, перед активацией\n     * мусоросборщика.\n     */\n    export extern (D) проц вкл()\n    {\n        if (!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            assert(gcx.отключен > 0);\n            gcx.отключен--;\n        }\n        else synchronized (смЗамок)\n        {\n            assert(gcx.отключен > 0);\n            gcx.отключен--;\n        }\n    }\n\n    /**\n     * Отключает мусоросборщик.  Это функция повторного входа, но\n     * откл нужно вызывать для каждого вкл.\n     */\n    export extern (D) проц откл()\n    {\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            gcx.отключен++;\n        }\n        else synchronized (смЗамок)\n        {\n            gcx.отключен++;\n        }\n    }\n\n    /**\n     * Активирует полную сборку.  Хотя значение этой функции может меняться\n\t* в зависимости от реализации сборщика мусора,\n     * как правило, она сканирует все сегменты стека на наличие\n     * корней (ветвлений), помечает доступные блоки памяти как \"живые\",\n     * а затем отзывает свободное пространство.  Для этого действа может\n     * потребоваться приостановка всех запущенных нитей, как  минимум,\n\t  * для соответствующей части процесса сборки.\n\t  */\n    export extern (D) проц собери()\n    {\n        полныйСбор();\n    }\n\n    /**\n     * Указывает на то, что можно уменьшить обрабатываемое пространство\n\t * памяти путём возврата свободной физической памяти операционной системе.\n\t * Количество возвращаемой свободной памяти зависит от\n     * дизайна разместителя и от поведения программы.\n     */\n    export extern (D) проц уменьши()\n    {\n        экономь();\n    }\n       \n    /**\n     * Возвращает бит-поле, представляющее собой все атрибуты блока, установленные для\n\t * памяти, на которую ссылается p. Если p ссылается на пямять, изначально распределенную\n\t * не этим мусоросборщиком, то указывает на внутренности блока памяти, или если if p\n     * нулевой, возвращает ноль.\n     *\n     * Параметры:\n     *  p = Указатель на корень действительного блока памяти или на пусто.\n     *\n     * Возвращает:\n     *  Бит-поле, содержащее какие-либо биты, установленные для блока памяти, на который\n\t * указывает  p, или ноль при ошибке.\n     */\n    export extern (D) бцел дайАтр( ук p )\n    {\n         if (!p)\n        {\n            return 0;\n        }\n\n        бцел go()\n        {\n            Пул* пул = gcx.найдиПул(p);\n            бцел  старб = 0;\n\n            if (пул)\n            {\n                auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;\n\n                старб = gcx.дайБиты(пул, битинд);\n            }\n            return старб;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return go();\n        }\n        else synchronized (смЗамок)\n        {\n            return go();\n        }\n    }\n\n    /**\n     * Устанавливает указаннные биты для обращений к памяти переменной p.  Если p обращается\n     * к памяти, размещённой изначально не данным сборщиком, указывает внутрь блока памяти\n     * либо содержит значение пусто, никакого действия не последует.\n     *\n     * Параметры:\n     *  p = Указатель на корень действительного блока памяти, либо в пусто.\n     *  a = Битполе с любыми битами, устанавливаемыми для данного блока памяти.\n     *\n     *  Результат вызова дайАтр устанавливается после установки указанного бита.\n     */\n    export extern (D) бцел устАтр( ук p, ПАтрБлока маска )\n    {\n         if (!p)\n        {\n            return 0;\n        }\n\n        бцел go()\n        {\n            Пул* пул = gcx.найдиПул(p);\n            бцел  старб = 0;\n\n            if (пул)\n            {\n                auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;\n\n                старб = gcx.дайБиты(пул, битинд);\n                gcx.устБиты(пул, битинд, маска);\n            }\n            return старб;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return go();\n        }\n        else synchronized (смЗамок)\n        {\n            return go();\n        }\n    }\n\n    /**\n     * Удаляет указанные биты для обращения к памяти переменной p.  Если p обращается\n     * к памяти, размещённой изначально не данным сборщиком, указывает внутрь блока памяти\n     * либо содержит значение пусто, никакого действия не последует.\n     *\n     * Параметры:\n     *  p = Указатель на корень действительного блока памяти, либо в пусто.\n     *  a = Битполе с любыми битами, устанавливаемыми для данного блока памяти.\n     *\n     *  Результат вызова дайАтр устанавливается после установки указанного бита.\n     */ \n    export extern (D) бцел удалиАтр( ук p, ПАтрБлока маска )\n    {\n        if (!p)\n        {\n            return 0;\n        }\n\n        бцел go()\n        {\n            Пул* пул = gcx.найдиПул(p);\n            бцел  старб = 0;\n\n            if (пул)\n            {\n                auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;\n\n                старб = gcx.дайБиты(пул, битинд);\n                gcx.удалиБиты(пул, битинд, маска);\n            }\n            return старб;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return go();\n        }\n        else synchronized (смЗамок)\n        {\n            return go();\n        }\n    }\n\n    /**\n     * Запрашивает размеченный блок управляемой памяти у мусоросборщика.\n     * Эту память при желании можно удалить, вызвав cidrus.освободи, либо её можно\n     * сбросить и освободить автоматически, при пуске очистки. Если\n     * распределение неудачно, то эта функция вызывает onOutOfMemory,\n     * от которого ожидается вывод OutOfMemoryException.\n     *\n     * Параметры:\n     *  разм = Желаемый размер размещения в байтах.\n     *  ba = Битмаска атрибутов, для установки на данном блоке.\n     *\n     * Возвращает:\n     *  Ссылку на распределенную память или пусто, если памяти\n     *  недостаточно.\n     *\n     * Выводит:\n     *  OutOfMemoryException при неудачном распределении.\n     */\n    export extern (D) ук празмести(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)\n    {\n        if (!размер)\n        {\n\t\t  if(разм_размещ)\n                *разм_размещ = 0;\n            return null;\n        }\n\n        // Т.к. финализатор может запустить новый поток, при сборке всегда\n        // нужна блокировка. Это лучше всегда делать при\n        // помещении в оперативку.\n        synchronized (смЗамок)\n        {\n\t\t//эхо(\"Passed to mallocNoSync\\n\");\n            return mallocNoSync(размер, биты, разм_размещ);\n        }\n    }\n\n    /**\n     * Запрашивает у сборщика мусора размещённый блок управляемой памяти,\n     * который инициализуется со всеми битами, установленными в ноль. Эту память по желанию\n     * можно удалить вызовом cidrus.освободи, или сбросить или очистить автоматически при\n     * запуске сборки.  If allocation fails, this\n     * function will вызови onOutOfMemory which is expected to throw an\n     * OutOfMemoryException.\n     *\n     * Параметры:\n     *  разм = The desired allocation размер in байтs.\n     *  ba = A bitmask of the attributes to установи on this block.\n     *\n     * Возвращает:\n     *  A ссылка to the allocated memory or пусто if insufficient memory\n     *  is available.\n     *\n     * Выводит:\n     *  OutOfMemoryException on allocation failure.\n     */\n    export extern (D) ук кразмести(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)\n    {\n        if (!размер)\n        {\n\t\t    if(разм_размещ)\n                *разм_размещ = 0;\n            return null;\n        }\n        synchronized (смЗамок)\n        {\n            return callocNoSync(размер, биты, разм_размещ);\n        }\n    }\n\n    /**\n     * Если разм равно нулю, то память, на которую указывает p, будет освобождена,\n     * как это бывает при вызове cidrus.освободи.  Затем новый блок памяти размером в разм\n\t * будет распределен, как это бывает при вызове cidrus.празмести, либо вместо этого\n\t * реализация может на месте изменить блок в размере. Содержимое нового\n     * блока памяти будет таким же, как у старого блока, до наименьшего общего\n     * между новым и старым размерами. Запомните, что существующая память будет\n     * освобождена только, если разм равно нулю. Впоследствии от сборщика мусора\n     * ожидается отзыв этого блока памяти, если он более не используется.\n     * Если распределение не удалось, эта функция вызывает onOutOfMemory,\n\t * от которого ожидается вывод исключения OutOfMemoryException. Если же p\n\t  * указывает на память, ранее размещенную не этим мусоросборщиком, \n\t  * либо если он указывает во внутрь блока памяти, то никакого действия\n\t  * не предпринимается. Если ba равно нулю (по умолчанию),\n\t  * а p указывает на главу действительного, известного блока памяти,\n     * тогда все биты, установленные на текущем блоке, будут перенесены на новый блок,\n\t * если потребуется перемещение. Если ba не равно нулю, а p указывает на\n     * главу действительного, известного блока памяти, тогда биты из ba заменят\n     * биты в текущем блоке памяти, а также будут установлены на новом блоке,\n     * если понадобится перемещение.\n     *\n     * Параметры:\n     *  p  = Указатель на корень действительного блока памяти или на пусто.\n     *  разм = Необходимый размер размещения в байтах.\n     *  ba = Бит-маска атрибутов, которые нужно установить на данном блоке.\n     *\n     * Возвращает:\n     *  Ссылку на размещенную память при успехе, либо пусто, если разм равно\n     *  нулю. При неудаче возвращается исходное значение p.\n     *\n     * Выводит:\n     *  OutOfMemoryException при неудачном размещении.\n     */\n    export extern (D) ук перемести(ук p, т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)\n    {\n        synchronized (смЗамок)\n        {\n            return reallocNoSync(p, размер, биты, разм_размещ);\n        }\n    }\n\n    /**\n     * Запрашивает, чтобы блок управляемой памяти,  на который ссылается p,\n\t * был увеличен на месте, как минимум на mx байт, с желательным расширением на\n\t * разм байт. Если расширение требуемой памяти невозможно,\n     * и p ссылается на память, ранее размещенную другим сборщиком,\n\t * либо же p указывает внутрь блока память,\n\t * то никаких действий не предпринимается.\n     *\n     * Параметры:\n     *  mx = Минимальный размер расширения в байтах.\n     *  разм = Желаемый размер расширения в байтах.\n     *\n     * Возвращает:\n     *  Размер в байтах расширенного блока памяти, показываемого p, или обнули,\n     *  если расширения не произошло.\n     */\n    export extern (D) т_мера расширь(ук p, т_мера минразм, т_мера максразм)\n    {\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return extendNoSync(p, минразм, максразм);\n        }\n        else synchronized (смЗамок)\n        {\n            return extendNoSync(p, минразм, максразм);\n        }\n    }\n\n    /**\n     * Запрашивает получение от операционной системы как минимум разм байтов\n     * с пометкой их как \"свободные\".\n     *\n     * Параметры:\n     *  разм = Требуемый размер в байтах.\n     *\n     * Возвращает:\n     *  Действительное число размещенных байтов или ноль при ошибке.\n     */\n    export extern (D) т_мера резервируй(т_мера размер)\n    {\n        if (!размер)\n        {\n            return 0;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return reserveNoSync(размер);\n        }\n        else synchronized (смЗамок)\n        {\n            return reserveNoSync(размер);\n        }\n    }\n\n    /**\n     * Вымещает память, на которую показывает p.  Если p равен нулю, никаких\n     * действий не предпринимается. Если p ссылается на память, ранее размещенную другим\n\t * мусоросборщиком, или он указывает внутрь блока памяти,\n     * действий не последует. Этот блок останется не финализированным, несмотря на то,\n\t * установлен или нет атрибут Финализовать. Если требуется финализация,\n     * то следует использовать delete.\n     *\n     * Параметры:\n     *  p = Указатель на корень действующего блока памяти или в пусто.\n     */\n    export extern (D) проц освободи( ук p )\n    {\n        if (!p)\n        {\n            return;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return freeNoSync(p);\n        }\n        else synchronized (смЗамок)\n        {\n            return freeNoSync(p);\n        }\n    }\n\n    /**\n     * Возвращает адрес базы блока памяти, содержащего p.  Это значение\n     * может использоваться для определения того, является ли p\n\t * внутренним указателем, а результат может передаваться\n     * процедурам типа sizeOf, которые в противном случае могут не срабатывать.\n\t * Если p ссылается на память, которую изначально выделил не этот\n\t * сборщик мусора, если p = пусто, или сборщик мусора не поддерживает\n     * данную операцию, то будет возвращено пусто.\n     *\n     * Параметры:\n     *  p = A pointer to the корень or the interior of a valid memory block or to\n     *      пусто.\n     *\n     * Возвращает:\n     *  The base address of the memory block referenced by p or пусто on error.\n     */\n    export extern (D) ук адрес_у( ук p )\n    {\n        if (!p)\n        {\n            return null;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return addrOfNoSync(p);\n        }\n        else synchronized (смЗамок)\n        {\n            return addrOfNoSync(p);\n        };\n    }\n\n    /**\n     * Возвращает настоящий размер блока памяти, указанного p.  Это значение\n     * представляет максимальный размер в байтах, в который вызовом realloc \n     * можно на месте изменить существующий блок.  If p references memory not\n     * originally allocated by this garbage collector, points to the interior\n     * of a memory block, or if p is пусто, ноль will be returned.\n     *\n     * Параметры:\n     *  p = A pointer to the корень of a valid memory block or to пусто.\n     *\n     * Возвращает:\n     *  Размер в байтах of the memory block referenced by p or ноль on error.\n     */\n    export extern (D) т_мера размер_у( ук p )\n    {\n        if (!p)\n        {\n            return 0;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return sizeOfNoSync(p);\n        }\n        else synchronized (смЗамок)\n        {\n            return sizeOfNoSync(p);\n        }\n    }\n\n    /**\n     * Возвращает совокупную информацию о блоке памяти, содержащем p.  Если p\n     * ссылается на память, исходно установленную не этим сборщиком мусора, \n     *или p имеет значение пусто, либо СМ не поддерживает эту операцию, будет\n     * выдано ИнфОБл.init. Как правило, поддержка данной операции зависит от поддержки\n     * функции адрес_у.\n     *\n     * Параметры:\n     *  p = Указатель на корень или внутренность валидного блока памяти\n     *   либо на  пусто.\n     *\n     * Возвращает:\n     *  Информацию, касающуюся блока бамяти, на который ссылается p, или ИнфОБл.init\n     *  при ошибке.\n     */\n    export extern (D) ИнфОБл опроси( ук p )\n    {\n        if (!p)\n        {\n            ИнфОБл инд;\n            return  инд;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return queryNoSync(p);\n        }\n        else synchronized (смЗамок)\n        {\n            return queryNoSync(p);\n        }\n    }\n\t\n\t    /**\n     * Проверяет указатель p:\n     *  1) на принадлежность к данному пулу памяти\n     *  2) на то, что он указывает на начало размещенного куска памяти\n     *  3) что его нет в списке очистки\n     */\n    export extern (D) проц проверь(ук p)\n    {\n        if (!p)\n        {\n            return;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            checkNoSync(p);\n        }\n        else synchronized (смЗамок)\n        {\n            checkNoSync(p);\n        }\n    }\n\n    /**\n     * Добавляет адрес памяти, на который ссылается p, во внутренний список корней,\n     * подлежащих сканированию при сборке.  Если p = пусто, никакой операции\n     * не выполняется.\n     *\n     * Параметры:\n     *  p = Указатель на действительный адрес памяти или в пусто.\n     */\n    export extern (D) проц добавьКорень( ук p )\n    {\n        if (!p)\n        {\n            return;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            gcx.добавьКорень(p);\n        }\n        else synchronized (смЗамок)\n        {\n            gcx.добавьКорень(p);\n        }\n    }\n\t\n\t\n\t\t /**\n     *\n     */\n  export extern (D)  цел delegate(цел delegate(ref ук)) обходКорня()\n    {\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return &gcx.обходКорня;\n        }\n        else synchronized (смЗамок)\n        {\n            return &gcx.обходКорня;\n        }\n    }\n\n    /**\n     * Добавляет блок памяти, указанный p размера разм во внутренний список\n     * сканируемых при сборке диапазонов.  Если p пусто, то никаких действий\n     * не предпринимается.\n     *\n     * Параметры:\n     *  p  = Указатель на действительный адрес памяти или в пусто.\n     *  разм = Размер в байтах добавляемого блока.  Если разм = нуль, то\n     *      ничего не произойдёт. Если p = пусто, то разм должен быть нуль.\n     */\n////////////////////////////////\t \n    export extern (D) проц добавьПространство( ук p, т_мера разм )\n    {\n        debug(НА_КОНСОЛЬ) эхо(\"addR1: ук, т_мера\");\n        if (!p || !разм)\n        {\n            return;\n        }\n\n        debug(НА_КОНСОЛЬ) скажифнс(\"+СМ.добавьПространство(Низ = x%x, Верх = x%x)\\n\", Низ, Верх);\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            gcx.добавьПространство(p, p + разм);\n        }\n        else synchronized (смЗамок)\n        {\n            gcx.добавьПространство(p, p + разм);\n        }\n        debug(НА_КОНСОЛЬ) скажи(\"-СМ.добавьПространство()\\n\");\n    }\n/////////////////////////////////////////\t\n\texport extern (D) проц добавьПространство(ук Низ, ук Верх)\n    {\n\tdebug(НА_КОНСОЛЬ) скажинс(\" addR2: ук, ук\");\n        if (!Низ || !Верх)\n        {\n            return;\n        }\n\n\tdebug(НА_КОНСОЛЬ) скажифнс(\"+СМ.добавьПространство(Низ = x%x, Верх = x%x)\\n\", Низ, Верх);\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n\t    gcx.добавьПространство(Низ, Верх);\n        }\n        else synchronized (смЗамок)\n\t{\n\t    gcx.добавьПространство(Низ, Верх);\n\t}\n\tdebug(НА_КОНСОЛЬ) скажи(\"-СМ.добавьПространство()\\n\");\n    }\n//////////////////////////\t\n\texport extern (D) цел delegate(цел delegate(ref Пространство)) обходПространства()\n    {\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return &gcx.обходПространства;\n        }\n        else synchronized (смЗамок)\n        {\n            return &gcx.обходПространства;\n        }\n    }\n\n    /**\n     * Удаляет блок памяти, указанный p, из внутреннего списка \"корней\" (ветвей),\n     * подлежащих сканированию при сборке. Если p = пусто или не представляет собой\n     * ранее переданное add(ук) значение, то никакого действия не происходит.\n     *\n     *  p  = Указатель на действительный адрес памяти или в пусто.\n     */\n\t \n    export extern (D) проц удалиКорень( ук p )\n    {\n        if (!p)\n        {\n            return;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            gcx.удалиКорень(p);\n        }\n        else synchronized (смЗамок)\n        {\n            gcx.удалиКорень(p);\n        }\n    }\n\n    /**\n     * Удаляет блок памяти, на к-й ссылается p, из внутреннего списка диапазонов,\n     * подлежащих сканированию при сборке мусора. Если p пусто или не представляет значение,\n     * ранее переданное add(ук, т_мера), то никакой операции не выполняется.\n     *\n     * Параметры:\n     *  p  = Указатель на действительный адрес памяти или в пусто.\n     */\n    export extern (D) проц удалиПространство( ук p )\n    {\n        if (!p)\n        {\n            return;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            gcx.удалиПространство(p);\n        }\n        else synchronized (смЗамок)\n        {\n            gcx.удалиПространство(p);\n        }\n    }\n\t\n\t        \n    export extern (D) проц мониторируй( проц delegate() начало, проц delegate(цел, цел) конец )\n    {\n        монитор( начало, конец );\n    }   \n\n    /**\n     * Создаёт слабый указатель на данный объект.\n     * Возвращает указатель на плотную структуру, размещённую в памяти Си.\n     */\n    export extern (D) ук создайСлабУк( Объект r )\n    {\n        if (r)\n           {\n           //должно быть размещено в памяти C\n           //1. чтобы скрыть ссылку от СМ\n           //2. этот СМ не сканирует делегатов, добавленных rt_detachDisposeEvent, на ссылки\n           auto wp = cast(СлабыйУказатель*)(cidrus.празмести(СлабыйУказатель.sizeof));\n           if (!wp)\n               throw new ВнеПамИскл();\n           wp.ссылка = r;\n           object.rt_attachDisposeEvent(r, &wp.ondestroy);\n           return wp;\n           }\n               return null;\n    }\n\n\n    /**\n     * Удаляет слабый указатель, возвращённый создайСлабУк().\n     * Если передано пусто, ничего не происходит.\n     */\n    export extern (D) проц удалиСлабУк( ук p )\n    {\n        if (p)        \n           {\n           auto wp = cast(СлабыйУказатель*)p;\n           //must be extra careful about the СМ or parallel threads finalizing the\n           //ссылка at the same time\n           locked!(проц)({\n                   if (wp.ссылка)\n                       object.rt_detachDisposeEvent(wp.ссылка, &wp.ondestroy);\n                  });\n           cidrus.освободи(wp);\n           }\n    }\n\n    /**\n     * Опросить слабук, вернув либо Объект, переданный методу\n     * создайСлабУк, либо пусто, если он был удалён.\n     * Если передаётся пусто, пусто и возвращается.\n     */\n    export extern (D) Объект дайСлабУк( ук p )\n    {\n        if (p)\n           {\n           //NOTE: could avoid the блокируй by using Fawzi style СМ counters\n           // but that'd require core.sync.Atomic and lots of care about memory consistency\n           // it's an optional optimization\n           //see http://dsource.org/projects/tango/browser/trunk/user/tango/core/Lifetime.d?rev=5100#L158\n           return locked!(Объект)({\n                  return (cast(СлабыйУказатель*)p).ссылка;\n                  });\n           }\n        return null;\n    }\n\n    /**\n    * returns the amount to allocate to оставить some extra space\n    * for large allocations the extra allocated space decreases, but is still enough\n    * so that the number of reallocations when linearly growing stays logaritmic\n    * Параметры:\n    * новДлина = the number of elements to allocate\n    * размЭлта = размер of one element\n    */\n    export extern (D) т_мера нарастиДлину (т_мера новДлина, т_мера размЭлта=1)\n    {   \n        return нарастиДлину (новДлина, размЭлта, 100, 0, 1);\n    }\n    \n    /**\n    * returns the amount to allocate to оставить some extra space\n    * for large allocations the extra allocated space decreases, but is still enough\n    * so that the number of reallocations when linearly growing stays logaritmic\n    * Параметры:\n    * новДлина = the number of elements to allocate\n    * размЭлта = размер of one element\n    * a = maximum extra space in percent (the allocated space gets rounded up, so might be larger)\n    * b = flatness factor, how fast the extra space decreases with массив размер (the larger the more constant)\n    * minBits = minimum number of bits of новДлина\n    */\n    export extern (D) т_мера нарастиДлину(т_мера новДлина, т_мера размЭлта, т_мера a, т_мера b=0, т_мера minBits=1)\n    {\n        static т_мера log2(т_мера c)\n        {\n            // could use the bsr bit op\n            т_мера инд=1;\n            while(c >>= 1)\n                  ++инд;\n            return инд;\n        }\n\n        т_мера newext = 0;\n        т_мера newcap = новДлина*размЭлта;\n        дол mult = 100 + a*(minBits+b) / (log2(новДлина)+b);\n        newext = размЭлта*cast(т_мера)(((newcap * mult)+99) / 100);\n        newcap = newext > newcap ? newext : newcap; // just to хэндл overflows\n        return newcap;\n    }\n\n   /**\n     * Выполнить полную сборку мусора\n     */\n    export extern (D) проц полныйСбор()\n    {\n        debug(НА_КОНСОЛЬ) скажи(\"СМ.полныйСбор()\\n\");\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            gcx.полная_уборка();\n        }\n        else synchronized (смЗамок)\n        {\n            gcx.полная_уборка();\n        }\n\n        version (none)\n        {\n            СМСтат стат;\n\n            getStats(стат);\n            debug(НА_КОНСОЛЬ) скажифнс(\"razmerPula = %x, ispRazmer = %x, razmSpiskaSvobBlokov = %x\\n\",\n                    стат.размерПула, стат.испРазмер, стат.размСпискаСвобБлоков);\n        }\n\n        gcx.журнал_сборка();\n    }\n\t\n   /**\n     * Выполнить полный сбор мусора, игнорируя корни\n     */\n    export extern (D) проц полныйСборБезСтэка()\n    {\n        // Поскольку финализатор способен запустить новую нить, всегда надо блокировать\n        // при сборе.\n        synchronized (смЗамок)\n        {\n            gcx.безСтэка++;\n            gcx.полная_уборка();\n            gcx.безСтэка--;\n        }\n    }\n\t\n/**\n     * Выполнить генерационный сбор мусора\n     */\n    export extern (D) проц генСбор()\n    {\n\tsynchronized (смЗамок)\n\t{\n\t    gcx.полная_уборка();\n\t}\n    }\n///////////////////////////////\n\texport extern (D) проц естьУказатели(ук p)\n    {\n\tsynchronized (смЗамок)\n\t{\n\t    gcx.ЕстьУказатели(p);\n\t}\n    }\n/////////////////////////\n\texport extern (D) проц нетУказателей(ук p)\n    {\n\tif (!gcx.консервативный)\n\t{   synchronized (смЗамок)\n\t    {\n\t\tgcx.НетУказателей(p);\n\t    }\n\t}\n    }\n////////////////////////\n\texport extern (D) проц устВ1_0()\n    {\n\tgcx.консервативный = 1;\n    }\n///////////////////\n/**\n     * Определить размещённый размер указателя p.  If p is an interior pointer\n     * or not a gc allocated pointer, return 0.\n     */\n   export extern (D) т_мера ёмкость(ук p)\n    {\n        if (!p)\n        {\n            return 0;\n        }\n\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            return sizeOfNoSync(p);\n        }\n        else synchronized (смЗамок)\n        {\n            return sizeOfNoSync(p);\n\t\t}\n     }\n//////////////\n    export extern (D) проц сканируйСтатДан(т_см g)\n    {\n\tук Низ;\n\tук Верх;\n\tбцел члобайт;\n\n\tdebug(НА_КОНСОЛЬ) скажи(\"+СМ.сканируйСтатДан()\\n\");\n\tос_запроссегментастатдан(&Низ, &члобайт);\n\tВерх = Низ + члобайт;\n\tg.добавьПространство(Низ, Верх);\n\tdebug(НА_КОНСОЛЬ) скажи(\"-СМ.сканируйСтатДан()\\n\");\n    }\n\n    export extern (D) проц отсканируйСтатДан(т_см g)\n    {\n\tук Низ;\n\tбцел члобайт;\n\n\tос_запроссегментастатдан(&Низ, &члобайт);\n\tg.удалиПространство(Низ);\n    }\n///////////////////////////////////////\n    /**\n     * минимизировать использование пространства\n     */\n    export extern (D) проц экономь()\n    {\n        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            gcx.экономь();\n        }\n        else synchronized (смЗамок)\n        {\n            gcx.экономь();\n        }\n    }\n///////////////////////////////////////////\t\n/**\n     * Получить статистику о сборке мусора.\n     * Применимо при отладке и настройке.\n     */\n    export extern (D) проц дайСтат(out СМСтат стат)\n    {\n       if (!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)\n        {\n            getStatsNoSync(стат);\n        }\n        else synchronized (смЗамок)\n        {\n            getStatsNoSync(стат);\n        }\n    }\n\t\n\texport extern (D) проц устФинализатор(ук p, ФИНАЛИЗАТОР_СМ pFn)\n    {\n\tsynchronized (смЗамок)\n\t{\n\t    gcx.финализатор = pFn;\n\t    gcx.заверши(p);\n\t}\n    }\n\t\n//////////////////////////////////////////////////////////////////////////////////////////\nprivate:\n//////////////////////////////////////////////\nук mallocNoSync(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)\n//////////////////////////////////////////////\n    {\n        assert(размер != 0);\n\n        ук p = null;\n        Бины бин;\n\t\tцел состояние;\n        бул собрано;\n\n        assert(gcx);\n\n\t\t    if (gcx.пущен)\n            throw new Исключение(\"Ошибочная операция с памятью\", __FILE__, __LINE__);\n\n        размер += SENTINEL_EXTRA;\n\t\tбин = gcx.найдиБин(размер);\n        Пул *пул;\n\n        if (бин < Б_СТР)\n        {\n\t\t     if(разм_размещ)\n                *разм_размещ = бинразм[бин];\n           состояние = gcx.отключен ? 1 : 0;\n            собрано = false;\n\n            while (!gcx.бак[бин] && !gcx.разместиСтраницу(бин))\n            {\n                switch (состояние)\n                {\n                case 0:\n                    т_мера удалённые_страницы = gcx.полная_уборка();\n                    собрано = true;\n                    if (удалённые_страницы < gcx.чло_пулов * ((РАЗМЕР_ПУЛА / РАЗМЕР_СТРАНИЦЫ) / 8))\n                    {   \n                        gcx.новыйПул(1, false);\n                        состояние = 2;\n                    }\n                    else\n                        состояние = 1;\n                    continue;\n                case 1:\n                    gcx.новыйПул(1, false);\n                    состояние = 2;\n                    continue;\n                case 2:\n                    if (собрано)\n                        throw new ВнеПамИскл();\n                    состояние = 0;\n                    continue;\n                default:\n                    assert(false);\n                }\n            }\n            p = gcx.бак[бин];\n\n            gcx.бак[бин] = (cast(Список*)p).следщ;\n            if( !(биты & ПАтрБлока.НеСканировать) )\n                cidrus.memset(p + размер, 0, бинразм[бин] - размер);\n            debug(НА_КОНСОЛЬ) скажифнс(\"\\tcidrus.празмести => %x\\n\", p);\n            debug (MEMSTOMP) cidrus.memset(p, 0xF0, размер);\n        }\n        else\n        {\n            p = gcx.большоеРазмещение(размер, &пул, разм_размещ);\n            if (!p)\n                throw new ВнеПамИскл();\n        }\n        размер -= SENTINEL_EXTRA;\n        p = сентинель_добавь(p);\n        сентинель_иниц(p, размер);\n        gcx.журнал_празмести(p, размер);\n\n        if (биты)\n        {\n            пул = gcx.найдиПул(p);\n            assert(пул);\n\n            gcx.устБиты(пул, cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа, биты);\n        }\n\t\tdebug(НА_КОНСОЛЬ) скажифнс(\"Возврат из cidrus.празмести %i\\n\", p);\n        return p;\n    }\n/////////////////////////////////////////////\t\nук callocNoSync(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)\n/////////////////////////////////////////////\n    {\n        assert(размер != 0);\n\n        //debug(НА_КОНСОЛЬ) скажифнс(\"cidrus.кразмести: %x len %d\\n\", p, len);\n        ук p = mallocNoSync(размер, биты, разм_размещ);\n        cidrus.memset(p, 0, размер);\n        return p;\n    }\n////////////////////////////////////////////////////\t\nук reallocNoSync(ук p, т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)\n////////////////////////////////////////////////////\n    {\n        if (!размер)\n        {   if (p)\n            {   freeNoSync(p);\n                p = null;\n            }\n\t\t\tif(разм_размещ)\n                *разм_размещ = 0;\n        }\n        else if (!p)\n        {\n            p = mallocNoSync(размер, биты, разм_размещ);\n        }\n        else\n        {   ук p2;\n            т_мера размук;\n\n            version (SENTINEL)\n            {\n                сентинель_Инвариант(p);\n                размук = *сентинель_размер(p);\n                if (размук != размер)\n                {\n                    if (размук)\n                    {\n                        Пул *пул = gcx.найдиПул(p);\n\n                        if (пул)\n                        {\n                            auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;\n\n                            if (биты)\n                            {\n                                gcx.удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты);\n                                gcx.устБиты(пул, битинд, биты);\n                            }\n                            else\n                            {\n                                биты = gcx.дайБиты(пул, битинд);\n                            }\n                        }\n                    }\n                    p2 = mallocNoSync(размер, биты, разм_размещ);\n                    if (размук < размер)\n                        размер = размук;\n                    cidrus.memcpy(p2, p, размер);\n                    p = p2;\n                }\n            }\n            else\n            {\n                размук = gcx.найдиРазмер(p);        // найди allocated размер\n                if (размук >= РАЗМЕР_СТРАНИЦЫ && размер >= РАЗМЕР_СТРАНИЦЫ)\n                {\n                    auto psz = размук / РАЗМЕР_СТРАНИЦЫ;\n                    auto newsz = (размер + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;\n                    if (newsz == psz)\n                        return p;\n\n                    auto пул = gcx.найдиПул(p);\n                    auto номерстр = (p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;\n\n                    if (newsz < psz)\n                    {   // Shrink in place\n                        synchronized (смЗамок)\n                        {\n                            debug (MEMSTOMP) cidrus.memset(p + размер, 0xF2, размук - размер);\n                            пул.освободиСтраницы(номерстр + newsz, psz - newsz);\n                        }\n\t\t\t\t\t\tif(разм_размещ)\n                            *разм_размещ = newsz * РАЗМЕР_СТРАНИЦЫ;\n                        return p;\n                    }\n                    else if (номерстр + newsz <= пул.члостр)\n                    {\n                        // Attempt to expand in place\n                        synchronized (смЗамок)\n                        {\n                            for (т_мера инд = номерстр + psz; 1;)\n                            {\n                                if (инд == номерстр + newsz)\n                                {\n                                    //debug (MEMSTOMP) cidrus.memset(p + размук, 0xF0, размер - размук);\n                                    cidrus.memset(&пул.таблица_страниц[номерстр + psz], Б_СТРПЛЮС, newsz - psz);\n\t\t\t\t\t\t\t\t\tпул.обновиСмещения(номерстр);\n                                    if(разм_размещ)\n                                        *разм_размещ = newsz * РАЗМЕР_СТРАНИЦЫ;\n                                    пул.свобстры -= (newsz - psz);\n                                    return p;\n                                }\n                                if (инд == пул.члопереданных)\n                                {\n                                    auto u = пул.увеличьСтраницы(номерстр + newsz - пул.члопереданных);\n                                    if (u == СБОЙ_ОП)\n                                        break;\n                                    инд = номерстр + newsz;\n                                    continue;\n                                }\n                                if (пул.таблица_страниц[инд] != Б_ОСВОБ)\n                                    break;\n                                инд++;\n                            }\n                        }\n                    }\n                }\n                if (размук < размер ||             // if new размер is bigger\n                    размук > размер * 2)           // or less than half\n                {\n                    if (размук)\n                    {\n                        Пул *пул = gcx.найдиПул(p);\n\n                        if (пул)\n                        {\n                            auto битинд = cast(т_мера)(p - пул.адрОсновы)  >> пул.смещНа;\n\n                            if (биты)\n                            {\n                                gcx.удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты);\n                                gcx.устБиты(пул, битинд, биты);\n                            }\n                            else\n                            {\n                                биты = gcx.дайБиты(пул, битинд);\n                            }\n                        }\n                    }\n                    p2 = mallocNoSync(размер, биты, разм_размещ);\n                    if (размук < размер)\n                        размер = размук;\n                    cidrus.memcpy(p2, p, размер);\n                    p = p2;\n                }\n\t\t\t\telse if(разм_размещ)\n                    *разм_размещ = размук;\n            }\n        }\n        return p;\n    }\n//////////////////////////////////////////////////////////\nт_мера extendNoSync(ук p, т_мера аргминразм, т_мера аргмаксразм)\n//////////////////////////////////////////////////////////\n    in\n    {\n        assert( аргминразм <= аргмаксразм );\n    }\n    body\n    {\n\t\n\tif (gcx.пущен)\n            throw new Исключение(\"Неправильная операция с памятью\", __FILE__, __LINE__);\n       \n        version (SENTINEL)\n        {\n            return 0;\n        }\n        auto размук = gcx.найдиРазмер(p);   // найди allocated размер\n        if (размук < РАЗМЕР_СТРАНИЦЫ)\n            return 0;                   // cannot extend buckets\n\n        auto psz = размук / РАЗМЕР_СТРАНИЦЫ;\n        auto минразм = (аргминразм + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;\n        auto максразм = (аргмаксразм + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;\n\n        auto пул = gcx.найдиПул(p);\n        auto номерстр = (p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;\n\n        т_мера разм;\n        for (разм = 0; разм < максразм; разм++)\n        {\n            auto инд = номерстр + psz + разм;\n            if (инд == пул.члопереданных)\n                break;\n            if (пул.таблица_страниц[инд] != Б_ОСВОБ)\n            {   if (разм < минразм)\n                    return 0;\n                break;\n            }\n        }\n        if (разм >= минразм)\n        {\n        }\n        else if (номерстр + psz + разм == пул.члопереданных)\n        {\n            auto u = пул.увеличьЧлоСтрДо(максразм - разм);\n            if (u == СБОЙ_ОП || (u + разм < минразм))\n                return 0;\n            разм += u;\n\t\t\tif(разм > максразм) разм = максразм;\n        }\n        else\n            return 0;\n        debug (MEMSTOMP) cidrus.memset(p + размук, 0xF0, (psz + разм) * РАЗМЕР_СТРАНИЦЫ - размук);\n        cidrus.memset(пул.таблица_страниц + номерстр + psz, Б_СТРПЛЮС, разм);\n\t\tпул.обновиСмещения(номерстр);\n        пул.свобстры -= разм;\n        if (p == gcx.ключ_кэшированного_размера)\n            gcx.знач_кэшированного_размера = (psz + разм) * РАЗМЕР_СТРАНИЦЫ;\n        if (p == gcx.ключ_кэшированной_инфо)\n            gcx.знач_кэшированной_инфо.размер = (psz + разм) * РАЗМЕР_СТРАНИЦЫ;\n        return (psz + разм) * РАЗМЕР_СТРАНИЦЫ;\n    }\n///////////////////////////////////\t\nт_мера reserveNoSync(т_мера размер)\n///////////////////////////////////\n    {\n        assert(размер != 0);\n        assert(gcx);\n\t\t\n\t\tif (gcx.пущен)\n            throw new Исключение(\"Ошибочная операция с памятью\", __FILE__, __LINE__);\n\n        return gcx.резервируй(размер);\n    }\n/////////////////////\nпроц freeNoSync(ук p)\n/////////////////////\n    {\n        assert (p);\n\t\t\n\t\tif (gcx.пущен)\n            throw new Исключение(\"Ошибочная операция с памятью\", __FILE__, __LINE__);\n\n        Пул*  пул;\n        т_мера номерстр;\n        Бины бин;\n        т_мера битинд;\n\n        // Find which page it is in\n        пул = gcx.найдиПул(p);\n        if (!пул)                              // if not one of ours\n            return;                             // ignore\n        сентинель_Инвариант(p);\n        p = сентинель_отн(p);\n        номерстр = cast(т_мера)(p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;\n        битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;\n        gcx.удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты);\n\n        бин = cast(Бины)пул.таблица_страниц[номерстр];\n        if (бин == Б_СТР)              // if large alloc\n        {\n            auto члостр = пул.смещБСтр[номерстр];\n            debug (MEMSTOMP) cidrus.memset(p, 0xF2, члостр * РАЗМЕР_СТРАНИЦЫ);\n            пул.освободиСтраницы(номерстр, члостр);\n        }\n        else\n        {   // Add to cidrus.освободи список\n            Список *список = cast(Список*)p;\n\n            debug (MEMSTOMP) cidrus.memset(p, 0xF2, бинразм[бин]);\n\n            список.следщ = gcx.бак[бин];\n\t\t\tсписок.пул = пул;\n            gcx.бак[бин] = список;\n        }\n        gcx.журнал_освободи(сентинель_добавь(p));\n    }\n\n/////////////////////\t\nук addrOfNoSync(ук p)\n/////////////////////\n    {\n        if (!p)\n        {\n            return null;\n        }\n\n        return gcx.найдиОснову(p);\n    }\n\t\n/////////////////////////\nт_мера sizeOfNoSync(ук p)\n/////////////////////////\n    {\n        assert (p);\n\n        version (SENTINEL)\n        {\n            p = сентинель_отн(p);\n            т_мера размер = gcx.найдиРазмер(p);\n\n            // Check for interior pointer\n            // This depends on:\n            // 1) размер is a power of 2 for less than РАЗМЕР_СТРАНИЦЫ values\n            // 2) основа of memory пул is aligned on РАЗМЕР_СТРАНИЦЫ boundary\n            if (cast(т_мера)p & (размер - 1) & (РАЗМЕР_СТРАНИЦЫ - 1))\n                размер = 0;\n            return размер ? размер - SENTINEL_EXTRA : 0;\n        }\n        else\n        {\n            т_мера размер = gcx.найдиРазмер(p);\n\n            // Check for interior pointer\n            // This depends on:\n            // 1) размер is a power of 2 for less than РАЗМЕР_СТРАНИЦЫ values\n            // 2) основа of memory пул is aligned on РАЗМЕР_СТРАНИЦЫ boundary\n            if (cast(т_мера)p & (размер - 1) & (РАЗМЕР_СТРАНИЦЫ - 1))\n                return 0;\n            return размер;\n        }\n    }\n////////////////////////\nИнфОБл queryNoSync(ук p)\n///////////////////////\n    {\n        assert(p);\n\n        return gcx.дайИнфо(p);\n    }\n\t\n//////////////////////\nпроц checkNoSync(ук p)\n///////////////////////\n    {\n        assert(p);\n\n        сентинель_Инвариант(p);\n        debug (PTRCHECK)\n        {\n            Пул*  пул;\n            т_мера номерстр;\n            Бины бин;\n            т_мера размер;\n\n            p = сентинель_отн(p);\n            пул = gcx.найдиПул(p);\n            assert(пул);\n            номерстр = cast(т_мера)(p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;\n            бин = cast(Бины)пул.таблица_страниц[номерстр];\n            assert(бин <= Б_СТР);\n            размер = бинразм[бин];\n            assert((cast(т_мера)p & (размер - 1)) == 0);\n\n            debug (PTRCHECK2)\n            {\n                if (бин < Б_СТР)\n                {\n                    // Check that p is not on a cidrus.освободи список\n                    Список *список;\n\n                    for (список = gcx.бак[бин]; список; список = список.следщ)\n                    {\n                        assert(cast(ук)список != p);\n                    }\n                }\n            }\n        }\n    }\n//////////////////////////\nпроц устНизСтэка(ук p)\n/////////////////////////\n    {\n        version (СТЭК_РАСТЁТ_ВНИЗ)\n        {\n            //p = (ук )((бцел *)p + 4);\n            if (p > gcx.низСтэка)\n            {\n               debug(НА_КОНСОЛЬ) скажифнс(\"устНизСтэка(%x)\\n\", p);\n                gcx.низСтэка = p;\n            }\n        }\n        else\n        {\n            //p = (ук )((бцел *)p - 4);\n            if (p < gcx.низСтэка)\n            {\n                debug(НА_КОНСОЛЬ) скажифнс(\"устНизСтэка(%x)\\n\", p);\n                gcx.низСтэка = cast(char*)p;\n            }\n        }\n    }\n////////////////////////\nпроц getStatsNoSync(out СМСтат стат)\n///////////////////////////////\n    {\n        т_мера размук = 0;\n        т_мера размфл = 0;\n\t\tт_мера бразм = 0;\n\t\tт_мера иразм = 0;\n\n        т_мера n;\n\n        debug(НА_КОНСОЛЬ) скажи(\"дайСтат()\\n\");\n        cidrus.memset(&стат, 0, СМСтат.sizeof);\n\n        for (n = 0; n < gcx.чло_пулов; n++)\n        {   Пул *пул = gcx.таблица_пулов[n];\n\n            размук += пул.члопереданных * РАЗМЕР_СТРАНИЦЫ;\n            for (т_мера j = 0; j < пул.члопереданных; j++)\n            {\n                Бины бин = cast(Бины)пул.таблица_страниц[j];\n                if (бин == Б_ОСВОБ)\n                    стат.свобБлоки++;\n                else if (бин == Б_СТР)\n                    стат.блокиСтр++;\n\t\t\t\telse if (бин < Б_СТР)\n                    бразм += РАЗМЕР_СТРАНИЦЫ;\n            }\n        }\n\n        for (n = 0; n < Б_СТР; n++)\n        {\n            for (Список *список = gcx.бак[n]; список; список = список.следщ)\n            {\n                размфл += бинразм[n];\n            }\n        }\n        иразм = бразм - размфл;\n\t\t\n        стат.размерПула = размук;\n        стат.испРазмер = бразм - размфл;\n        стат.размСпискаСвобБлоков = размфл;\n    }\n\n    /******************* поддержка слабых ссылок *********************/\n\n    //call locked if necessary\n    T locked(T)(in T delegate() code) \n    {\n        if (нить_нужнаБлокировка()||stdrus.Нить.члонн != 1)\n            synchronized(смЗамок) return code();\n        else\n           return code();\n    }\n\n    struct СлабыйУказатель \n    {\n        Объект ссылка;\n\n        проц ondestroy(Объект r) \n        {\n            assert(r is ссылка);\n            //блокировка ради консистентности памяти (паралельное считывание)\n            //\n            //also ensures that weakpointerDestroy can be called while another\n            //thread is cidrus.освободиing the ссылка with \"delete\"                    \n            locked!(проц)({ ссылка = null; });\n        }\n    }\n\n}\n////////////////////////  КОНЕЦ СМ!!!!!!!!!!!!!!!\n\n\n/* ============================ Gcx =============================== */\n\nstruct Gcx\n{\n\n\n    ук ключ_кэшированного_размера;\n    т_мера знач_кэшированного_размера;\n    \n    ук ключ_кэшированной_инфо;\n    ИнфОБл знач_кэшированной_инфо;\n\n    т_мера члокорней;\n    т_мера размкорня;\n    ук* корни;\n\n    т_мера члопространств;\n    т_мера размпространства;\n    Пространство *пространства;\n\t\n\n\tбцел консервативный;\t// !=0 means консервативный behavior\n\tбцел безСтэка;       // !=0 means don't скан stack\n    бцел журнал;           // turn on logging\n    бцел любизмы;\n    ук низСтэка;\n    бцел готов;\n\tбцел пущен;\n    цел отключен;       // turn off collections if >0\n\n\tбайт *минАдр;      // min(адрОсновы)\n\tбайт *максАдр;      // max(адрВерха)\n\n\tт_мера чло_пулов;\n\tПул **таблица_пулов;\n\t//Пул **пултаб;\n\n\tСписок *бак[Б_МАКС];        // cidrus.освободи список for each размер\n\tФИНАЛИЗАТОР_СМ финализатор;\t// финализатор function (one per СМ)\n\n\n    проц delegate() началоСборки;\n    проц delegate(цел освобождено, цел байтыстр) конецСборки;\n\t\n\t    debug (THREADINVARIANT)\n    {\n        т_нук этот;\n        проц инвариант_Нити()\n        {\n            if (этот != эта_нить())\n                скажифнс(\"инвариант_Нити(): gcx = %x, this = %x, pthread_self() = %x\\n\", this, этот, эта_нить());\n            assert(этот == эта_нить());\n        }\n    }\n    else\n    {\n        проц инвариант_Нити() { }\n    }\n\t\n\tпроц устМинАдр(байт *новАдр){минАдр = новАдр;}\n\t\n\tпроц устМаксАдр(байт *новАдр){максАдр = новАдр;}\n\n\tПул** дайТабПул()\n\t{\n\t/+Пул* пул;\n\tт_мера n;\n\t  for (n = 0; n < чло_пулов; n++)\n        {\n\t\tскажинс(\"творю массив!\");\n            пул = таблица_пулов[n];\n\t\t\tпултаб ~= пул;\n\t\t\t\n\t\t}+/\n\treturn таблица_пулов;\n\t}\n\t\n\t\n    проц иниц()\n    {   цел dummy;\n\n        (cast(байт*)this)[0 .. Gcx.sizeof] = 0;\n        низСтэка = cast(char*)&dummy;\n        журнал_иниц();\n        debug (THREADINVARIANT)\n            этот = эта_нить();\n        //скажифнс(\"gcx = %p, этот = %x\\n\", this, этот);\n        this.готов = 1;\n    }\n\n\n    проц Дтор()\n    {\n\t\n\t\n        this.готов = 0;\n\n        for (т_мера инд = 0; инд < чло_пулов; инд++)\n        {   Пул *пул = таблица_пулов[инд];\n\n            пул.Дтор();\n            cidrus.освободи(пул);\n        }\n        if (таблица_пулов)\n            cidrus.освободи(таблица_пулов);\n\n        if (корни)\n            cidrus.освободи(корни);\n\n        if (пространства)\n            cidrus.освободи(пространства);\n    }\n\n\n    проц Invariant() { }\n\n\ninvariant()\n{\nинвариант();\n}\n\nprotected проц инвариант()\n{\nif(готов)\n{\n       // debug скажифнс(\"Gcx.invariant(): this = %p\\n\", this);\n            т_мера инд;\n\n            // Assure we're called on the right thread\n            debug (THREADINVARIANT) assert(этот == эта_нить());\n\n            for (инд = 0; инд < чло_пулов; инд++)\n            {   auto пул = таблица_пулов[инд];\n\n                пул.Invariant();\n                if (инд == 0)\n                {\n                    assert(минАдр == пул.адрОсновы);\n                }\n                if (инд + 1 < чло_пулов)\n                {\n                    assert(пул.opCmp(таблица_пулов[инд + 1]) < 0);\n                }\n                else if (инд + 1 == чло_пулов)\n                {\n                    assert(максАдр == пул.адрВерха);\n                }\n            }\n\n            if (корни)\n            {\n                assert(размкорня != 0);\n                assert(члокорней <= размкорня);\n            }\n\n            if (пространства)\n            {\n                assert(размпространства != 0);\n                assert(члопространств <= размпространства);\n\n                for (инд = 0; инд < члопространств; инд++)\n                {\n                    assert(пространства[инд].Низ);\n                    assert(пространства[инд].Верх);\n                    assert(пространства[инд].Низ <= пространства[инд].Верх);\n                }\n            }\n\n            for (инд = 0; инд < Б_СТР; инд++)\n            {\n                for (auto список = cast(Список*) бак[инд]; список; список = список.следщ)\n                {\n\t\t\t\t\n                }\n\t\t\t\t\n            }\n\t\t}        \n}\n\n////////////////////////////////////////////\n\n   /**\n     * Run финализатор on p when it is cidrus.освободи'd.\n     */\n    проц заверши(ук p)\n    {\n\tПул *пул = найдиПул(p);\n\tassert(пул);\n\n\t// Only allocate финалы[] if we actually need it\n\tif (!пул.финалы.члобит)\n\t    пул.финалы.размести(пул.пометь.члобит);\n\n\tпул.финалы.установи((p - пул.адрОсновы) / 16);\n    }\n\t\n    /**\n     * Indicate that block pointed to by p has possible pointers\n     * to СМ allocated memory in it.\n     */\n\n\tпроц ЕстьУказатели(ук p)\n    {\n\tПул *пул = найдиПул(p);\n\tassert(пул);\n\n\tпул.нескан.сбрось((p - пул.адрОсновы) / 16);\n    }\n\t\n    /**\n     * Indicate that block pointed to by p has no possible pointers\n     * to СМ allocated memory in it.\n     */\n    проц НетУказателей(ук p)\n    {\n\t//скажифнс(\"НетУказателей(%p)\\n\", p);\n\tПул *пул = найдиПул(p);\n\tassert(пул);\n\n\tпул.нескан.установи((p - пул.адрОсновы) / 16);\n    }\n\n//////////////////////////////////////////////////\n    /**\n     *\n     */\n    проц добавьКорень(ук p)\n    {\n        if (члокорней == размкорня)\n        {\n            т_мера новразм = размкорня * 2 + 16;\n            ук* новкорни;\n\n            новкорни = cast(ук*)cidrus.празмести(новразм * новкорни[0].sizeof);\n            if (!новкорни)\n                throw new ВнеПамИскл();\n            if (корни)\n            {   cidrus.memcpy(новкорни, корни, члокорней * новкорни[0].sizeof);\n                cidrus.освободи(корни);\n            }\n            корни = новкорни;\n            размкорня = новразм;\n        }\n        корни[члокорней] = p;\n        члокорней++;\n    }\n\n    /**\n     *\n     */\n    проц удалиКорень(ук p)\n    {\n        for (т_мера инд = члокорней; инд--;)\n        {\n            if (корни[инд] == p)\n            {\n                члокорней--;\n                cidrus.memmove(корни + инд, корни + инд + 1, (члокорней - инд) * корни[0].sizeof);\n                return;\n            }\n        }\n        assert(0);\n    }\n\n\t /**\n     *\n     */\n    цел обходКорня(цел delegate(ref ук) дг)\n    {\n        цел результат = 0;\n        for( т_мера инд = 0; инд < члокорней; ++инд )\n        {\n            результат = дг(корни[инд]);\n            if (результат)\n                break;\n        }\n        return результат;\n    }\n\n    /**\n     *\n     */\n    проц добавьПространство(ук Низ, ук Верх)\n    {\n        debug(НА_КОНСОЛЬ) скажифнс(\"Нить %x \", эта_нить());\n        debug(НА_КОНСОЛЬ) скажифнс(\"%x.Gcx::добавьПространство(%x, %x), члопространств = %d\\n\", this, Низ, Верх, члопространств);\n        if (члопространств == размпространства)\n        {\n            т_мера новразм = размпространства * 2 + 16;\n            Пространство *новпрострва;\n\n            новпрострва = cast(Пространство*)cidrus.празмести(новразм * новпрострва[0].sizeof);\n            if (!новпрострва)\n                throw new ВнеПамИскл();\n            if (пространства)\n            {   cidrus.memcpy(новпрострва, пространства, члопространств * новпрострва[0].sizeof);\n                cidrus.освободи(пространства);\n            }\n            пространства = новпрострва;\n            размпространства = новразм;\n        }\n        пространства[члопространств].Низ = Низ;\n        пространства[члопространств].Верх = Верх;\n        члопространств++;\n    }\n\n    /**\n     *\n     */\n    проц удалиПространство(ук Низ)\n    {\n        debug(НА_КОНСОЛЬ) скажифнс(\"Нить %x \", эта_нить());\n        debug(НА_КОНСОЛЬ) скажифнс(\"%x.Gcx.удалиПространство(%x), члопространств = %d\\n\", this, Низ, члопространств);\n        for (т_мера инд = члопространств; инд--;)\n        {\n            if (пространства[инд].Низ == Низ)\n            {\n                члопространств--;\n                cidrus.memmove(пространства + инд, пространства + инд + 1, (члопространств - инд) * пространства[0].sizeof);\n                return;\n            }\n        }\n        debug(НА_КОНСОЛЬ) скажи(\"Неверная нить\\n\");\n\n        // This is a fatal error, but ignore it.\n        // The problem is that we can get a Close() call on a thread\n        // other than the one the range was allocated on.\n        //assert(обнули);\n    }\n\t\n\t/**\n     *\n     */\n    цел обходПространства(цел delegate(ref Пространство) дг)\n    {\n        цел результат = 0;\n        for( т_мера инд = 0; инд < члопространств; ++инд )\n        {\n            результат = дг(пространства[инд]);\n            if (результат)\n                break;\n        }\n        return результат;\n    }\n\n    /**\n     * Find Пул that pointer is in.\n     * Return null if not in a Пул.\n     * Assume таблица_пулов[] is sorted.\n     */\n    Пул *найдиПул(ук p)\n    {\n        if (p >= минАдр && p < максАдр)\n        {\n            if (чло_пулов <= 1)\n            {\n                return чло_пулов == 0 ? null : таблица_пулов[0];\n            }\n\n            /* The таблица_пулов[] is sorted by address, so do a binary search\n             */\n            auto pt = таблица_пулов;\n            т_мера low = 0;\n            т_мера high = чло_пулов - 1;\n            while (low <= high)\n            {\n                т_мера mid = (low + high) >> 1;\n                auto пул = pt[mid];\n                if (p < пул.адрОсновы)\n                    high = mid - 1;\n                else if (p >= пул.адрВерха)\n                    low = mid + 1;\n                else\n                    return пул;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Найти адрес основы блока, где находится указатель p.\n     * Returns null if not a gc'd pointer\n     */\n    ук найдиОснову(ук p)\n    {\n        Пул *пул;\n\n        пул = найдиПул(p);\n        if (пул)\n        {\n            т_мера смещение = cast(т_мера)(p - пул.адрОсновы);\n            т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;\n            Бины бин = cast(Бины)пул.таблица_страниц[pn];\n\n            // Adjust bit to be at старт of allocated memory block\n            if (бин <= Б_СТР)\n            {\n                return пул.адрОсновы + (смещение & небинразм[бин]);\n            }\n            else if (бин == Б_СТРПЛЮС)\n            {\n                auto pageOffset = пул.смещБСтр[pn];\n                смещение -= pageOffset * РАЗМЕР_СТРАНИЦЫ;\n                pn -= pageOffset;\n\n                return пул.адрОсновы + (смещение & (смещение.max ^ (РАЗМЕР_СТРАНИЦЫ-1)));\n            }\n            else\n            {\n                // we are in a Б_ОСВОБ or Б_НЕПОДАНО page\n                return null;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Найти размер указателя p.\n     * Returns 0 if not a gc'd pointer\n     */\n    т_мера найдиРазмер(ук p)\n    {\n        Пул*  пул;\n        т_мера размер = 0;\n\n        if (ИСПОЛЬЗОВАТЬ_КЭШ && p == ключ_кэшированного_размера)\n            return знач_кэшированного_размера;\n            \n        пул = найдиПул(p);\n        if (пул)\n        {\n            т_мера номерстр;\n            Бины бин;\n\n            номерстр = cast(т_мера)(p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;\n            бин = cast(Бины)пул.таблица_страниц[номерстр];\n            размер = бинразм[бин];\n            if (бин == Б_СТР)\n            { \n\t\t\tразмер = пул.смещБСтр[номерстр] * РАЗМЕР_СТРАНИЦЫ;\n            }\n            ключ_кэшированного_размера = p;\n            знач_кэшированного_размера = размер;\n        }\n        return размер;\n    }\n\n    /**\n     *\n     */\n    ИнфОБл дайИнфо(ук p)\n    {\n        Пул*   пул;\n        ИнфОБл инфо;\n        \n        if (ИСПОЛЬЗОВАТЬ_КЭШ && p == ключ_кэшированной_инфо)\n            return знач_кэшированной_инфо;\n\n        пул = найдиПул(p);\n        if (пул)\n        {\n            т_мера смещение = cast(т_мера)(p - пул.адрОсновы);\n            т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;\n            Бины бин = cast(Бины)пул.таблица_страниц[pn];\n\n            ////////////////////////////////////////////////////////////////////\n            // findAddr\n            ////////////////////////////////////////////////////////////////////\n\n            if (бин <= Б_СТР)\n            {\n                инфо.основа = cast(ук)((cast(т_мера)p) & небинразм[бин]);\n            }\n            else if (бин == Б_СТРПЛЮС)\n            {\n                auto pageOffset = пул.смещБСтр[pn];\n                смещение = pageOffset * РАЗМЕР_СТРАНИЦЫ;\n                pn -= pageOffset;\n\n                инфо.основа = пул.адрОсновы + (смещение & (смещение.max ^ (РАЗМЕР_СТРАНИЦЫ-1)));\n\n                // fix бин for use by размер calc below\n                бин = cast(Бины)пул.таблица_страниц[pn];\n            }\n\n            ////////////////////////////////////////////////////////////////////\n            // найдиРазмер\n            ////////////////////////////////////////////////////////////////////\n\n            инфо.размер = бинразм[бин];\n            if (бин == Б_СТР)\n            {  \n                инфо.размер = пул.смещБСтр[pn] * РАЗМЕР_СТРАНИЦЫ;\n            }\n\n            ////////////////////////////////////////////////////////////////////\n            // дайБиты\n            ////////////////////////////////////////////////////////////////////\n            \n            смещение = cast(т_мера)(инфо.основа - пул.адрОсновы);\n            инфо.атр = дайБиты(пул, cast(т_мера)(смещение >> пул.смещНа));\n\n            ключ_кэшированной_инфо = p;\n            знач_кэшированной_инфо = инфо;\n        }\n        return инфо;\n    }\n\n    /**\n     * Вычисляет размер корзины.\n     */\n\n    static Бины найдиБин_р(т_мера размер)\n    {   Бины бин;\n\n        if (размер <= 256)\n        {\n            if (размер <= 64)\n            {\n                if (размер <= 16)\n                    бин = Б_16;\n                else if (размер <= 32)\n                    бин = Б_32;\n                else\n                    бин = Б_64;\n            }\n            else\n            {\n                if (размер <= 128)\n                    бин = Б_128;\n                else\n                    бин = Б_256;\n            }\n        }\n        else\n        {\n            if (размер <= 1024)\n            {\n                if (размер <= 512)\n                    бин = Б_512;\n                else\n                    бин = Б_1024;\n            }\n            else\n            {\n                if (размер <= 2048)\n                    бин = Б_2048;\n                else\n                    бин = Б_СТР;\n            }\n        }\n        return бин;\n    }\n\n\t    /**\n     * Рассчитывает бин-таблицу, используя CTFE.\n     */\n    static байт[] ctfeBins()\n    {\n        байт[] ret = new байт[2049];\n        for(т_мера инд = 0; инд < 2049; инд++)\n        {\n            ret[инд] = cast(байт) найдиБин_р(инд);\n        }\n\n        return ret;\n    }\n\t\n   static Бины найдиБин(т_мера размер)\n    {   \n\t  static байт[2049] binTable =cast(байт[2049]) ctfeBins();\n\n        return (размер <= 2048) ?\n            (cast(Бины) binTable[размер]) :\n            Б_СТР;\n    }\n\n    /**\n     * Разместить новый пул как минимум в \"размер\" байтов.\n     * Отсортировать его в таблицу_пулов[].\n     * Пометить всю память в пуле как Б_ОСВОБ.\n     * Возвращает реальное число резервированных байтов, либо 0 при ошибке.\n     */\n    т_мера резервируй(т_мера размер)\n    {\n        т_мера члостр = (размер + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;\n        Пул*  пул = новыйПул(члостр, false);\n\n        if (!пул || пул.увеличьСтраницы(члостр) == СБОЙ_ОП)\n            return 0;\n        return пул.члопереданных * РАЗМЕР_СТРАНИЦЫ;\n    }\n\n    /**\n     * Уменьшает использование физической памяти за счёт возврата\n\t * системе освобождаемых страниц.\n     */\n проц экономь()\n    {\n\t\t\n\t\t static бул используется(Пул *пул)\n        {\n            return пул.свобстры < пул.члостр;\n        }\n\n        for (т_мера n = 0; n < чло_пулов; n++)\n        {\n            auto пул = таблица_пулов[n];\n\t\t\t  if (используется(пул)) continue;\n\t\t\t\n            т_мера pn = n + 1;\n            for (; pn < чло_пулов; ++pn)\n            {\n\t\t\tпул = таблица_пулов[pn];\n\t\t\t  if (!используется(пул)) continue;\n                // swap\n                таблица_пулов[pn] = таблица_пулов[n];\n                таблица_пулов[n] = пул;\n                ++n;\n            }\n\t\t\t // npooltable[0 .. инд]      => использовано\n            // npooltable[инд .. чло_пулов] => free\n\n            // free unused pools\n            for (pn = n; pn < чло_пулов; ++pn)\n            {\n                пул = таблица_пулов[pn];\n               // debug(PRINTF) printFreeInfo(пул);\n                пул.Дтор();\n                cidrus.освободи(пул);\n            }\n            чло_пулов = n;\n        }\n\n        if (чло_пулов)\n        {\n            минАдр = таблица_пулов[0].адрОсновы;\n            максАдр = таблица_пулов[чло_пулов - 1].адрВерха;\n        }\n        else\n        {\n            минАдр = максАдр = null;\n        }\n\n\t\t\n//debug скажинс(\"Экономия пространства выполнена\");\n\t\t\n\t}\n\n    /**\n     * Размещает \"чанк\" памяти, с размером большим страницы.\n     * При недостатке памяти возвращает null.\n     */\n    ук большоеРазмещение(т_мера размер, Пул **poolPtr, т_мера *разм_размещ = null)\n    {\n        Пул*  пул;\n        т_мера члостр;\n        т_мера n;\n        т_мера pn;\n        т_мера удалённые_страницы;\n        ук  p;\n        цел    состояние;\n        бул   собрано = false;\n\n        члостр = (размер + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;\n\n        for (состояние = отключен ? 1 : 0; ; )\n        {\n            // This code could use some refinement when repeatedly\n            // allocating very large arrays.\n\n            for (n = 0; n < чло_пулов; n++)\n            {\n                пул = таблица_пулов[n];\n\t\t\t\tif(!пул.объектБольшой || пул.свобстры < члостр) continue;\n                pn = пул.разместиСтраницы(члостр);\n                if (pn != СБОЙ_ОП)\n                    goto L1;\n            }\n\n            // Failed\n            switch (состояние)\n            {\n            case 0:\n                // Try collecting\n                собрано = true;\n                удалённые_страницы = полная_уборка();\n                if (удалённые_страницы >= чло_пулов * ((РАЗМЕР_ПУЛА / РАЗМЕР_СТРАНИЦЫ) / 4))\n                {   состояние = 1;\n                    continue;\n                }\n                // Release empty pools to prevent bloat\n\t\t\t\t//скажинс(\"Первый вызов функции экономь\");\n                экономь();\n                // Allocate new пул\n                пул = новыйПул(члостр, true);\n                if (!пул)\n                {   состояние = 2;\n                    continue;\n                }\n                pn = пул.разместиСтраницы(члостр);\n                assert(pn != СБОЙ_ОП);\n                goto L1;\n            case 1:\n                // Release empty pools to prevent bloat\n\t\t\t\t//скажинс(\"Второй вызов функции экономь\");\n                экономь();\n                // Allocate new пул\n                пул = новыйПул(члостр, true);\n                if (!пул)\n                {\n                    if (собрано)\n                        goto Lnomemory;\n                    состояние = 0;\n                    continue;\n                }\n                pn = пул.разместиСтраницы(члостр);\n                assert(pn != СБОЙ_ОП);\n                goto L1;\n            case 2:\n                goto Lnomemory;\n            default:\n                assert(false);\n            }\n        }\n\n      L1:\n        пул.таблица_страниц[pn] = Б_СТР;\n        if (члостр > 1)\n            cidrus.memset(&пул.таблица_страниц[pn + 1], Б_СТРПЛЮС, члостр - 1);\n\t\tпул.обновиСмещения(pn);\n        пул.свобстры -= члостр;\t\t\n        p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;\n        cidrus.memset(cast(char *)p + размер, 0, члостр * РАЗМЕР_СТРАНИЦЫ - размер);\n        debug (MEMSTOMP) cidrus.memset(p, 0xF1, размер);\n\t\t if(разм_размещ)\n            *разм_размещ = члостр * РАЗМЕР_СТРАНИЦЫ;\n\t\t\t*poolPtr = пул;\n        //debug(НА_КОНСОЛЬ)\t\tскажифнс(\"большоеРазмещение: \\tp = %x\\n\", p);\n        return p;\n\n      Lnomemory:\n        return null; // let caller хэндл the error\n    }\n\n    /**\n     * Разместить новый пул с - как минимум - члостр в нём.\n     * Сортировать его в таблица_пулов[].\n     * Вернуть пусто при неудаче.\n     */\n    Пул *новыйПул(т_мера члостр, bool объектБольшой)\n    {\n        Пул*  пул;\n        Пул** новтаблица_пулов;\n        т_мера новпулы;\n        т_мера инд;\n\n        //debug(НА_КОНСОЛЬ) скажифнс(\"************Gcx::новыйПул(члостр = %d)****************\\n\", члостр);\n\n        // Round up to РАЗМЕР_ПОДАЧИ pages\n        члостр = (члостр + (РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ) - 1) & ~(РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ - 1);\n\n        // Minimum of РАЗМЕР_ПУЛА\n        if (члостр < РАЗМЕР_ПУЛА/РАЗМЕР_СТРАНИЦЫ)\n            члостр = РАЗМЕР_ПУЛА/РАЗМЕР_СТРАНИЦЫ;\n        else if (члостр > РАЗМЕР_ПУЛА/РАЗМЕР_СТРАНИЦЫ)\n        {   // Give us 150% of requested размер, so there's room to extend\n            auto n = члостр + (члостр >> 1);\n            if (n < т_мера.max/РАЗМЕР_СТРАНИЦЫ)\n                члостр = n;\n        }\n\n        // Allocate successively larger pools up to 8 megs\n        if (чло_пулов)\n        {   т_мера n;\n\n            n = чло_пулов;\n            if (n > 32)\n                n = 32;         // cap пул размер at 32 megs\n            else if (n > 8)\n                n = 16;\n            n *= (РАЗМЕР_ПУЛА / РАЗМЕР_СТРАНИЦЫ);\n            if (члостр < n)\n                члостр = n;\n        }\n\n        пул = cast(Пул *)cidrus.кразмести(1, Пул.sizeof);\n        if (пул)\n        {\n            пул.иниц(члостр, объектБольшой);\n            if (!пул.адрОсновы)\n                goto Lerr;\n\n            новпулы = чло_пулов + 1;\n            новтаблица_пулов = cast(Пул**)cidrus.realloc(таблица_пулов, новпулы * (Пул*).sizeof);\n            if (!новтаблица_пулов)\n                goto Lerr;\n\n            // Sort пул into новтаблица_пулов[]\n            for (инд = 0; инд < чло_пулов; инд++)\n            {\n                if (пул.opCmp(новтаблица_пулов[инд]) < 0)\n                     break;\n            }\n            cidrus.memmove(новтаблица_пулов + инд + 1, новтаблица_пулов + инд, (чло_пулов - инд) * (Пул*).sizeof);\n            новтаблица_пулов[инд] = пул;\n\n            таблица_пулов = новтаблица_пулов;\n            чло_пулов = новпулы;\n\n            минАдр = таблица_пулов[0].адрОсновы;\n            максАдр = таблица_пулов[чло_пулов - 1].адрВерха;\n        }\n        return пул;\n\n      Lerr:\n        пул.Дтор();\n        cidrus.освободи(пул);\n        return null;\n    }\n\n    /**\n     * Размещает страницу корзин.\n     * Возвращает:\n     *  0       провал\n     */\n    цел разместиСтраницу(Бины бин)\n    {\n        Пул*  пул;\n        т_мера n;\n        т_мера pn;\n        байт*  p;\n        байт*  верх;\n\n        //debug(НА_КОНСОЛЬ) скажифнс(\"Gcx::разместиСтраницу(бин = %d)\\n\", бин);\n        for (n = 0; n < чло_пулов; n++)\n        {\n            пул = таблица_пулов[n];\n\t\t\tif(пул.объектБольшой) continue;\n            pn = пул.разместиСтраницы(1);\n            if (pn != СБОЙ_ОП)\n                goto L1;\n        }\n        return 0;               // failed\n\n      L1:\n        пул.таблица_страниц[pn] = cast(ббайт)бин;\n\t\tпул.свобстры--;\n        // Convert page to cidrus.освободи список\n        т_мера размер = бинразм[бин];\n        Список **b = &бак[бин];\n\n        p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;\n        верх = p + РАЗМЕР_СТРАНИЦЫ;\n        for (; p < верх; p += размер)\n        {\n            (cast(Список *)p).следщ = *b;\n\t\t\t(cast(Список *)p).пул = пул;\n            *b = cast(Список *)p;\n        }\n        return 1;\n    }\n\n    /**\n     * Поиск в диапазоне (пространстве) памяти и выполнение пометки любых указателей  на пул СМ.\n     */\n    проц пометь(ук низ, ук верх, цел члорекурсий)\n    {\n\tт_мера смещение;\n        ук **p1 = cast(ук** )низ;\n        ук **p2 = cast(ук** )верх;\n        т_мера кэш = 0;\n        бцел изменения = 0;\n\n        //эхо(\"marking range: %p -> %p\\n\", Низ, Верх);\n        for (; p1 < p2; p1++)\n        {\n            auto p = cast(байт *)(*p1);\n\n            //if (журнал) debug(НА_КОНСОЛЬ) эхо(\"\\tmark %x\\n\", p);\n            if (p >= минАдр && p < максАдр)\n            {\n                if ((cast(т_мера)p & ~cast(т_мера)(РАЗМЕР_СТРАНИЦЫ-1)) == кэш)\n \t            continue;\n\n                auto пул = найдиПул(p);\n                if (пул)\n                {\n                    смещение = cast(т_мера)(p - пул.адрОсновы);\n                    т_мера битинд = void;\n                    т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;\n                    Бины бин = cast(Бины)пул.таблица_страниц[pn];\n\t\t\t\t\tук основа = void;\n\t\t\t\t\tбул точекДоОсновы = false;\n                    //debug(НА_КОНСОЛЬ) эхо(\"\\t\\tfound пул %x, основа=%x, pn = %d, бин = %d, битинд = x%x\\n\", пул, пул.адрОсновы, pn, бин, битинд);\n\n                    // Adjust bit to be at старт of allocated memory block\n                    if (бин < Б_СТР)\n                    {\n\t\t\t\t\tauto offsetBase = смещение & небинразм[бин];\n                        битинд = offsetBase >> пул.смещНа;\n\t\t\t\t\t\tоснова = пул.адрОсновы + offsetBase;\n                        //debug(НА_КОНСОЛЬ) эхо(\"\\t\\tбитинд = x%x\\n\", битинд);\n                    }\n                    else if (бин == Б_СТР)\n                    {\n                        auto offsetBase = смещение & небинразм[бин];\n                        основа = пул.адрОсновы + offsetBase;\n                        точекДоОсновы = offsetBase == смещение;\n                        битинд = offsetBase >> пул.смещНа;\n                        //debug(НА_КОНСОЛЬ) эхо(\"\\t\\tбитинд = x%x\\n\", битинд);\n\n                        кэш = cast(т_мера)p & ~cast(т_мера)(РАЗМЕР_СТРАНИЦЫ-1);\n                    }\n                    else if (бин == Б_СТРПЛЮС)\n                    {\n                        pn -= пул.смещБСтр[pn];\n                        основа = пул.адрОсновы + (pn * РАЗМЕР_СТРАНИЦЫ);\n                        битинд = pn * (РАЗМЕР_СТРАНИЦЫ >> пул.смещНа);\n\n                        кэш = cast(т_мера)p & ~cast(т_мера)(РАЗМЕР_СТРАНИЦЫ-1);                 \n                    }\n                    else\n                    {\n                        // Don't пометь биты in Б_ОСВОБ or Б_НЕПОДАНО pages\n                        continue;\n                    }\n\t\t\t\t\t\n\t\t\t\t\tif(пул.безнутра.члобит && !точекДоОсновы && пул.безнутра.тестируй(битинд))\n                    {\n                        continue;\n                    }\n\n                    //debug(НА_КОНСОЛЬ) эхо(\"\\t\\tmark(x%x) = %d\\n\", битинд, пул.пометь.тестируй(битинд));\n                    if (!пул.пометь.тестУст(битинд))\n                    {\n                                  \n                        if (!пул.нескан.тестируй(битинд))\n                        {\n                          \n\t\t\t\t\t\t\t\t  if(члорекурсий == 0) {\n                                // Then we've got a really deep heap graph.\n                                // Start marking stuff to be scanned when we\n                                // traverse the heap again next time, to save\n                                // stack space.\n                                пул.скан.установи(битинд);\n                                изменения = 1;\n                                пул.новИзмы = true;\n                            } else {\n                                // Directly recurse пометь() to prevent having\n                                // to traverse the heap O(D) times where D\n                                // is the max depth of the heap graph.\n                                if (бин < Б_СТР)\n                                {\n                                    пометь(основа, основа + бинразм[бин], члорекурсий - 1);\n                                }\n                                else\n                                {\n                                    auto u = пул.смещБСтр[pn];\n                                    пометь(основа, основа + u * РАЗМЕР_СТРАНИЦЫ, члорекурсий - 1);\n                                }\n                            }\n                        }\n                      debug (LOGGING)  журнал_родитель(сентинель_добавь(пул.адрОсновы +( битинд << пул.смещНа)), сентинель_добавь(низ));\n                    }\n                }\n            }\n        }\n        любизмы |= изменения;\n    }\n\t\n\t\t/**\n\t * Перегрузка \"пометь\" для его начального вызова.\n     */\n    проц пометь(ук низ, ук верх)\n\t{\n        пометь(низ, верх, МАКС_РЕКУРСИЙ_МЕЧЕНИЯ);\n    }\n    /**\n     *\n     */\n    т_мера полная_уборка(ук верхСтэка)\n    {\n        т_мера n;\n        Пул*  пул;\n\n        debug(COLLECT_PRINTF) эхо(\"Gcx.fullcollect()\\n\");\n        if (пущен)\n            throw new Exception(\"Неверная операция с памятью\", __FILE__, __LINE__);\n        пущен = 1;\n\n        нить_заморозьВсе();\n\t\tif (stdrus.Нить.члонн > 0)stdrus.Нить.паузаВсем();\n\n        ключ_кэшированного_размера = ключ_кэшированного_размера.init;\n        знач_кэшированного_размера = знач_кэшированного_размера.init;\n        ключ_кэшированной_инфо = ключ_кэшированной_инфо.init;\n        знач_кэшированной_инфо = знач_кэшированной_инфо.init;\n\n        любизмы = 0;\n        for (n = 0; n < чло_пулов; n++)\n        {\n            пул = таблица_пулов[n];\n            пул.пометь.обнули();\n            пул.скан.обнули();\n            if(!пул.объектБольшой) пул.своббиты.обнули();\n        }\n\n        // Mark each cidrus.освободи entry, so it doesn't get scanned\n        for (n = 0; n < Б_СТР; n++)\n        {\n            for (Список *список = бак[n]; список; список = список.следщ)\n            {\n                пул = найдиПул(список);\n                assert(пул);\n                пул.своббиты.установи(cast(т_мера)(cast(байт*)список - пул.адрОсновы) / 16);\n            }\n        }\n\n        for (n = 0; n < чло_пулов; n++)\n        {\n            пул = таблица_пулов[n];\n\t\t\tпул.новИзмы = false;\n\t\t\tif(!пул.объектБольшой)\n            {\n            пул.пометь.копируй(&пул.своббиты);\n\t\t\t}\n        }\n\n        //ртСканируйСтатДан( &пометь );\n\t\t\n\n\n        version (МНОГОПОТОЧНАЯ)\n        {\n            if (!безСтэка)\n            {\n                // Scan stacks and registers for each paused thread\n              нить_сканируйВсе( &this.пометь, верхСтэка );\n            }\n        }\n        else\n        {\n            if (!безСтэка)\n            {\n                // Scan stack for main thread\n                debug(НА_КОНСОЛЬ) эхо(\" scan niz steka = %x, top = %x\\n\", верхСтэка, низСтэка);\n                version (СТЭК_РАСТЁТ_ВНИЗ)\n                    пометь(верхСтэка, низСтэка);\n                else\n                    пометь(низСтэка, верхСтэка);\n            }\n        }\n\n        // Scan корни[]\n        debug(COLLECT_PRINTF) эхо(\"scan korni[]\\n\");\n        пометь(корни, корни + члокорней);\n\n        // Scan пространства[]\n        debug(COLLECT_PRINTF) эхо(\"scan prostranstva[]\\n\");\n        //журнал++;\n        for (n = 0; n < члопространств; n++)\n        {\n            debug(COLLECT_PRINTF) эхо(\"\\t%x .. %x\\n\", пространства[n].Низ, пространства[n].Верх);\n            пометь(пространства[n].Низ, пространства[n].Верх);\n        }\n        //журнал--;\n\n        debug(COLLECT_PRINTF) эхо(\"\\tscan heap\\n\");\n\t\tцел nTraversals;\n        while (любизмы)\n        {\n            \n            for (n = 0; n < чло_пулов; n++)\n            {\n                пул = таблица_пулов[n];\n\t\t\t\tпул.старИзмы = пул.новИзмы;\n                пул.новИзмы = false;\n\t\t\t}\n\t\t\tлюбизмы = 0;\n\t\t\t\n\t\t\tfor (n = 0; n < чло_пулов; n++)\n            {\n\t\t\t\tпул = таблица_пулов[n];\n                if(!пул.старИзмы) continue;\n\t\t\t\n\t\t\t\tauto смещНа = пул.смещНа;\n                auto носнова = пул.скан.основа();\n                auto нверх = носнова + пул.скан.члослов;\n                for (auto b = носнова; b < нверх;)\n                {\n                    auto bitm = *b;\n                    if (!bitm)\n                    {   b++;\n                        continue;\n                    }\n                    *b = 0;\n\n                    auto o = пул.адрОсновы + (b - носнова) * ((typeof(bitm).sizeof*8) << смещНа);\n\t\t\t\t\t\n\t\t\t\t\tauto firstset = std.intrinsic.bsf(bitm);\n                    bitm >>= firstset;\n                    o += firstset << смещНа;\n\t\t\t\t\t\n\t\t\t\t\t while(bitm)\n                    {\n                        auto pn = cast(т_мера)(o - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;\n                        auto бин = cast(Бины)пул.таблица_страниц[pn];\n                        if (бин < Б_СТР)\n                        {\n                            пометь(o, o + бинразм[бин]);\n                        }\n                        else if (бин == Б_СТР)\n                        {\n                            auto u = пул.смещБСтр[pn];\n                            пометь(o, o + u * РАЗМЕР_СТРАНИЦЫ);\n                        }\n\n                        bitm >>= 1;\n                        auto члобит = std.intrinsic.bsf(bitm);\n                        bitm >>= члобит;\n                        o += (члобит + 1) << смещНа;\n                    }\n                }\n            }\n        }\n\n\t\t//thread_processGCMarks();\n        нить_разморозьВсе();\n        if (stdrus.Нить.члонн > 0) stdrus.Нить.возобновиВсе();\n/+\n        debug(PROFILING)\n        {\n            stop = clock();\n            markTime += (stop - start);\n            start = stop;\n        }\n+/\n        // Free up everything not marked\n        debug(COLLECT_PRINTF) эхо(\"\\tfree'ing\\n\");\n        т_мера освобождённые_стр = 0;\n        т_мера освобождено = 0;\n        for (n = 0; n < чло_пулов; n++)\n        {   т_мера pn;\n\n            пул = таблица_пулов[n];\n            auto члопереданных = пул.члопереданных;\n\n            if(пул.объектБольшой)\n            {\n                for(pn = 0; pn < члопереданных; pn++)\n                {\n                    Бины бин = cast(Бины)пул.таблица_страниц[pn];\n                    if(бин > Б_СТР) continue;\n                    т_мера битинд = pn;\n\n                    if (!пул.пометь.тестируй(битинд))\n                    {   байт *p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;\n\n                        сентинель_Инвариант(сентинель_добавь(p));\n                        if (пул.финалы.члобит && пул.финалы.тестСброс(битинд))\n                            rt_finalize_gc(сентинель_добавь(p));\n                        удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты ^ ПАтрБлока.Финализовать);\n\n                        debug(COLLECT_PRINTF) эхо(\"\\tcollecting big %p\\n\", p);\n                        журнал_освободи(сентинель_добавь(p));\n                        пул.таблица_страниц[pn] = Б_ОСВОБ;\n                        if(pn < пул.стартПоиска) пул.стартПоиска = pn;\n                        освобождённые_стр++;\n                        пул.свобстры++;\n\n                        debug (MEMSTOMP) memset(p, 0xF3, РАЗМЕР_СТРАНИЦЫ);\n                        while (pn + 1 < члопереданных && пул.таблица_страниц[pn + 1] == Б_СТРПЛЮС)\n                        {\n                            pn++;\n                            пул.таблица_страниц[pn] = Б_ОСВОБ;\n\n                            // Don't need to update стартПоиска here because\n                            // pn is guaranteed to be greater than last time\n                            // we updated it.\n\n                            пул.свобстры++;\n                            освобождённые_стр++;\n\n                            debug (MEMSTOMP)\n                            {   p += РАЗМЕР_СТРАНИЦЫ;\n                                memset(p, 0xF3, РАЗМЕР_СТРАНИЦЫ);\n                            }\n                        }\n                    }\n                }\n\n                continue;\n            }\n            else\n            {\n\n                for (pn = 0; pn < члопереданных; pn++)\n                {\n                    Бины бин = cast(Бины)пул.таблица_страниц[pn];\n\n                    if (бин < Б_СТР)\n                    {\n                        auto   размер = бинразм[бин];\n                        байт *p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;\n                        байт *верх = p + РАЗМЕР_СТРАНИЦЫ;\n                        т_мера битинд = pn * (РАЗМЕР_СТРАНИЦЫ/16);\n                        т_мера битстрайд = размер / 16;\n\n                        СМБиты.т_слово к_сбросу;\n                        т_мера стартСброса = (битинд >> СМБиты.СДВИГ_БИТ) + 1;\n                        т_мера индСброса;\n\n                        for (; p < верх; p += размер, битинд += битстрайд, индСброса += битстрайд)\n                        {\n                            if(индСброса > СМБиты.БИТ_НА_СЛОВО - 1)\n                            {\n                                if(к_сбросу)\n                                {\n                                    Gcx.УдалиБитыМал(пул, стартСброса, к_сбросу);\n                                    к_сбросу = 0;\n                                }\n\n                                стартСброса = (битинд >> СМБиты.СДВИГ_БИТ) + 1;\n                                индСброса = битинд & СМБиты.МАСКА_БИТ;\n                            }\n\n                            if (!пул.пометь.тестируй(битинд))\n                            {\n                                сентинель_Инвариант(сентинель_добавь(p));\n\n                                пул.своббиты.установи(битинд);\n                                if (пул.финалы.члобит && пул.финалы.тестируй(битинд))\n                                    rt_finalize_gc(сентинель_добавь(p));\n                                к_сбросу |= СМБиты.БИТЫ_1 << индСброса;\n\n                                Список *список = cast(Список *)p;\n                                debug(PRINTF) эхо(\"\\tcollecting %p\\n\", список);\n                                журнал_освободи(сентинель_добавь(список));\n\n                                debug (MEMSTOMP) memset(p, 0xF3, размер);\n\n                                освобождено += размер;\n                            }\n                        }\n\n                        if(к_сбросу)\n                        {\n                            Gcx.УдалиБитыМал(пул, стартСброса, к_сбросу);\n                        }\n                    }\n                }\n            }\n        }\n\n        debug(PROFILING)\n        {\n            stop = clock();\n            sweepTime += (stop - start);\n            start = stop;\n        }\n\n        // Zero buckets\n        бак[] = null;\n\n        // Free complete pages, rebuild free список\n        debug(COLLECT_PRINTF) эхо(\"\\tfree complete pages\\n\");\n        т_мера восстановленные_стр = 0;\n        for (n = 0; n < чло_пулов; n++)\n        {   т_мера pn;\n            т_мера члопереданных;\n\n            пул = таблица_пулов[n];\n            if(пул.объектБольшой) continue;\n            члопереданных = пул.члопереданных;\n            for (pn = 0; pn < члопереданных; pn++)\n            {\n                Бины   бин = cast(Бины)пул.таблица_страниц[pn];\n                т_мера битинд;\n                т_мера u;\n\n                if (бин < Б_СТР)\n                {\n                    т_мера размер = бинразм[бин];\n                    т_мера битстрайд = размер / 16;\n                    т_мера бит_ова = pn * (РАЗМЕР_СТРАНИЦЫ / 16);\n                    т_мера bittop = бит_ова + (РАЗМЕР_СТРАНИЦЫ / 16);\n                    байт*  p;\n\n                    битинд = бит_ова;\n                    for (битинд = бит_ова; битинд < bittop; битинд += битстрайд)\n                    {   if (!пул.своббиты.тестируй(битинд))\n                            goto Lnotfree;\n                    }\n                    пул.таблица_страниц[pn] = Б_ОСВОБ;\n                    if(pn < пул.стартПоиска) пул.стартПоиска = pn;\n                    пул.свобстры++;\n                    восстановленные_стр++;\n                    continue;\n\n                 Lnotfree:\n                    p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;\n                    for (u = 0; u < РАЗМЕР_СТРАНИЦЫ; u += размер)\n                    {   битинд = бит_ова + u / 16;\n                        if (пул.своббиты.тестируй(битинд))\n                        {   Список *список;\n\n                            список = cast(Список *)(p + u);\n                            if (список.следщ != бак[бин])       // avoid unnecessary writes\n                                список.следщ = бак[бин];\n                            список.пул = пул;\n                            бак[бин] = список;\n                        }\n                    }\n                }\n            }\n        }\n\n        debug(PROFILING)\n        {\n            stop = clock();\n            recoverTime += (stop - start);\n        }\n\n        debug(COLLECT_PRINTF) эхо(\"\\trecovered pages = %d\\n\", восстановленные_стр);\n        debug(COLLECT_PRINTF) эхо(\"\\tfree'd %u bytes, %u pages from %u pools\\n\", освобождено, освобождённые_стр, чло_пулов);\n\n        пущен = 0; // only clear on success\n\n        return освобождённые_стр + восстановленные_стр;\n    }\n\n    /**\n     * Возвращает число заполненных страниц, высвобожденных функцией cidrus.освободи.\n     */\n    т_мера полная_уборка()\n    {    \n        // The purpose of the 'shell' is to ensure all the registers\n        // get put on the stack so they'll be scanned\n        ук sp;\n        т_мера результат;\n        version (GNU)\n        {\n            __builtin_unwind_init();\n            sp = & sp;\n        }\n        else version (D_InlineAsm_X86)\n        {\n            asm\n            {\n                pushad              ;\n                mov sp[EBP],ESP     ;\n            }\n        }\n        else version (D_InlineAsm_X86_64)\n        {\n            asm\n            {\n                push RAX ;\n                push RBX ;\n                push RCX ;\n                push RDX ;\n                push RSI ;\n                push RDI ;\n                push RBP ;\n                push R8  ;\n                push R9  ;\n                push R10  ;\n                push R11  ;\n                push R12  ;\n                push R13  ;\n                push R14  ;\n                push R15  ;\n                push RAX ;   // 16 байт align the stack\n                mov sp[RBP],RSP     ;\n            }\n        }\n        else\n        {\n            static assert(false, \"Архитектура не поддерживается.\");\n        }\n\n        результат = полная_уборка(sp);\n\n        version (GNU)\n        {\n            // registers will be popped automatically\n        }\n        else version (D_InlineAsm_X86)\n        {\n            asm\n            {\n                popad;\n            }\n        }\n        else version (D_InlineAsm_X86_64)\n        {\n            asm\n            {\n                pop RAX ;   // 16 байт align the stack\n                pop R15  ;\n                pop R14  ;\n                pop R13  ;\n                pop R12  ;\n                pop R11  ;\n                pop R10  ;\n                pop R9  ;\n                pop R8  ;\n                pop RBP ;\n                pop RDI ;\n                pop RSI ;\n                pop RDX ;\n                pop RCX ;\n                pop RBX ;\n                pop RAX ;\n            }\n        }\n        else\n        {\n            static assert(false, \"Архитектура не поддерживается.\");\n        }\n        return результат;\n    }\n\t\n/**\n     * Возвращает true, если указатель подлежит сборке.  Вызывается только\n     * по указателю на основу блока.\n     *\n     * Внимание! Вызывать следует только когда\n\t * полная_сборка блокировала всё остальное.\n     */\n    bool идётУборка(void *p)\n    {\n        // first, we find the Pool this block is in, then check to see if the\n        // mark bit is clear.\n        auto пул = найдиПул(p);\n        if(пул)\n        {\n            auto смещение = cast(т_мера)(p - пул.адрОсновы);\n            auto pn = смещение / РАЗМЕР_СТРАНИЦЫ;\n            auto бины = cast(Бины)пул.таблица_страниц[pn];\n            if(бины <= Б_СТР)\n            {\n                assert(p == cast(void*)((cast(т_мера)p) & небинразм[бины]));\n                // return true if the block is not marked.\n                return !(пул.пометь.тестируй(смещение >> пул.смещНа));\n            }\n        }\n        return false; // not collecting or pointer is a valid argument.\n    }\n\t\t\t\t\n    /**\n     *\n     */\n    бцел дайБиты(Пул* пул, т_мера битинд)\n    in\n    {\n        assert( пул );\n    }\n    body\n    {\n        бцел биты;\n\n        if (пул.финалы.члобит &&\n            пул.финалы.тестируй(битинд))\n            биты |= ПАтрБлока.Финализовать;\n        if (пул.нескан.тестируй(битинд))\n            биты |= ПАтрБлока.НеСканировать;\n\t\t\t        if (пул.безнутра.члобит && пул.безнутра.тестируй(битинд))\n            биты |= ПАтрБлока.БезНутра;\n//       if (пул.неперем.члобит &&\n//            пул.неперем.тестируй(битинд))\n//            биты |= ПАтрБлока.НеПеремещать;\n        if (пул.мождоб.тестируй(битинд))\n            биты |= ПАтрБлока.МожноДобавить;\n        return биты;\n    }\n\n    /**\n     *\n     */\n    проц устБиты(Пул* пул, т_мера битинд, бцел маска)\n    in\n    {\n        assert( пул );\n    }\n    body\n    {\n                // Calculate the маска and bit смещение once and then use it to\n        // set all of the bits we need to set.\n        auto индексДанных = 1 + (битинд >> СМБиты.СДВИГ_БИТ);\n        auto битСмещение = битинд & СМБиты.МАСКА_БИТ;\n        auto orWith = СМБиты.БИТЫ_1 << битСмещение;\n\n        if (маска & ПАтрБлока.Финализовать)\n        {\n            if (!пул.финалы.члобит)\n                пул.финалы.размести(пул.пометь.члобит);\n            пул.финалы.данные[индексДанных] |= orWith;\n        }\n        if (маска & ПАтрБлока.НеСканировать)\n        {\n            пул.нескан.данные[индексДанных] |= orWith;\n        }\n//        if (маска & ПАтрБлока.NO_MOVE)\n//        {\n//            if (!пул.неперем.члобит)\n//                пул.неперем.alloc(пул.пометь.члобит);\n//            пул.неперем.данные[индексДанных] |= orWith;\n//        }\n        if (маска & ПАтрБлока.МожноДобавить)\n        {\n            пул.мождоб.данные[индексДанных] |= orWith;\n        }\n\n        if (пул.объектБольшой && (маска & ПАтрБлока.БезНутра))\n        {\n            if(!пул.безнутра.члобит)\n                пул.безнутра.размести(пул.пометь.члобит);\n            пул.безнутра.данные[индексДанных] |= orWith;\n        }\n    }\n\n    /**\n     *\n     */\n    проц удалиБиты(Пул* пул, т_мера битинд, бцел маска)\n    in\n    {\n        assert( пул );\n    }\n    body\n    {\n        auto индексДанных =  1 + (битинд >> СМБиты.СДВИГ_БИТ);\n        auto битСмещение = битинд & СМБиты.МАСКА_БИТ;\n        auto оставить = ~(СМБиты.БИТЫ_1 << битСмещение);\n\n        if (маска & ПАтрБлока.Финализовать && пул.финалы.члобит)\n            пул.финалы.данные[индексДанных] &= оставить;\n        if (маска & ПАтрБлока.НеСканировать)\n            пул.нескан.данные[индексДанных] &= оставить;\n//        if (маска & ПАтрБлока.NO_MOVE && пул.nomove.члобит)\n//            пул.nomove.данные[индексДанных] &= оставить;\n        if (маска & ПАтрБлока.МожноДобавить)\n            пул.мождоб.данные[индексДанных] &= оставить;\n        if (пул.безнутра.члобит && (маска & ПАтрБлока.БезНутра))\n            пул.безнутра.данные[индексДанных] &= оставить;\n    }\n\n\t void УдалиБитыМал(Пул* пул, т_мера индексДанных, СМБиты.т_слово к_сбросу)\n    in\n    {\n        assert(пул);\n    }\n    body\n    {\n        auto оставить = ~к_сбросу;\n        if (пул.финалы.члобит)\n            пул.финалы.данные[индексДанных] &= оставить;\n\n        пул.нескан.данные[индексДанных] &= оставить;\n\n//        if (пул.nomove.члобит)\n//            пул.nomove.данные[индексДанных] &= оставить;\n\n        пул.мождоб.данные[индексДанных] &= оставить;\n\n        if (пул.безнутра.члобит)\n            пул.безнутра.данные[индексДанных] &= оставить;\n    }\n\n    /***** Детектор Утечки ******/\n\n\n    debug (LOGGING)\n    {\n        МассивЖурналов текущий;\n        МассивЖурналов предыдущ;\n\n\n        проц журнал_иниц()\n        {\n            //debug(НА_КОНСОЛЬ) эхо(\"+журнал_иниц()\\n\");\n            текущий.резервируй(1000);\n            предыдущ.резервируй(1000);\n            //debug(НА_КОНСОЛЬ) эхо(\"-журнал_иниц()\\n\");\n        }\n\n\n        проц журнал_празмести(ук p, т_мера размер)\n        {\n            //debug(НА_КОНСОЛЬ) эхо(\"+журнал_празмести(p = %x, размер = %d)\\n\", p, размер);\n            Журнал журнал;\n\n            журнал.p = p;\n            журнал.размер = размер;\n            журнал.строка = СМ.строка;\n            журнал.файл = СМ.файл;\n            журнал.родитель = null;\n\n            СМ.строка = 0;\n            СМ.файл = null;\n\n            текущий.сунь(журнал);\n            //debug(НА_КОНСОЛЬ) эхо(\"-журнал_празмести()\\n\");\n        }\n\n\n        проц журнал_освободи(ук p)\n        {\n            //debug(НА_КОНСОЛЬ) эхо(\"+журнал_освободи(%x)\\n\", p);\n            т_мера инд;\n\n            инд = текущий.найди(p);\n            if (инд == СБОЙ_ОП)\n            {\n                debug(НА_КОНСОЛЬ) эхо(\"freeing unallocated memory %x\\n\", p);\n            }\n            else\n                текущий.удали(инд);\n            //debug(НА_КОНСОЛЬ) эхо(\"-журнал_освободи()\\n\");\n        }\n\n\n        проц журнал_сборка()\n        {\n            //debug(НА_КОНСОЛЬ) эхо(\"+журнал_сборка()\\n\");\n            // Print everything in текущий that is not in предыдущ\n\n            debug(НА_КОНСОЛЬ) эхо(\"New pointers this cycle: --------------------------------\\n\");\n            т_мера использовано = 0;\n            for (т_мера инд = 0; инд < текущий.разм; инд++)\n            {\n                т_мера j;\n\n                j = предыдущ.найди(текущий.данные[инд].p);\n                if (j == СБОЙ_ОП)\n                    текущий.данные[инд].выведи();\n                else\n                    использовано++;\n            }\n\n            debug(НА_КОНСОЛЬ) эхо(\"Vse korni dannogo cykla: --------------------------------\\n\");\n            for (т_мера инд = 0; инд < текущий.разм; инд++)\n            {\n                ук p;\n                т_мера j;\n\n                p = текущий.данные[инд].p;\n                if (!найдиПул(текущий.данные[инд].родитель))\n                {\n                    j = предыдущ.найди(текущий.данные[инд].p);\n                    if (j == СБОЙ_ОП)\n                        debug(НА_КОНСОЛЬ) эхо(\"N\");\n                    else\n                        debug(НА_КОНСОЛЬ) эхо(\" \");;\n                    текущий.данные[инд].выведи();\n                }\n            }\n\n            debug(НА_КОНСОЛЬ) эхо(\"Used = %d-------------------------------------------------\\n\", использовано);\n            предыдущ.копируй(&текущий);\n\n            debug(НА_КОНСОЛЬ) эхо(\"-zhurnal_sborka()\\n\");\n        }\n\n\n        проц журнал_родитель(ук p, ук родитель)\n        {\n            //debug(НА_КОНСОЛЬ) эхо(\"+журнал_родитель()\\n\");\n            т_мера инд;\n\n            инд = текущий.найди(p);\n            if (инд == СБОЙ_ОП)\n            {\n                debug(НА_КОНСОЛЬ) эхо(\"родитель'ing unallocated memory %x, родитель = %x\\n\", p, родитель);\n                Пул *пул;\n                пул = найдиПул(p);\n                assert(пул);\n                т_мера смещение = cast(т_мера)(p - пул.адрОсновы);\n                т_мера битинд;\n                т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;\n                Бины бин = cast(Бины)пул.таблица_страниц[pn];\n                битинд = (смещение & небинразм[бин]);\n                debug(НА_КОНСОЛЬ) эхо(\"\\tbin = %d, смещение = x%x, битинд = x%x\\n\", бин, смещение, битинд);\n            }\n            else\n            {\n                текущий.данные[инд].родитель = родитель;\n            }\n            //debug(НА_КОНСОЛЬ) эхо(\"-журнал_родитель()\\n\");\n        }\n\n    }\n    else\n    {\n        проц журнал_иниц() { }\n        проц журнал_празмести(ук p, т_мера размер) { }\n        проц журнал_освободи(ук p) { }\n        проц журнал_сборка() { }\n        проц журнал_родитель(ук p, ук родитель) { }\n    }\n}\n\n\n/* ============================ Пул  =============================== */\n\n\nstruct Пул\n{\n    байт* адрОсновы;\n    байт* адрВерха;\n    СМБиты пометь;        // уже сканированные записи, либо не подлежащие сканированию\n    СМБиты скан;        // нуждающиеся в сканировании записи\n    СМБиты своббиты;    // записи в списке высвобождения\n    СМБиты финалы;      // записи, для которых нужен запуст финализатора\n    СМБиты нескан;      // записи, не подлежащие сканированию\n\n    т_мера члостр;\n    т_мера члопереданных;    // члопереданных <= члостр\n    ббайт* таблица_страниц;\n\t\n\tСМБиты мождоб;\n\tСМБиты безнутра; \n\tт_мера свобстры;\n\t\n\tбул объектБольшой;\n    бул старИзмы;  \n    бул новИзмы; \n\n    бцел* смещБСтр;\n\tт_мера стартПоиска;\n\t\n\tбайт *дайАдрОсновы(){return адрОсновы;}\n\tбайт *дайАдрВерха(){return адрВерха;}\n\tббайт *дайТаблицуСтраниц(){return таблица_страниц;}\n\n    проц иниц(т_мера члостр, бул объектБольшой)\n    {\n\t\tthis.объектБольшой = объектБольшой;\n        т_мера размерПула;\n\n        //debug(НА_КОНСОЛЬ) эхо(\"Пул::Пул(%u)\\n\", члостр);\n        размерПула = члостр * РАЗМЕР_СТРАНИЦЫ;\n        assert(размерПула >= РАЗМЕР_ПУЛА);\n        адрОсновы = cast(байт *)ос_памВкарту(размерПула);\n\n        // Some of the code depends on page alignment of memory pools\n        assert((cast(т_мера)адрОсновы & (РАЗМЕР_СТРАНИЦЫ - 1)) == 0);\n\n        if (!адрОсновы)\n        {\n            //debug(НА_КОНСОЛЬ) эхо(\"СМ fail: размерПула = x%x, errno = %d\\n\", размерПула, errno);\n            //debug(НА_КОНСОЛЬ) эхо(\"message = '%s'\\n\", sys_errсписок[errno]);\n\n            члостр = 0;\n            размерПула = 0;\n        }\n        //assert(адрОсновы);\n        адрВерха = адрОсновы + размерПула;\n\t\t auto div = this.divisor;\n        auto члобит = cast(т_мера)размерПула / div;\n\t\t\n        пометь.размести(cast(т_мера)члобит);\n        скан.размести(cast(т_мера) члобит);\n\t\t\n\t\t if(!объектБольшой)\n        {\n        своббиты.размести(cast(т_мера)члобит);\n\t\t}\n        нескан.размести(cast(т_мера)члобит);\n\t\tмождоб.размести(члобит);\n\n        таблица_страниц = cast(ббайт*)cidrus.празмести(члостр);\n        if (!таблица_страниц)\n            throw new ВнеПамИскл();\n\t\t\t\n\t\t if(объектБольшой)\n        {\n            смещБСтр = cast(бцел*)cidrus.празмести(члостр * бцел.sizeof);\n            if (!смещБСтр)\n                throw new ВнеПамИскл();\n        }\n        cidrus.memset(таблица_страниц, Б_НЕПОДАНО, члостр);\n\n        this.члостр = члостр;\n\t\tthis.свобстры = члостр;\n        члопереданных = 0;\n    }\n\n\n    проц Дтор()\n    {\n        if (адрОсновы)\n        {\n            цел результат;\n\n            if (члопереданных)\n            {\n                результат = ос_памДекоммит(адрОсновы, 0, члопереданных * РАЗМЕР_СТРАНИЦЫ);\n                assert(результат == 0);\n                члопереданных = 0;\n            }\n\n            if (члостр)\n            {\n                результат = ос_памИЗкарты(адрОсновы, члостр * РАЗМЕР_СТРАНИЦЫ);\n\t\t\t\tassert(результат == 0);\n                члостр = 0;\n            }\n\n            адрОсновы = null;\n            адрВерха = null;\n        }\n        if (таблица_страниц)\n            cidrus.освободи(таблица_страниц);\n\t\t\n\t\t         if(смещБСтр)\n            cidrus.освободи(смещБСтр);\n\n        пометь.Дтор();\n        скан.Дтор();\n\t\tif(объектБольшой)\n        {\n            безнутра.Дтор();\n        }\n        else\n        {\n        своббиты.Дтор();\n\t\t}\n        финалы.Дтор();\n        нескан.Дтор();\n\t\tмождоб.Дтор();\n    }\n\n\n    проц Invariant() { }\n\n\n    invariant\n    {\n     инвариант();        \n    }\n\nprivate\tпроц инвариант()\n\t{\n\tif (адрОсновы)\n        {\n            assert(адрОсновы + члостр * РАЗМЕР_СТРАНИЦЫ == адрВерха, \"Первый ассёрт инварианта Пула СМ\");\n            assert(члопереданных <= члостр, \"Второй ассёрт инварианта Пула СМ\");\n        }\n\n        for (т_мера инд = 0; инд < члостр; инд++)\n        {   Бины бин = cast(Бины)таблица_страниц[инд];\n\n            assert(бин < Б_МАКС, \"Третий ассёрт инварианта Пула СМ\");\n        }\n\t}\n\t\n\tprivate т_мера divisor()\n    {\n        // NOTE: Since this is called by initialize it must be private or\n        //       invariant() will be called and fail.\n        return объектБольшой ? РАЗМЕР_СТРАНИЦЫ : 16;\n    }\n\t\n\tбцел смещНа()\n    {\n        return объектБольшой ? 12 : 4;\n    }\n\t\n\tпроц обновиСмещения(т_мера откуда)\n    {\n        assert(таблица_страниц[откуда] == Б_СТР);\n        т_мера pn = откуда + 1;\n        for(бцел смещение = 1; pn < члопереданных; pn++, смещение++)\n        {\n            if(таблица_страниц[pn] != Б_СТРПЛЮС) break;\n            смещБСтр[pn] = смещение;\n        }\n\n        // Store the размер of the block in смещБСтр[откуда].\n        смещБСтр[откуда] = cast(бцел) (pn - откуда);\n    }\n\n    /**\n     * Размещает n страниц в Пул.\n     * Возвращает СБОЙ_ОП при провале.\n     */\n    т_мера разместиСтраницы(т_мера n)\n    {\n\t\n\tif(свобстры < n) return СБОЙ_ОП;\n        т_мера инд;\n        т_мера n2;\n\n        //debug(НА_КОНСОЛЬ) эхо(\"Пул::разместиСтраницы(n = %d)\\n\", n);\n        n2 = n;\n        for (инд = стартПоиска; инд < члопереданных; инд++)\n        {\n            if (таблица_страниц[инд] == Б_ОСВОБ)\n            {\n\t\t\t\n                if(таблица_страниц[стартПоиска] < Б_ОСВОБ)\n                {\n                    стартПоиска = инд + (!объектБольшой);\n                }\n\n                if (--n2 == 0)\n                {   //debug(PRINTF) эхо(\"\\texisting pn = %d\\n\", инд - n + 1);\n                    return инд - n + 1;\n                }\n            }\n            else\n\t\t\t{\n            n2 = n;\n\t\t\tif(таблица_страниц[инд] == Б_СТР)\n                {\n                    // Then we have the смещение information.  We can skip a\n                    // whole bunch of stuff.\n                    инд += смещБСтр[инд] - 1;\n                }\n            }\n        }\n\n        if(таблица_страниц[стартПоиска] < Б_ОСВОБ)\n        {\n            стартПоиска = члопереданных;\n        }\n        return увеличьСтраницы(n);\n    }\n\n    /**\n     * Расширяет Пул на n страниц.\n     * При провале возвращает СБОЙ_ОП.\n     */\n    т_мера увеличьСтраницы(т_мера n)\n    {\n        //debug(НА_КОНСОЛЬ) эхо(\"Пул::увеличьСтраницы(n = %d)\\n\", n);\n        if (члопереданных + n <= члостр)\n        {\n            т_мера к_передаче;\n\n            к_передаче = (n + (РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ) - 1) & ~(РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ - 1);\n            if (члопереданных + к_передаче > члостр)\n                к_передаче = члостр - члопереданных;\n            //debug(НА_КОНСОЛЬ) эхо(\"\\tlooking to commit %d more pages\\n\", к_передаче);\n            //fflush(stdout);\n            if (ос_памКоммит(адрОсновы, члопереданных * РАЗМЕР_СТРАНИЦЫ, к_передаче * РАЗМЕР_СТРАНИЦЫ) == 0)\n            {\n                cidrus.memset(таблица_страниц + члопереданных, Б_ОСВОБ, к_передаче);\n                auto инд = члопереданных;\n                члопереданных += к_передаче;\n\n                while (инд && таблица_страниц[инд - 1] == Б_ОСВОБ)\n                    инд--;\n\n                return инд;\n            }\n            //debug(НА_КОНСОЛЬ) эхо(\"\\tfailed to commit %d pages\\n\", к_передаче);\n        }\n\n        return СБОЙ_ОП;\n    }\n\t\n\t  /**\n     * расширяет диапазон страниц до n страниц как минимум.Возвращает\n     * число добавленных страниц.\n     */\n    т_мера увеличьЧлоСтрДо(т_мера n)\n    {\n        //debug(PRINTF) эхо(\"Pool::увеличьЧлоСтрДо(n = %d)\\n\", n);\n        if (члопереданных + n > члостр)\n            n = члостр - члопереданных;\n        т_мера к_передаче;\n\n        к_передаче = (n + (РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ) - 1) & ~(РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ - 1);\n        if (члопереданных + к_передаче > члостр)\n            к_передаче = члостр - члопереданных;\n        if(к_передаче == 0)\n            return 0;\n        //debug(PRINTF) эхо(\"\\tlooking to commit %d more pages\\n\", к_передаче);\n            //fflush(stdout);\n        if (ос_памКоммит(адрОсновы, члопереданных * РАЗМЕР_СТРАНИЦЫ, к_передаче * РАЗМЕР_СТРАНИЦЫ) == 0)\n        {\n            memset(таблица_страниц + члопереданных, Б_ОСВОБ, к_передаче);\n            члопереданных += к_передаче;\n\n            return к_передаче > n;\n        }\n        //debug(PRINTF) эхо(\"\\tfailed to commit %d pages\\n\", к_передаче);\n\n        return СБОЙ_ОП;\n    }\n\n\n    /**\n     * Освобождает члостр, начиная с номерстр.\n     */\n    проц освободиСтраницы(т_мера номерстр, т_мера члостр)\n    {\n        //cidrus.memset(&таблица_страниц[номерстр], Б_ОСВОБ, члостр);\n\t\tif(номерстр < стартПоиска) стартПоиска = номерстр;\n\n        for(т_мера инд = номерстр; инд < члостр + номерстр; инд++)\n        {\n            if(таблица_страниц[инд] < Б_ОСВОБ)\n            {\n                свобстры++;\n            }\n\n            таблица_страниц[инд] = Б_ОСВОБ;\n        }\n    }\n\t\n\t\n    /**\n     * Используется для сортировки таблица_пулов[]\n     */\n    цел opCmp(Пул *p2)\n    {\n        if (адрОсновы < p2.адрОсновы)\n            return -1;\n        else\n        return cast(цел)(адрОсновы > p2.адрОсновы);\n    }\n}\n\n\n/* ============================ SENTINEL =============================== */\n\n\nversion (SENTINEL)\n{\n    const т_мера SENTINEL_PRE = cast(т_мера) 0xF4F4F4F4F4F4F4F4UL; // 32 or 64 биты\n    const ббайт SENTINEL_POST = 0xF5;           // 8 биты\n    const бцел SENTINEL_EXTRA = 2 * т_мера.sizeof + 1;\n\n\n    т_мера* сентинель_размер(ук p)  { return &(cast(т_мера *)p)[-2]; }\n    т_мера* sentinel_pre(ук p)   { return &(cast(т_мера *)p)[-1]; }\n    ббайт* sentinel_post(ук p) { return &(cast(ббайт *)p)[*сентинель_размер(p)]; }\n\n\n    проц сентинель_иниц(ук p, т_мера размер)\n    {\n        *сентинель_размер(p) = размер;\n        *sentinel_pre(p) = SENTINEL_PRE;\n        *sentinel_post(p) = SENTINEL_POST;\n    }\n\n\n    проц сентинель_Инвариант(ук p)\n    {\n        assert(*sentinel_pre(p) == SENTINEL_PRE);\n        assert(*sentinel_post(p) == SENTINEL_POST);\n    }\n\n\n    ук сентинель_добавь(ук p)\n    {\n        return p + 2 * т_мера.sizeof;\n    }\n\n\n    ук сентинель_отн(ук p)\n    {\n        return p - 2 * т_мера.sizeof;\n    }\n}\nelse\n{\n    const бцел SENTINEL_EXTRA = 0;\n\n\n    проц сентинель_иниц(ук p, т_мера размер)\n    {\n    }\n\n\n    проц сентинель_Инвариант(ук p)\n    {\n    }\n\n\n    ук сентинель_добавь(ук p)\n    {\n        return p;\n    }\n\n\n    ук сентинель_отн(ук p)\n    {\n        return p;\n    }\n}\n\n////////////////////\n\nexport extern (C) т_см смНовый()\n\t{\n\t\tversion (all)\n\t\t{\n\t\tук  укз;\n\t\tClassInfo ci = СМ.classinfo;\n\t\tукз = cidrus.празмести(ci.init.length);\n\t\t(cast(байт*)укз)[0 .. ci.init.length] = ci.init[];\n\t\t//debug эхо(\"(gc ln 3735) Returning from gcNew all\\n\");\n\t\treturn cast(т_см)укз;\n\t\t}\n\t\telse\n\t\t{\n\t\t//debug эхо(\"(gc ln 3735) Returning from gcNew else\\n\");\n\t\treturn cast(т_см)cidrus.кразмести(1, СМ.sizeof);\n\t\t}\n\t}\n\nexport extern (C) проц смУдали(т_см см)\n\t{\n\t\tсм.Дтор();\n\t\tcidrus.освободи(cast(ук )см);\n\t}\n\n/////////////////////////////////////////////////////////////////////////////////\n",
			"file": "gc.d",
			"file_size": 159588,
			"file_write_time": 131305340054316406,
			"settings":
			{
				"buffer_size": 117425,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "module cidrus;\n\nimport /*rt.console*/ std.string: toStringz, toString;\n import std.utf: toUTF16z;\n public import tpl.args;\n \n alias toStringz вТкст0;\nalias toString вТкст;\n\nenum ППозКурсора {\n  Уст,\n  Тек,\n  Кон,   \n}\n\n enum\n    {\n\tФУК_ДОБАВКА\t= 0x04,\n\tФУК_УСТРВО\t= 0x08,\n\tФУК_ТЕКСТ\t= 0x10,\n\tФУК_БАЙТ\t= 0x20,\n\tФУК_ШИМ\t= 0x40,\n   \n    ВВФБФ   = 0,\n    ВВЛБФ   = 0x40,\n\tВВНБФ   = 4,\n    ВВЧИТ  = 1,\t  // non-standard\n    ВВЗАП   = 2,\t  // non-standard\n    ВВМОЙБУФ = 8,\t  // non-standard\t\n    ВВКФ   = 0x10,  // non-standard\n    ВВОШ   = 0x20,  // non-standard\n    ВВСТРЖ  = 0x40,  // non-standard\n    ВВЧЗ    = 0x80,  // non-standard\n    ВВТРАН  = 0x100, // non-standard\n    ВВПРИЛ   = 0x200, // non-standard\n    }\n\n enum\n    {\n        РАЗМБУФ       = 0x4000,\n        КФ          = -1,//конец файла\n        МАКС_ОТКРФ    = 20,\n        МАКС_ИМЯФ = 256, // 255 plus NULL\n        МАКС_ВРЕМ      = 32767,\n        СИС_ОТКР     = 20,\t// non-standard\n    }\n\nconst шим ШКФ = 0xFFFF;\n\nconst дво ДВОБЕСК      = дво.infinity;\nconst дво ПЛАВБЕСК     = плав.infinity;\nconst дво РЕАЛБЕСК    = реал.infinity;\n\nconst СИМБИТ       = 8;\nconst БАЙТМИН      = байт.min;\nconst БАЙТМАКС      = байт.max;\nconst ББАЙТМИН      = ббайт.min;\nconst СИММИН       = сим.min;\nconst СИММАКС       = сим.max;\nconst МБДЛИНМАКС     = 2;\nconst КРАТМИН       = крат.min;\nconst КРАТМАКС       = крат.max;\nconst БКРАТМАКС      = бкрат.max;\nconst ЦЕЛМИН        = цел.min;\nconst ЦЕЛМАКС        = цел.max;\nconst БЦЕЛМАКС       = бцел.max;\nconst ДОЛМИН      = дол.min;\nconst ДОЛМАКС      = дол.max;\nconst БДОЛМАКС     = бдол.max;\n\nconst ПЛАВОКРУГЛ\t\t\t= 1;\nconst ПЛАВМЕТОДОЦЕНКИ\t= 2;\nconst ПЛАВКОРЕНЬ\t\t\t= 2;\n\nconst ПЛАВЦИФР\t\t\t= плав.dig;\nconst ДВОЦИФР\t\t\t= дво.dig;\nconst РЕАЛЦИФР\t\t\t= реал.dig;\n\nconst ПЛАВМАНТЦИФР\t\t= плав.mant_dig;\nconst ДВОМАНТЦИФР\t\t= дво.mant_dig;\nconst РЕАЛМАНТЦИФР\t\t= реал.mant_dig;\n\nconst ПЛАВМИН\t\t\t= плав.min;\nconst ДВОМИН\t\t\t= дво.min;\nconst РЕАЛМИН\t\t\t= реал.min;\n\nconst ПЛАВМАКС\t\t\t= плав.max;\nconst ДВОМАКС\t\t\t= дво.max;\nconst РЕАЛМАКС\t\t\t= реал.max;\n\nconst ПЛАВЭПС\t\t= плав.epsilon;\nconst ДВОЭПС\t\t= дво.epsilon;\nconst РЕАЛЭПС\t\t= реал.epsilon;\n\nconst ПЛАВМИНЭКСП\t\t= плав.min_exp;\nconst ДВОМИНЭКСП\t\t= дво.min_exp;\nconst РЕАЛМИНЭКСП\t\t= реал.min_exp;\n\nconst ПЛАВМАКСЭКСП\t\t= плав.max_exp;\nconst ДВОМАКСЭКСП\t\t= дво.max_exp;\nconst РЕАЛМАКСЭКСП\t\t= реал.max_exp;\n\nconst ПЛАВМИН10ЭКСП\t\t= плав.min_10_exp;\nconst ДВОМИН10ЭКСП\t\t= дво.min_10_exp;\nconst РЕАЛМИН10ЭКСП\t= реал.min_10_exp;\n\nconst ПЛАВМАКС10ЭКСП\t\t= плав.max_10_exp;\nconst ДВОМАКС10ЭКСП\t\t= дво.max_10_exp;\nconst РЕАЛМАКС10ЭКСП\t= реал.max_10_exp;\n\nconst плав БЕСКОНЕЧНОСТЬ       = плав.infinity;\nconst плав Н_Ч            = плав.nan;\n\nconst цел ПЗ_ИЛОГБ0        = цел.min;\nconst цел ПЗ_ИЛОГБНЧ      = цел.min;\n\nconst цел МАТОШ       = 1;//математическая ошибка\nconst цел МАТОШИСКЛ   = 2;\nconst цел матошобработка = МАТОШ | МАТОШИСКЛ;\n\nconst ЛП_СИТИП          = 0;\nconst ЛП_ЧИСЛО        = 1;\nconst ЛП_ВРЕМЯ           = 2;\nconst ЛП_КОЛЛЕЙТ        = 3;\nconst ЛП_МОНЕТА       = 4;\nconst ЛП_ВСЕ            = 6;\nconst ЛП_БУМАГА          = 7;  // non-standard\nconst ЛП_ИМЯ           = 8;  // non-standard\nconst ЛП_АДРЕС        = 9;  // non-standard\nconst ЛП_ТЕЛЕФОН      = 10; // non-standard\nconst ЛП_МЕРА    = 11; // non-standard\nconst ЛП_ИДЕНТИФИКАЦИЯ = 12; // non-standard\n\nenum ФИскл\n{\n    Повреждён      = 1,\n    Ненорм     = 2, // non-standard\n    ДелениеНаНоль    = 4,\n    Переполнение     = 8,\n    Недополнение    = 0x10,\n    Неточность      = 0x20,\n    ВсеИскл   = 0x3F,\n    КБлиж    = 0,\n    Выше       = 0x800,\n    Ниже     = 0x400,\n    КНулю   = 0xC00,\n}\n\nextern(C)\n{\n//сиэф = экспортируемая си-функция\nalias  проц function() сифунк;\nalias проц function(цел) сифунк_Ц;\nalias проц function(цел, цел) сифунк_ЦЦ;\nalias проц function(цел, цел, цел) сифунк_ЦЦЦ;\nalias проц function(цел, цел, цел, цел) сифунк_ЦЦЦЦ;\nalias проц function(цел, цел, цел, цел, цел) сифунк_ЦЦЦЦЦ;\nalias проц function(сим, цел, цел) сифунк_СЦЦ;\nalias проц function(ббайт, цел, цел) сифунк_бБЦЦ;\nalias  проц function(ук) сифунк_У;\nalias проц function(бцел, цел, цел, цел) сифунк_бЦЦЦЦ; \n\nalias цел function() сифункЦ; \nalias цел function(сим, цел, цел) сифункЦ_СЦЦ;\nalias цел function(ббайт, цел, цел) сифункЦ_бБЦЦ;\nalias цел function(цел) сифункЦ_Ц;\nalias цел function(цел, цел) сифункЦ_ЦЦ;\nalias цел function(цел, цел, цел) сифункЦ_ЦЦЦ;\nalias цел function(цел, цел, цел, цел) сифункЦ_ЦЦЦЦ;\nalias цел function (ук, бцел, бцел, цел) сифункЦ_УбЦбЦЦ;\n\nalias бцел function() сифункбЦ; \nalias бцел function (ук, бцел, бцел, цел) сифункбЦ_УбЦбЦЦ;\nalias  бцел function(ук) сифункбЦ_У;\n\nalias дво  function() сифункД2; \nalias плав  function() сифункП; \nalias ук   function() сифункУ; \nalias байт  function() сифункБ; \nalias ббайт  function() сифункбБ; \nalias сим  function() сифункС; \nalias усим function() сифункуС;\nalias шим  function() сифункШ;\nalias ушим function() сифункуШ;\nalias дол  function() сифункД;\nalias бдол  function() сифункбД;\n\nalias бул  function() сифункБ2;\nalias бул function(бцел) сифункБ2_бЦ;\n//alias struct систрукт;\n//alias class сикласс;\n}\n\nalias проц function(цел) т_сигфн, sigfn_t;\n\n\n//const wchar WEOF = 0xFFFF;\t \n const CHAR_BIT       = 8;\nconst SCHAR_MIN      = byte.min;\nconst SCHAR_MAX      = byte.max;\nconst UCHAR_MAX      = ubyte.min;\nconst CHAR_MIN       = сим.max;\nconst CHAR_MAX       = сим.max;\nconst MB_LEN_MAX     = 2;\nconst SHRT_MIN       = short.min;\nconst SHRT_MAX       = short.max;\nconst USHRT_MAX      = ushort.max;\nconst INT_MIN        = int.min;\nconst INT_MAX        = int.max;\nconst UINT_MAX       = uint.max;\nconst LONG_MIN       = c_long.min;\nconst LONG_MAX       = c_long.max;\nconst ULONG_MAX      = c_ulong.max;\nconst LLONG_MIN      = long.min;\nconst LLONG_MAX      = long.max;\nconst ULLONG_MAX     = ulong.max;\n\nconst int FP_ILOGB0        = int.min;\nconst int FP_ILOGBNAN      = int.min;\n \nconst УДАЧНЫЙ_ВЫХОД = 0;\nconst НЕУДАЧНЫЙ_ВЫХОД = 1;\nconst СЛУЧ_МАКС     = 32767;\nconst МБ_ТЕК_МАКС   = 1;\n \n     enum\n    {\n        FP_NANS        = 0,\n        FP_NANQ        = 1,\n        FP_INFINITE    = 2,\n        FP_NORMAL      = 3,\n        FP_SUBNORMAL   = 4,\n        FP_ZERO        = 5,\n        FP_NAN         = FP_NANQ,\n        FP_EMPTY       = 6,\n        FP_UNSUPPORTED = 7,\n    }\n\t\nenum\n{\n    SEEK_SET,\n    SEEK_CUR,\n    SEEK_END\n}\n\t\n \n\nextern  (C) \n{\n\t\n\tstruct div_t\n\t{\n\t\tint quot,\n\t\t\trem;\n\t}\n\n\nstruct ldiv_t\n\t{\n\t\tint quot,\n\t\t\trem;\n\t}\nstruct lldiv_t\n\t{\n\t\tlong quot,\n\t\t\t rem;\n\t}\n\t\nstruct imaxdiv_t\n{\n    intmax_t    quot,\n                rem;\n}\n\n\nintmax_t  imaxabs(intmax_t j);\nimaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);\nintmax_t  strtoimax(in char* nptr, char** endptr, int base);\nuintmax_t strtoumax(in char* nptr, char** endptr, int base);\nintmax_t  wcstoimax(in wchar_t* nptr, wchar_t** endptr, int base);\nuintmax_t wcstoumax(in wchar_t* nptr, wchar_t** endptr, int base);\n\n\n\nvoid _c_exit();\nvoid _cexit();\nvoid _exit(int);\nvoid abort();\nvoid _dodtors();\nint getpid();\nvoid    exit(int status);\nint     atexit(void function() func);\nvoid    _Exit(int status);\n\n\n\nenum { _P_WAIT, _P_NOWAIT, _P_OVERLAY };\n\nint execl(сим *, сим *,...);\nint execle(сим *, сим *,...);\nint execlp(сим *, сим *,...);\nint execlpe(сим *, сим *,...);\nint execv(сим *, сим **);\nint execve(сим *, сим **, сим **);\nint execvp(сим *, сим **);\nint execvpe(сим *, сим **, сим **);\n\n\nenum { WAIT_CHILD, WAIT_GRANDCHILD }\n\nint cwait(int *,int,int);\nint wait(int *);\n\nversion (Windows)\n{\n\nalias void function(void *) _У;\n    uint _beginthread( _У ,uint, void *);\n\n    extern  (Windows) alias uint (*stdfp)(void *);\n\n    uint _beginthreadex(void* security, uint stack_size,\n\t    stdfp start_addr, void* arglist, uint initflag,\n\t    uint* thrdaddr);\n\n    void _endthread();\n    void _endthreadex(uint);\n\n    int spawnl(int, сим *, сим *,...);\n    int spawnle(int, сим *, сим *,...);\n    int spawnlp(int, сим *, сим *,...);\n    int spawnlpe(int, сим *, сим *,...);\n    int spawnv(int, сим *, сим **);\n    int spawnve(int, сим *, сим **, сим **);\n    int spawnvp(int, сим *, сим **);\n    int spawnvpe(int, сим *, сим **, сим **);\n\n\n    int _wsystem(wchar_t *);\n    int _wspawnl(int, wchar_t *, wchar_t *, ...);\n    int _wspawnle(int, wchar_t *, wchar_t *, ...);\n    int _wspawnlp(int, wchar_t *, wchar_t *, ...);\n    int _wspawnlpe(int, wchar_t *, wchar_t *, ...);\n    int _wspawnv(int, wchar_t *, wchar_t **);\n    int _wspawnve(int, wchar_t *, wchar_t **, wchar_t **);\n    int _wspawnvp(int, wchar_t *, wchar_t **);\n    int _wspawnvpe(int, wchar_t *, wchar_t **, wchar_t **);\n\n    int _wexecl(wchar_t *, wchar_t *, ...);\n    int _wexecle(wchar_t *, wchar_t *, ...);\n    int _wexeclp(wchar_t *, wchar_t *, ...);\n    int _wexeclpe(wchar_t *, wchar_t *, ...);\n    int _wexecv(wchar_t *, wchar_t **);\n    int _wexecve(wchar_t *, wchar_t **, wchar_t **);\n    int _wexecvp(wchar_t *, wchar_t **);\n    int _wexecvpe(wchar_t *, wchar_t **, wchar_t **);\n}\n\n\nint iswalnum(wint_t wc);\nint iswalpha(wint_t wc);\nint iswblank(wint_t wc);\nint iswcntrl(wint_t wc);\nint iswdigit(wint_t wc);\nint iswgraph(wint_t wc);\nint iswlower(wint_t wc);\nint iswprint(wint_t wc);\nint iswpunct(wint_t wc);\nint iswspace(wint_t wc);\nint iswupper(wint_t wc);\nint iswxdigit(wint_t wc);\n\nint       iswctype(wint_t wc, wctype_t desc);\nwctype_t  wctype(in char* property);\nwint_t    towlower(wint_t wc);\nwint_t    towupper(wint_t wc);\nwint_t    towctrans(wint_t wc, wctrans_t desc);\nwctrans_t wctrans(in char* property);\n\t\nvoid* memchr(in void* s, int c, size_t n);\nint   memcmp(in void* s1, in void* s2, size_t n);\nvoid* memcpy(void* s1, in void* s2, size_t n);\nvoid* memmove(void* s1, in void* s2, size_t n);\nvoid* memset(void* s, int c, size_t n);\n\nchar*  strcpy(char* s1, in char* s2);\nchar*  strncpy(char* s1, in char* s2, size_t n);\nchar*  strcat(char* s1, in char* s2);\nchar*  strncat(char* s1, in char* s2, size_t n);\nint    strcmp(in char* s1, in char* s2);\nint    strcoll(in char* s1, in char* s2);\nint    strncmp(in char* s1, in char* s2, size_t n);\nsize_t strxfrm(char* s1, in char* s2, size_t n);\nchar*  strchr(in char* s, int c);\nsize_t strcspn(in char* s1, in char* s2);\nchar*  strpbrk(in char* s1, in char* s2);\nchar*  strrchr(in char* s, int c);\nsize_t strspn(in char* s1, in char* s2);\nchar*  strstr(in char* s1, in char* s2);\nchar*  strtok(char* s1, in char* s2);\nchar*  strerror(int errnum);\nsize_t strlen(in char* s);\n\nint memicmp(char* s1, char* s2, size_t n);\n\t\t\n\tint _fputc_nlock(int, FILE*);\n\tint _fputwc_nlock(int, FILE*);\n\tint _fgetc_nlock(FILE*);\n\tint _fgetwc_nlock(FILE*);\n\tint __fp_lock(FILE*);\n\tпроц __fp_unlock(FILE*);\n\t\n\tint getErrno();      // for internal use\n\tint setErrno(int);   // for internal use\n\t\n\t    struct fenv_t\n    {\n        ushort    status;\n        ushort    control;\n        ushort    round;\n        ushort[2] reserved;\n    }\n\t\n\tvoid feraiseexcept(int excepts);\n\tvoid feclearexcept(int excepts);\n\n\tint fetestexcept(int excepts);\n\tint feholdexcept(fenv_t* envp);\n\n\tvoid fegetexceptflag(fexcept_t* flagp, int excepts);\n\tvoid fesetexceptflag(in fexcept_t* flagp, int excepts);\n\n\tint fegetround();\n\tint fesetround(int round);\n\n\tvoid fegetenv(fenv_t* envp);\n\tvoid fesetenv(in fenv_t* envp);\n\tvoid feupdateenv(in fenv_t* envp);\n\t\nalias creal complex;\nalias ireal imaginary;\n\ncdouble cacos(cdouble z);\ncfloat  cacosf(cfloat z);\ncreal   cacosl(creal z);\n\ncdouble casin(cdouble z);\ncfloat  casinf(cfloat z);\ncreal   casinl(creal z);\n\ncdouble catan(cdouble z);\ncfloat  catanf(cfloat z);\ncreal   catanl(creal z);\n\ncdouble ccos(cdouble z);\ncfloat  ccosf(cfloat z);\ncreal   ccosl(creal z);\n\ncdouble csin(cdouble z);\ncfloat  csinf(cfloat z);\ncreal   csinl(creal z);\n\ncdouble ctan(cdouble z);\ncfloat  ctanf(cfloat z);\ncreal   ctanl(creal z);\n\ncdouble cacosh(cdouble z);\ncfloat  cacoshf(cfloat z);\ncreal   cacoshl(creal z);\n\ncdouble casinh(cdouble z);\ncfloat  casinhf(cfloat z);\ncreal   casinhl(creal z);\n\ncdouble catanh(cdouble z);\ncfloat  catanhf(cfloat z);\ncreal   catanhl(creal z);\n\ncdouble ccosh(cdouble z);\ncfloat  ccoshf(cfloat z);\ncreal   ccoshl(creal z);\n\ncdouble csinh(cdouble z);\ncfloat  csinhf(cfloat z);\ncreal   csinhl(creal z);\n\ncdouble ctanh(cdouble z);\ncfloat  ctanhf(cfloat z);\ncreal   ctanhl(creal z);\n\ncdouble cexp(cdouble z);\ncfloat  cexpf(cfloat z);\ncreal   cexpl(creal z);\n\ncdouble clog(cdouble z);\ncfloat  clogf(cfloat z);\ncreal   clogl(creal z);\n\n double cabs(cdouble z);\n float  cabsf(cfloat z);\n real   cabsl(creal z);\n\ncdouble cpow(cdouble x, cdouble y);\ncfloat  cpowf(cfloat x, cfloat y);\ncreal   cpowl(creal x, creal y);\n\ncdouble csqrt(cdouble z);\ncfloat  csqrtf(cfloat z);\ncreal   csqrtl(creal z);\n\n double carg(cdouble z);\n float  cargf(cfloat z);\n real   cargl(creal z);\n\n double cimag(cdouble z);\n float  cimagf(cfloat z);\n real   cimagl(creal z);\n\ncdouble conj(cdouble z);\ncfloat  conjf(cfloat z);\ncreal   conjl(creal z);\n\ncdouble cproj(cdouble z);\ncfloat  cprojf(cfloat z);\ncreal   cprojl(creal z);\n\n// double creal(cdouble z);\n float  crealf(cfloat z);\n real   creall(creal z);\n \nint isalnum(int c);\nint isalpha(int c);\nint isblank(int c);\nint iscntrl(int c);\nint isdigit(int c);\nint isgraph(int c);\nint islower(int c);\nint isprint(int c);\nint ispunct(int c);\nint isspace(int c);\nint isupper(int c);\nint isxdigit(int c);\nint tolower(int c);\nint toupper(int c);\n\nstruct lconv\n{\n    char* decimal_point;\n    char* thousands_sep;\n    char* grouping;\n    char* int_curr_symbol;\n    char* currency_symbol;\n    char* mon_decimal_point;\n    char* mon_thousands_sep;\n    char* mon_grouping;\n    char* positive_sign;\n    char* negative_sign;\n    byte  int_frac_digits;\n    byte  frac_digits;\n    byte  p_cs_precedes;\n    byte  p_sep_by_space;\n    byte  n_cs_precedes;\n    byte  n_sep_by_space;\n    byte  p_sign_posn;\n    byte  n_sign_posn;\n    byte  int_p_cs_precedes;\n    byte  int_p_sep_by_space;\n    byte  int_n_cs_precedes;\n    byte  int_n_sep_by_space;\n    byte  int_p_sign_posn;\n    byte  int_n_sign_posn;\n}\n\nchar*  setlocale(int category, in char* locale);\nlconv* localeconv();\n\t\n    uint __fpclassify_f(float x);\n    uint __fpclassify_d(double x);\n    uint __fpclassify_ld(real x);\n\t\n\t double  acos(double x);\n    float   acosf(float x);\n    real    acosl(real x);\n\n    double  asin(double x);\n    float   asinf(float x);\n    real    asinl(real x);\n\n    double  atan(double x);\n    float   atanf(float x);\n    real    atanl(real x);\n\n    double  atan2(double y, double x);\n    float   atan2f(float y, float x);\n    real    atan2l(real y, real x);\n\n    double  cos(double x);\n    float   cosf(float x);\n    real    cosl(real x);\n\n    double  sin(double x);\n    float   sinf(float x);\n    real    sinl(real x);\n\n    double  tan(double x);\n    float   tanf(float x);\n    real    tanl(real x);\n\n    double  acosh(double x);\n    float   acoshf(float x);\n    real    acoshl(real x);\n\n    double  asinh(double x);\n    float   asinhf(float x);\n    real    asinhl(real x);\n\n    double  atanh(double x);\n    float   atanhf(float x);\n    real    atanhl(real x);\n\n    double  cosh(double x);\n    float   coshf(float x);\n    real    coshl(real x);\n\n    double  sinh(double x);\n    float   sinhf(float x);\n    real    sinhl(real x);\n\n    double  tanh(double x);\n    float   tanhf(float x);\n    real    tanhl(real x);\n\n    double  exp(double x);\n    float   expf(float x);\n    real    expl(real x);\n\n    double  exp2(double x);\n    float   exp2f(float x);\n    real    exp2l(real x);\n\n    double  expm1(double x);\n    float   expm1f(float x);\n    real    expm1l(real x);\n\n    double  frexp(double value, int* exp);\n    float   frexpf(float value, int* exp);\n    real    frexpl(real value, int* exp);\n\n    int     ilogb(double x);\n    int     ilogbf(float x);\n    int     ilogbl(real x);\n\n    double  ldexp(double x, int exp);\n    float   ldexpf(float x, int exp);\n    real    ldexpl(real x, int exp);\n\n    double  log(double x);\n    float   logf(float x);\n    real    logl(real x);\n\n    double  log10(double x);\n    float   log10f(float x);\n    real    log10l(real x);\n\n    double  log1p(double x);\n    float   log1pf(float x);\n    real    log1pl(real x);\n\n    double  log2(double x);\n    float   log2f(float x);\n    real    log2l(real x);\n\n    double  logb(double x);\n    float   logbf(float x);\n    real    logbl(real x);\n\n    double  modf(double value, double* iptr);\n    float   modff(float value, float* iptr);\n    real    modfl(real value, real *iptr);\n\n    double  scalbn(double x, int n);\n    float   scalbnf(float x, int n);\n    real    scalbnl(real x, int n);\n\n    double  scalbln(double x, c_long n);\n    float   scalblnf(float x, c_long n);\n    real    scalblnl(real x, c_long n);\n\n    double  cbrt(double x);\n    float   cbrtf(float x);\n    real    cbrtl(real x);\n\n    double  fabs(double x);\n    float   fabsf(float x);\n    real    fabsl(real x);\n\n    double  hypot(double x, double y);\n    float   hypotf(float x, float y);\n    real    hypotl(real x, real y);\n\n    double  pow(double x, double y);\n    float   powf(float x, float y);\n    real    powl(real x, real y);\n\n    double  sqrt(double x);\n    float   sqrtf(float x);\n    real    sqrtl(real x);\n\n    double  erf(double x);\n    float   erff(float x);\n    real    erfl(real x);\n\n    double  erfc(double x);\n    float   erfcf(float x);\n    real    erfcl(real x);\n\n    double  lgamma(double x);\n    float   lgammaf(float x);\n    real    lgammal(real x);\n\n    double  tgamma(double x);\n    float   tgammaf(float x);\n    real    tgammal(real x);\n\n    double  ceil(double x);\n    float   ceilf(float x);\n    real    ceill(real x);\n\n    double  floor(double x);\n    float   floorf(float x);\n    real    floorl(real x);\n\n    double  nearbyint(double x);\n    float   nearbyintf(float x);\n    real    nearbyintl(real x);\n\n    double  rint(double x);\n    float   rintf(float x);\n    real    rintl(real x);\n\n    c_long  lrint(double x);\n    c_long  lrintf(float x);\n    c_long  lrintl(real x);\n\n    long    llrint(double x);\n    long    llrintf(float x);\n    long    llrintl(real x);\n\n    double  round(double x);\n    float   roundf(float x);\n    real    roundl(real x);\n\n    c_long  lround(double x);\n    c_long  lroundf(float x);\n    c_long  lroundl(real x);\n\n    long    llround(double x);\n    long    llroundf(float x);\n    long    llroundl(real x);\n\n    double  trunc(double x);\n    float   truncf(float x);\n    real    truncl(real x);\n\n    double  fmod(double x, double y);\n    float   fmodf(float x, float y);\n    real    fmodl(real x, real y);\n\n    double  remainder(double x, double y);\n    float   remainderf(float x, float y);\n    real    remainderl(real x, real y);\n\n    double  remquo(double x, double y, int* quo);\n    float   remquof(float x, float y, int* quo);\n    real    remquol(real x, real y, int* quo);\n\n    double  copysign(double x, double y);\n    float   copysignf(float x, float y);\n    real    copysignl(real x, real y);\n\n    double  nan(char* tagp);\n    float   nanf(char* tagp);\n    real    nanl(char* tagp);\n\n    double  nextafter(double x, double y);\n    float   nextafterf(float x, float y);\n    real    nextafterl(real x, real y);\n\n    double  nexttoward(double x, real y);\n    float   nexttowardf(float x, real y);\n    real    nexttowardl(real x, real y);\n\n    double  fdim(double x, double y);\n    float   fdimf(float x, float y);\n    real    fdiml(real x, real y);\n\n    double  fmax(double x, double y);\n    float   fmaxf(float x, float y);\n    real    fmaxl(real x, real y);\n\n    double  fmin(double x, double y);\n    float   fminf(float x, float y);\n    real    fminl(real x, real y);\n\n    double  fma(double x, double y, double z);\n    float   fmaf(float x, float y, float z);\n    real    fmal(real x, real y, real z);\n\t\n\tint remove(in char* filename);\nint rename(in char* from, in char* to);\n\nFILE* tmpfile();\nchar* tmpnam(char* s);\n\nint   fclose(FILE* stream);\nint   fflush(FILE* stream);\nFILE* fopen(in char* filename, in char* mode);\nFILE* freopen(in char* filename, in char* mode, FILE* stream);\n\nvoid setbuf(FILE* stream, char* buf);\nint  setvbuf(FILE* stream, char* buf, int mode, size_t size);\n\nint fprintf(FILE* stream, in char* format, ...);\nint fscanf(FILE* stream, in char* format, ...);\nint sprintf(char* s, in char* format, ...);\nint sscanf(in char* s, in char* format, ...);\nint vfprintf(FILE* stream, in char* format, va_list арг);\nint vfscanf(FILE* stream, in char* format, va_list арг);\nint vsprintf(char* s, in char* format, va_list арг);\nint vsscanf(in char* s, in char* format, va_list арг);\nint vprintf(in char* format, va_list арг);\nint vscanf(in char* format, va_list арг);\n//int эхо(in char* format, ...);\nint scanf(in char* format, ...);\n\nint fgetc(FILE* stream);\nint fputc(int c, FILE* stream);\n\nchar* fgets(char* s, int n, FILE* stream);\nint   fputs(in char* s, FILE* stream);\nchar* gets(char* s);\nint   puts(in char* s);\n\nint ungetc(int c, FILE* stream);\n\nsize_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);\nsize_t fwrite(in void* ptr, size_t size, size_t nmemb, FILE* stream);\n\nint fgetpos(FILE* stream, fpos_t * pos);\nint fsetpos(FILE* stream, in fpos_t* pos);\n\nint    fseek(FILE* stream, c_long offset, int whence);\nc_long ftell(FILE* stream);\n\nint   _snprintf(char* s, size_t n, in char* fmt, ...);\nalias _snprintf snprintf;\n\nint   _vsnprintf(char* s, size_t n, in char* format, va_list арг);\nalias _vsnprintf vsnprintf;\n\nvoid perror(in char* s);\n\ndouble  atof(in char* nptr);\nint     atoi(in char* nptr);\nc_long  atol(in char* nptr);\nlong    atoll(in char* nptr);\n\ndouble  strtod(in char* nptr, char** endptr);\nfloat   strtof(in char* nptr, char** endptr);\nreal    strtold(in char* nptr, char** endptr);\nc_long  strtol(in char* nptr, char** endptr, int base);\nlong    strtoll(in char* nptr, char** endptr, int base);\nc_ulong strtoul(in char* nptr, char** endptr, int base);\nulong   strtoull(in char* nptr, char** endptr, int base);\n\nint     rand();\nvoid    srand(uint seed);\n\nvoid*   malloc(size_t size);\nvoid*   calloc(size_t nmemb, size_t size);\nvoid*   realloc(void* ptr, size_t size);\nvoid    free(void* ptr);\n\nchar*   getenv(in char* name);\nint     system(in char* string);\n\nvoid*   bsearch(in void* key, in void* base, size_t nmemb, size_t size, int function(in void*, in void*) compar);\nvoid    qsort(void* base, size_t nmemb, size_t size, int function(in void*, in void*) compar);\n\nint     abs(int j);\nc_long  labs(c_long j);\nlong    llabs(long j);\n\ndiv_t   div(int numer, int denom);\nldiv_t  ldiv(c_long numer, c_long denom);\nlldiv_t lldiv(long numer, long denom);\n\nint     mblen(in char* s, size_t n);\nint     mbtowc(wchar_t* pwc, in char* s, size_t n);\nint     wctomb(char*s, wchar_t wc);\nsize_t  mbstowcs(wchar_t* pwcs, in char* s, size_t n);\nsize_t  wcstombs(char* s, in wchar_t* pwcs, size_t n);\n\nversion( DigitalMars )\n\t{\n\t\tvoid* alloca(size_t size); // non-standard\n\t\t\n\t}\n\t\nversion( Windows )\n{\n    struct tm\n    {\n        int     tm_sec;     // seconds after the minute - [0, 60]\n        int     tm_min;     // minutes after the hour - [0, 59]\n        int     tm_hour;    // hours since midnight - [0, 23]\n        int     tm_mday;    // day of the month - [1, 31]\n        int     tm_mon;     // months since January - [0, 11]\n        int     tm_year;    // years since 1900\n        int     tm_wday;    // days since Sunday - [0, 6]\n        int     tm_yday;    // days since January 1 - [0, 365]\n        int     tm_isdst;   // Daylight Saving Time flag\n    }\n}\nelse\n{\n    struct tm\n    {\n        int     tm_sec;     // seconds after the minute [0-60]\n        int     tm_min;     // minutes after the hour [0-59]\n        int     tm_hour;    // hours since midnight [0-23]\n        int     tm_mday;    // day of the month [1-31]\n        int     tm_mon;     // months since January [0-11]\n        int     tm_year;    // years since 1900\n        int     tm_wday;    // days since Sunday [0-6]\n        int     tm_yday;    // days since January 1 [0-365]\n        int     tm_isdst;   // Daylight Savings Time flag\n        c_long  tm_gmtoff;  // offset from CUT in seconds\n        char*   tm_zone;    // timezone abbreviation\n    }\n}\n\nalias c_long time_t;\nalias c_long clock_t;\n\n\n clock_t CLOCKS_PER_SEC = 1000;\n\n\nclock_t clock();\ndouble  difftime(time_t time1, time_t time0);\ntime_t  mktime(tm* timeptr);\ntime_t  time(time_t* timer);\nchar*   asctime(in tm* timeptr);\nchar*   ctime(in time_t* timer);\ntm*     gmtime(in time_t* timer);\ntm*     localtime(in time_t* timer);\nsize_t  strftime(char* s, size_t maxsize, in char* format, in tm* timeptr);\n\n    void  tzset();  \t\t // non-standard\n    void  _tzset(); \t\t // non-standard\n    char* _strdate(char* s); // non-standard\n    char* _strtime(char* s); // non-standard\n\t\nalias int     mbstate_t;\n//alias wchar_t wint_t;\n\n//const wchar_t WEOF = 0xFFFF;\n\nint fwprintf(FILE* stream, in wchar_t* format, ...);\nint fwscanf(FILE* stream, in wchar_t* format, ...);\nint swprintf(wchar_t* s, size_t n, in wchar_t* format, ...);\nint swscanf(in wchar_t* s, in wchar_t* format, ...);\nint vfwprintf(FILE* stream, in wchar_t* format, va_list арг);\nint vfwscanf(FILE* stream, in wchar_t* format, va_list арг);\nint vswprintf(wchar_t* s, size_t n, in wchar_t* format, va_list арг);\nint vswscanf(in wchar_t* s, in wchar_t* format, va_list арг);\nint vwprintf(in wchar_t* format, va_list арг);\nint vwscanf(in wchar_t* format, va_list арг);\nint wprintf(in wchar_t* format, ...);\nint wscanf(in wchar_t* format, ...);\n\nwint_t fgetwc(FILE* stream);\nwint_t fputwc(wchar_t c, FILE* stream);\n\nwchar_t* fgetws(wchar_t* s, int n, FILE* stream);\nint      fputws(in wchar_t* s, FILE* stream);\n\nwint_t ungetwc(wint_t c, FILE* stream);\nint    fwide(FILE* stream, int mode);\n\ndouble  wcstod(in wchar_t* nptr, wchar_t** endptr);\nfloat   wcstof(in wchar_t* nptr, wchar_t** endptr);\nreal    wcstold(in wchar_t* nptr, wchar_t** endptr);\nc_long  wcstol(in wchar_t* nptr, wchar_t** endptr, int base);\nlong    wcstoll(in wchar_t* nptr, wchar_t** endptr, int base);\nc_ulong wcstoul(in wchar_t* nptr, wchar_t** endptr, int base);\nulong   wcstoull(in wchar_t* nptr, wchar_t** endptr, int base);\n\nwchar_t* wcscpy(wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsncpy(wchar_t* s1, in wchar_t* s2, size_t n);\nwchar_t* wcscat(wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsncat(wchar_t* s1, in wchar_t* s2, size_t n);\nint      wcscmp(in wchar_t* s1, in wchar_t* s2);\nint      wcscoll(in wchar_t* s1, in wchar_t* s2);\nint      wcsncmp(in wchar_t* s1, in wchar_t* s2, size_t n);\nsize_t   wcsxfrm(wchar_t* s1, in wchar_t* s2, size_t n);\nwchar_t* wcschr(in wchar_t* s, wchar_t c);\nsize_t   wcscspn(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcspbrk(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsrchr(in wchar_t* s, wchar_t c);\nsize_t   wcsspn(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsstr(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcstok(wchar_t* s1, in wchar_t* s2, wchar_t** ptr);\nsize_t   wcslen(in wchar_t* s);\n\nwchar_t* wmemchr(in wchar_t* s, wchar_t c, size_t n);\nint      wmemcmp(in wchar_t* s1, in wchar_t* s2, size_t n);\nwchar_t* wmemcpy(wchar_t* s1, in wchar_t* s2, size_t n);\nwchar_t* wmemmove(wchar_t*s1, in wchar_t* s2, size_t n);\nwchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);\n\nsize_t wcsftime(wchar_t* s, size_t maxsize, in wchar_t* format, in tm* timeptr);\n\nversion( Windows )\n{\n    wchar_t* _wasctime(tm*);      // non-standard\n    wchar_t* _wctime(time_t*);\t  // non-standard\n    wchar_t* _wstrdate(wchar_t*); // non-standard\n    wchar_t* _wstrtime(wchar_t*); // non-standard\n}\n\nwint_t btowc(int c);\nint    wctob(wint_t c);\nint    mbsinit(in mbstate_t* ps);\nsize_t mbrlen(in char* s, size_t n, mbstate_t* ps);\nsize_t mbrtowc(wchar_t* pwc, in char* s, size_t n, mbstate_t* ps);\nsize_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);\nsize_t mbsrtowcs(wchar_t* dst, in char** src, size_t len, mbstate_t* ps);\nsize_t wcsrtombs(char* dst, in wchar_t** src, size_t len, mbstate_t* ps);\n\nsigfn_t signal(int sig, sigfn_t func);\nint     raise(int sig);\n\n}\n\t\nconst int     _NFILE     = 60;\nextern (C) struct _iobuf\n{\nalign (1):\nexport:\n        char* _ptr;\n        int   _cnt;\n        char* _base;\n        int   _flag;\n        int   _file;\n        int   _charbuf;\n        int   _bufsiz;\n        int   __tmpnum;\n   \n        alias _ptr Ук ;\n        alias   _cnt Конт;\n        alias _base Ова ;\n        alias   _flag Флаг ;\n        alias   _file Файл ;\n        alias   _charbuf Симбуф;\n        alias  _bufsiz  Буфразм ;\n        alias  __tmpnum  Времчло ;\n\t\n}\nalias _iobuf ФАЙЛ, FILE;\nalias ФАЙЛ *фук;\nextern (C) extern ФАЙЛ[_NFILE] _iob;\n\nconst фук стдвхо = &_iob[0];\nconst фук стдвых = &_iob[1];\nconst фук стдош = &_iob[2];\nconst фук стддоп = &_iob[3];\nconst фук стдпрн = &_iob[4];\n\n\talias стдвхо stdin;\n\talias стдвых stdout;\n\talias стдош stderr;\n\talias стддоп stdaux;\n\talias стдпрн stdprn;\n\t\nexport extern (C) фук дайСтдвхо(){return стдвхо;}\nexport extern (C) фук дайСтдвых(){return стдвых;}\nexport extern (C) фук дайСтдош(){return стдош;}\nexport extern (C) фук дайСтддоп(){return стддоп;}\nexport extern (C) фук дайСтдпрн(){return стдпрн;}\n\n extern (C) extern ubyte __fhnd_info[_NFILE];\t\n \n    enum\n    {\n\tFHND_APPEND\t= 0x04,\n\tFHND_DEVICE\t= 0x08,\n\tFHND_TEXT\t= 0x10,\n\tFHND_BYTE\t= 0x20,\n\tFHND_WCHAR\t= 0x40,\n    }\n\t\n    enum\n    {\n        _IOFBF   = 0,\n        _IOLBF   = 0x40,\n\t\t_IONBF   = 4,\n        _IOREAD  = 1,\t  // non-standard\n        _IOWRT   = 2,\t  // non-standard\n        _IOMYBUF = 8,\t  // non-standard\t\n        _IOEOF   = 0x10,  // non-standard\n        _IOERR   = 0x20,  // non-standard\n        _IOSTRG  = 0x40,  // non-standard\n        _IORW    = 0x80,  // non-standard\n        _IOTRAN  = 0x100, // non-standard\n        _IOAPP   = 0x200, // non-standard\n    }\nalias дол т_максцел;\nalias бдол т_максбцел;\n\n/* export extern (D)\n{\n    цел getсим()                 { return getc(stdin);     }\n    цел putсим(цел c)            { return putc(c,stdout);  }\n    цел getc(фук stream)        { return fgetc(stream);   }\n    цел putc(цел c, фук stream) { return fputc(c,stream); }\n}\n\nextern  (D)\n{\n    wint_t getwchar()                     { return fgetwc(stdin);     }\n    wint_t putwchar(wchar_t c)            { return fputwc(c,stdout);  }\n    wint_t getwc(фук stream)            { return fgetwc(stream);    }\n    wint_t putwc(wchar_t c, фук stream) { return fputwc(c, stream); }\n}\n\n\n*/\n\nexport extern (D)\n{\n\n\n\t//цел fpclassify(реал-floating x);\n    цел птклассифицируй(плав x)     { return __fpclassify_f(x); }\n    цел птклассифицируй(дво x)    { return __fpclassify_d(x); }\n    цел птклассифицируй(реал x)\n    {\n        return (реал.sizeof == дво.sizeof)\n            ? __fpclassify_d(x)\n            : __fpclassify_ld(x);\n    }\n\n    //цел isfinite(реал-floating x);\n    цел конечен_ли(плав x)       { return птклассифицируй(x) >= FP_NORMAL; }\n    цел конечен_ли(дво x)      { return птклассифицируй(x) >= FP_NORMAL; }\n    цел конечен_ли(реал x)        { return птклассифицируй(x) >= FP_NORMAL; }\n\n    //цел isinf(реал-floating x);\n    цел беск_ли(плав x)          { return птклассифицируй(x) == FP_INFINITE; }\n    цел беск_ли(дво x)         { return птклассифицируй(x) == FP_INFINITE; }\n    цел беск_ли(реал x)           { return птклассифицируй(x) == FP_INFINITE; }\n\n    //цел isnan(реал-floating x);\n    цел нечисло_ли(плав x)          { return птклассифицируй(x) <= FP_NANQ;   }\n    цел нечисло_ли(дво x)         { return птклассифицируй(x) <= FP_NANQ;   }\n    цел нечисло_ли(реал x)           { return птклассифицируй(x) <= FP_NANQ;   }\n\n    //цел isnormal(реал-floating x);\n    цел нормаль_ли(плав x)       { return птклассифицируй(x) == FP_NORMAL; }\n    цел нормаль_ли(дво x)      { return птклассифицируй(x) == FP_NORMAL; }\n    цел нормаль_ли(реал x)        { return птклассифицируй(x) == FP_NORMAL; }\n\n    //цел signbit(реал-floating x);\n    цел знакбит(плав x)     { return (cast(крат*)&(x))[1] & 0x8000; }\n    цел знакбит(дво x)    { return (cast(крат*)&(x))[3] & 0x8000; }\n    цел знакбит(реал x)\n    {\n        return (реал.sizeof == дво.sizeof)\n            ? (cast(крат*)&(x))[3] & 0x8000\n            : (cast(крат*)&(x))[4] & 0x8000;\n    }\n\t  //цел isgreater(реал-floating x, реал-floating y);\n    цел больше_ли(плав x, плав y)        { return !(x !>  y); }\n    цел больше_ли(дво x, дво y)      { return !(x !>  y); }\n    цел больше_ли(реал x, реал y)          { return !(x !>  y); }\n\n    //цел большеравны_ли(реал-floating x, реал-floating y);\n    цел большеравен_ли(плав x, плав y)   { return !(x !>= y); }\n    цел большеравен_ли(дво x, дво y) { return !(x !>= y); }\n    цел большеравен_ли(реал x, реал y)     { return !(x !>= y); }\n\n    //цел isless(реал-floating x, реал-floating y);\n    цел меньше_ли(плав x, плав y)           { return !(x !<  y); }\n    цел меньше_ли(дво x, дво y)         { return !(x !<  y); }\n    цел меньше_ли(реал x, реал y)             { return !(x !<  y); }\n\n    //цел меньше_ли(реал-floating x, реал-floating y);\n    цел меньшеравен_ли(плав x, плав y)      { return !(x !<= y); }\n    цел меньшеравен_ли(дво x, дво y)    { return !(x !<= y); }\n    цел меньшеравен_ли(реал x, реал y)        { return !(x !<= y); }\n\n    //цел меньше_лиgreater(реал-floating x, реал-floating y);\n    цел меньшебольше_ли(плав x, плав y)    { return !(x !<> y); }\n    цел меньшебольше_ли(дво x, дво y)  { return !(x !<> y); }\n    цел меньшебольше_ли(реал x, реал y)      { return !(x !<> y); }\n\n    //цел isunordered(реал-floating x, реал-floating y);\n    цел беспорядочны_ли(плав x, плав y)      { return (x !<>= y); }\n    цел беспорядочны_ли(дво x, дво y)    { return (x !<>= y); }\n    цел беспорядочны_ли(реал x, реал y)        { return (x !<>= y); }\n\t  дво  акос(дво x){return acos(x);}\n    плав   акосп(плав x){return acosf(x);}\n    реал    акосд(реал x){return acosl(x);}\n\n    дво  асин(дво x){return asin(x);}\n    плав   асинп(плав x){return asinf(x);}\n    реал    асинд(реал x){return asinl(x);}\n\n    дво  атан(дво x){return atan(x);}\n    плав   атанп(плав x){return atanf(x);}\n    реал    атанд(реал x){return atanl(x);}\n\n    дво  атан2(дво y, дво x){return atan2(y, x);}\n    плав   атан2п(плав y, плав x){return atan2f(y, x);}\n    реал    атан2д(реал y, реал x){return atan2l(y, x);}\n\n    дво  кос(дво x){return cos(x);}\n    плав   косп(плав x){return cosf(x);}\n    реал    косд(реал x){return cosl(x);}\n\n    дво  син(дво x){return sin(x);}\n    плав   синп(плав x){return sinf(x);}\n    реал    синд(реал x){return sinl(x);}\n\n    дво  тан(дво x){return tan(x);}\n    плав   танп(плав x){return tanf(x);}\n    реал    танд(реал x){return tanl(x);}\n\n    дво  акосг(дво x){return acosh(x);}\n    плав   акосгп(плав x){return acoshf(x);}\n    реал    акосгд(реал x){return acoshl(x);}\n\n    дво  асинг(дво x){return asinh(x);}\n    плав   асингп(плав x){return asinhf(x);}\n    реал    асингд(реал x){return asinhl(x);}\n\n    дво  атанг(дво x){return atanh(x);}\n    плав   атангп(плав x){return atanhf(x);}\n    реал    атангд(реал x){return atanhl(x);}\n\n    дво  косг(дво x){return cosh(x);}\n    плав   косгп(плав x){return coshf(x);}\n    реал    косгд(реал x){return coshl(x);}\n\n    дво  синг(дво x){return sinh(x);}\n    плав   сингп(плав x){return sinhf(x);}\n    реал    сингд(реал x){return sinhl(x);}\n\n    дво  танг(дво x){return tanh(x);}\n    плав   тангп(плав x){return tanhf(x);}\n    реал    тангд(реал x){return tanhl(x);}\n\n    дво  эксп(дво x){return exp(x);}\n    плав   экспп(плав x){return expf(x);}\n    реал    экспд(реал x){return expl(x);}\n\n    дво  эксп2(дво x){return exp2(x);}\n    плав   эксп2п(плав x){return exp2f(x);}\n    реал    эксп2д(реал x){return exp2l(x);}\n\n    дво  экспм1(дво x){return expm1(x);}\n    плав  экспм1п(плав x){return expm1f(x);}\n    реал    экспм1д(реал x){return expm1l(x);}\n\n    дво  фрэксп(дво value, цел* exp){return frexp(value, exp);}//\n    плав   фрэкспп(плав value, цел* exp){return frexpf(value, exp);}//\n    реал   фрэкспд(реал value, цел* exp){return frexpl(value, exp);}//!!!!!!!!!!!!!!!!!!\n\n    цел     илогб(дво x){return ilogb(x);}\n    цел     илогбп(плав x){return ilogbf(x);}\n    цел     илогбд(реал x){return ilogbl(x);}\n/*\n    дво  ldexp(дво x, цел exp){return ldexp(x, exp);}\n    плав   ldexpf(плав x, цел exp){return ldexpf(x, exp);}\n    реал    ldexpl(реал x, цел exp){return ldexpl(x, exp);}\n*/\n    дво  лог(дво x){return log(x);}\n    плав   логп(плав x){return logf(x);}\n    реал    логд(реал x){return logl(x);}\n\n    дво  лог10(дво x){return log10(x);}\n    плав   лог10п(плав x){return log10f(x);}\n    реал    лог10д(реал x){return log10l(x);}\n\n    дво  лог1п(дво x){return log1p(x);}\n    плав   лог1пп(плав x){return log1pf(x);}\n    реал    лог1пд(реал x){return log1pl(x);}\n\n    дво  лог2(дво x){return log2(x);}\n    плав   лог2п(плав x){return log2f(x);}\n    реал    лог2д(реал x){return log2l(x);}\n\n    дво  логб(дво x){return logb(x);}\n    плав   логбп(плав x){return logbf(x);}\n    реал    логбд(реал x){return logbl(x);}\n\n    дво  модф(дво значение, дво* цук){return modf(значение, цук);}\n    плав   модфп(плав значение, плав* цук){return modff(значение, цук);}\n    реал    модфд(реал значение, реал *цук){return modfl(значение, цук);}\n/*\n    дво  scalbn(дво x, цел n){return scalbn(x, n);}\n    плав   scalbnf(плав x, цел n){return scalbnf(x, n);}\n    реал    scalbnl(реал x, цел n){return scalbnl(x, n);}\n\n    дво  scalbln(дво x, c_long n){return scalbln(x, n);}\n    плав   scalblnf(плав x, c_long n){return scalblnf(x, n);}\n    реал    scalblnl(реал x, c_long n){return scalblnl(x, n);}\n*/\n    дво  кубкор(дво x){return cbrt(x);}\n    плав   кубкорп(плав x){return cbrtf(x);}\n    реал    кубкорд(реал x){return cbrtl(x);}\n\n    дво  фабс(дво x){return fabs(x);}\n    плав   фабсп(плав x){return fabsf(x);}\n    реал    фабсд(реал x){return fabsl(x);}\n\n    дво  гипот(дво x, дво y){return hypot(x, y);}\n    плав   гипотп(плав x, плав y){return hypotf(x, y);}\n    реал    гипотд(реал x, реал y){return hypotl(x, y);}\n\n    дво  степ(дво x, дво y){return pow(x, y);}\n    плав   степп(плав x, плав y){return powf(x, y);}\n    реал    степд(реал x, реал y){return powl(x, y);}\n\n    дво  квкор(дво x){return sqrt(x);}\n    плав   квкорп(плав x){return sqrtf(x);}\n    реал    квкорд(реал x){return sqrtl(x);}\n\n    дво  фцош(дво x){return erf(x);}\n    плав   фцошп(плав x){return erff(x);}\n    реал    фцошд(реал x){return erfl(x);}\n\n    дво  фцошк(дво x){return erfc(x);}\n    плав   фцошкп(плав x){return erfcf(x);}\n    реал    фцошкд(реал x){return erfcl(x);}\n\n    дво  лгамма(дво x){return lgamma(x);}\n    плав   лгаммап(плав x){return lgammaf(x);}\n    реал    лгаммад(реал x){return lgammal(x);}\n\n    дво  тгамма(дво x){return tgamma(x);}\n    плав   тгаммап(плав x){return tgammaf(x);}\n    реал   тгаммад(реал x){return tgammal(x);}\n\n    дво  вокругли(дво x){return ceil(x);}\n    плав   вокруглип(плав x){return ceilf(x);}\n    реал    вокруглид(реал x){return ceill(x);}\n\n    дво  нокругли(дво x){return floor(x);}\n    плав   нокруглип(плав x){return floorf(x);}\n    реал    нокруглид(реал x){return floorl(x);}\n\n    дво  ближцел(дво x){return nearbyint(x);}\n    плав   ближцелп(плав x){return nearbyintf(x);}\n    реал    ближцелд(реал x){return nearbyintl(x);}\n\n    дво  ринт(дво x){return rint(x);}//\n    плав   ринтп(плав x){return rintf(x);}//\n    реал    ринтд(реал x){return rintl(x);}//\n/*\n    c_long  lrint(дво x){return lrint(x);}\n    c_long  lrintf(плав x){return lrintf(x);}\n    c_long  lrintl(реал x){return lrintl(x);}\n\n    дол    llrint(дво x){return llrint(x);}\n    дол    llrintf(плав x){return llrintf(x);}\n    дол    llrintl(реал x){return llrintl(x);}\n*/\n    дво  округли(дво x){return round(x);}\n    плав   округлип(плав x){return roundf(x);}\n    реал    округлид(реал x){return roundl(x);}\n/*\n    c_long  lround(дво x){return lround(x);}\n    c_long  lroundf(плав x){return lroundf(x);}\n    c_long  lroundl(реал x){return lroundl(x);}\n\n    дол    llround(дво x){return llround(x);}\n    дол    llroundf(плав x){return llroundf(x);}\n    дол    llroundl(реал x){return llroundl(x);}\n\n    дво  trunc(дво x){return trunc(x);}\n    плав   truncf(плав x){return truncf(x);}\n    реал    truncl(реал x){return truncl(x);}\n\n    дво  fmod(дво x, дво y){return fmod(x, y);}\n    плав   fmodf(плав x, плав y){return fmodf(x, y);}\n    реал    fmodl(реал x, реал y){return fmodl(x, y);}\n*/\n    дво  остаток(дво x, дво y){return remainder(x, y);}\n    плав   остатокп(плав x, плав y){return remainderf(x, y);}\n    реал    остатокд(реал x, реал y){return remainderl(x, y);}\n/*\n    дво  remquo(дво x, дво y, цел* quo){return remquo(x, y, quo);}\n    плав   remquof(плав x, плав y, цел* quo){return remquof(x, y, quo);}\n    реал    remquol(реал x, реал y, цел* quo){return remquol(x, y, quo);}\n*/\n    дво  копируйзнак(дво x, дво y){return copysign(x, y);}\n    плав   копируйзнакп(плав x, плав y){return copysignf(x, y);}\n    реал    копируйзнакд(реал x, реал y){return copysignl(x, y);}\n\n    дво  нечисло(ткст tangp){return nan(вТкст0(tangp));}\n    плав   нечислоп(ткст tangp){return nanf(вТкст0(tangp));}\n    реал    нечислод(ткст tangp){return nanl(вТкст0(tangp));}\n\n    дво  следза(дво x, дво y){return nextafter(x, y);}\n    плав   следзап(плав x, плав y){return nextafterf(x, y);}\n    //реал    следзад(реал x, реал y){return nextafterl(x, y);}\n\n    //дво  следк(дво x, реал y){return nexttoward(x, y);}\n    //плав   следкп(плав x, реал y){return nexttowardf(x, y);}\n    //реал    следкд(реал x, реал y){return nexttowardl(x, y);}\n/*\n    дво  fdim(дво x, дво y){return fdim(x, y);}\n    плав   fdimf(плав x, плав y){return fdimf(x, y);}\n    реал    fdiml(реал x, реал y){return fdiml(x, y);}\n\n    дво  fmax(дво x, дво y){return fmax(x, y);}\n    плав   fmaxf(плав x, плав y){return fmaxf(x, y);}\n    реал    fmaxl(реал x, реал y){return fmaxl(x, y);}\n\n    дво  fmin(дво x, дво y){return fmin(x, y);}\n    плав   fminf(плав x, плав y){return fminf(x, y);}\n    реал    fminl(реал x, реал y){return fminl(x, y);}\n\n    дво  fma(дво x, дво y, дво z){return fma(x, y, z);}\n    плав   fmaf(плав x, плав y, плав z){return fmaf(x, y, z);}\n    реал    fmal(реал x, реал y, реал z){return fmal(x, y, z);}*/\n\t\n\n}\n\nexport extern (D)\n  {\n    проц перемотай(фук поток)   { fseek(cast(FILE*) поток,0L,SEEK_SET); поток.Флаг&=~_IOERR; }\n    проц сбросьош(фук поток) { поток.Флаг &= ~(_IOERR|_IOEOF);                 }\n    цел  конфл(фук поток)     { return поток.Флаг&_IOEOF;                       }\n    цел  ошфл(фук поток)   { return поток.Флаг&_IOERR;                       }\n  }\n//////////////////\nexport extern  (C):\n\nstruct лпреобр\n{\nexport:\n    ткст десятичная_точка;\n    ткст делит_тысяч;\n    ткст группировка;\n    ткст цел_валютн_символ;\n    ткст символ_валюты;\n    ткст мон_десятичная_точка;\n    ткст мон_делит_тыс;\n    ткст мон_группировка;\n    ткст положит_знак;\n    ткст отрицат_знак;\n    байт  цел_дробн_цифры;\n    байт  дробн_цифры;\n    байт  p_cs_precedes;\n    байт  p_sep_by_space;\n    байт  n_cs_precedes;\n    байт  n_sep_by_space;\n    байт  p_sign_posn;\n    байт  n_sign_posn;\n    байт  цел_p_cs_precedes;\n    байт  цел_p_sep_by_space;\n    байт  цел_n_cs_precedes;\n    байт  цел_n_sep_by_space;\n    байт  цел_p_sign_posn;\n    байт  цел_n_sign_posn;\n}\n\nstruct т_цмаксдел\n\t{\n\texport:\n\t\tдол    квот,\n\t\t\t\t\tрем;\n\t}\n\nstruct т_фсред\n    {\n\texport:\n        бкрат    статус;\n        бкрат    контроль;\n        бкрат    округл;\n        бкрат[2] резерв;\n    }\n\t\nstruct т_дели\n\t{\n\texport:\n\t\tцел квот,\n\t\t\tрем;\n\t}\n\n\nstruct т_делиц\n\t{\n\texport:\n\t\tцел квот,\n\t\t\tрем;\n\t}\n\nstruct т_делид\n\t{\n\texport:\n\t\tдол квот,\n\t\t\t рем;\n\t}\n\t\n\t\nцел удали(in ткст фимя){return remove(вТкст0(фимя));}\nцел переименуй(in ткст из, in ткст в){return rename(вТкст0(из), вТкст0(в));}\n\nфук времфл(){return cast(FILE*) tmpfile();}\nткст времим(ткст s){return вТкст(tmpnam(вТкст0(s)));}\n\nцел   закройфл(фук поток){return fclose(cast(FILE*)поток);}\nцел   слейфл(фук поток){return fflush(cast(FILE*)поток);}\nфук откройфл(in ткст фимя, in ткст режим){return cast(FILE*) fopen(вТкст0(фимя), вТкст0(режим));}\nфук переоткройфл(in ткст фимя, in ткст режим, фук поток){return cast(FILE*) freopen(вТкст0(фимя), вТкст0(режим),  cast(FILE*) поток);}\n\nпроц устбуффл(фук поток, ткст буф){return setbuf(cast(FILE*)поток, вТкст0(буф));}\nцел  уствбуф(фук поток, ткст буф, цел режим, т_мера размер){return setvbuf(cast(FILE*)поток, вТкст0(буф), режим, размер);}\n\nцел вфвыводф(фук поток, in ткст формат, спис_ва арг){return vfprintf(cast(FILE*)поток, вТкст0(формат), арг);}\nцел вфсканф(фук поток, in ткст формат, спис_ва арг){return vfscanf(cast(FILE*)поток, вТкст0(формат), арг);}\nцел всвыводф(ткст s, in ткст формат, спис_ва арг){return vsprintf(вТкст0(s), вТкст0(формат), арг);}\nцел вссканф(in ткст s, in ткст формат, спис_ва арг){return vsscanf(вТкст0(s), вТкст0(формат), арг);}\nцел ввыводф(in ткст формат, спис_ва арг){return vprintf(вТкст0(формат), арг);}\nцел всканф(in ткст формат, спис_ва арг){return vscanf(вТкст0(формат), арг);}\nцел берисфл(фук поток){return fgetc(cast(FILE*)поток);}\nцел вставьсфл(цел c, фук поток){return fputc(c, cast(FILE*)поток);}\n\nткст дайтфл(ткст s, цел n, фук поток){return вТкст(fgets(вТкст0(s), n, cast(FILE*)поток));}\nцел   вставьтфл(in ткст s, фук поток){return fputs(вТкст0(s), cast(FILE*)поток);}\nткст дайт(ткст s){return вТкст(gets(вТкст0(s)));}\nцел   вставьт(in ткст s){return puts(вТкст0(s));}\n\nцел отдайс(цел c, фук поток){return ungetc(c, cast(FILE*)поток);}\n\nт_мера читайфл(ук указат, т_мера размер, т_мера nmemb, фук поток){return fread(адаптВхоУкз(указат), размер, nmemb, cast(FILE*)поток);}\nт_мера пишифл(in ук указат, т_мера размер, т_мера nmemb, фук поток){return fwrite(адаптВхоУкз(указат), размер, nmemb, cast(FILE*)поток);}\n\nцел дайпозфл(фук поток, цел* поз){return fgetpos(cast(FILE*)поток, cast(fpos_t*) поз);}\nцел устпозфл(фук поток, in цел* поз){return fsetpos(cast(FILE*)поток, cast(fpos_t*) поз);}\n\nцел    сместисьфл(фук поток, цел смещение, цел куда){return fseek(cast(FILE*)поток, cast(c_long) смещение, куда);}\nцел скажифл(фук поток){return cast(цел) ftell(cast(FILE*)поток);}\n\nцел   вснвыводф(ткст s, т_мера n, in ткст формат, спис_ва арг){return _vsnprintf(вТкст0(s), n, вТкст0(формат), арг);}\n\nпроц укошиб(in ткст s){return perror(вТкст0(s));}\n\n//////////////////////////////////////////\n\nт_сигфн сигнал(цел сиг, т_сигфн функ){return cast(т_сигфн) signal(сиг, cast(sigfn_t) функ);}\nцел     влеки(цел сиг){return raise(сиг);}\n\nкдво какос(кдво z){return cacos(z);}\nкплав  какосп(кплав z){return cacosf(z);}\nкреал   какосд(креал z){return cacosl(z);}\n\nкдво касин(кдво z){return casin(z);}\nкплав  касинп(кплав z){return casinf(z);}\nкреал   касинд(креал z){return casinl(z);}\n\nкдво катан(кдво z){return catan(z);}\nкплав  катанп(кплав z){return catanf(z);}\nкреал   катанд(креал z){return catanl(z);}\n\nкдво ккос(кдво z){return ccos(z);}\nкплав  ккосп(кплав z){return ccosf(z);}\nкреал   ккосд(креал z){return ccosl(z);}\n\nкдво ксин(кдво z){return csin(z);}\nкплав  ксинп(кплав z){return csinf(z);}\nкреал   ксинд(креал z){return csinl(z);}\n\nкдво ктан(кдво z){return ctan(z);}\nкплав  ктанп(кплав z){return ctanf(z);}\nкреал   ктанд(креал z){return ctanl(z);}\n\nкдво какосг(кдво z){return cacosh(z);}\nкплав  какосгп(кплав z){return cacoshf(z);}\nкреал   какосгд(креал z){return cacoshl(z);}\n\nкдво касинг(кдво z){return casinh(z);}\nкплав  касингп(кплав z){return casinhf(z);}\nкреал   касингд(креал z){return casinhl(z);}\n\nкдво катанг(кдво z){return catanh(z);}\nкплав  катангп(кплав z){return catanhf(z);}\nкреал   катангд(креал z){return catanhl(z);}\n\nкдво ккосг(кдво z){return ccosh(z);}\nкплав  ккосгп(кплав z){return ccoshf(z);}\nкреал   ккосгд(креал z){return ccoshl(z);}\n\nкдво ксинг(кдво z){return csinh(z);}\nкплав  ксингп(кплав z){return csinhf(z);}\nкреал   ксингд(креал z){return csinhl(z);}\n\nкдво ктанг(кдво z){return ctanh(z);}\nкплав  ктангп(кплав z){return ctanhf(z);}\nкреал   ктангд(креал z){return ctanhl(z);}\n\nкдво кэксп(кдво z){return cexp(z);}\nкплав  кэкспп(кплав z){return cexpf(z);}\nкреал   кэкспд(креал z){return cexpl(z);}\n\nкдво клог(кдво z){return clog(z);}\nкплав  клогп(кплав z){return clogf(z);}\nкреал   клогд(креал z){return clogl(z);}\n\nдво кабс(кдво z){return cabs(z);}\nплав  кабсп(кплав z){return cabsf(z);}\nреал  кабсд(креал z){return cabsl(z);}\n\nкдво кстеп(кдво x, кдво y){return cpow(x, y);}\nкплав  кстепп(кплав x, кплав y){return cpowf(x, y);}\nкреал   кстепд(креал x, креал y){return cpowl(x, y);}\n\nкдво кквкор(кдво z){return csqrt(z);}\nкплав  кквкорп(кплав z){return csqrtf(z);}\nкреал   кквкорд(креал z){return csqrtl(z);}\n\n дво карг(кдво z){return carg(z);}\n плав  каргп(кплав z){return cargf(z);}\n реал  каргд(креал z){return cargl(z);}\n\n// дво квообр(кдво z){return cimag(z);}\n //плав  квообрп(кплав z){return cimagf(z);}\n //реал  квообрд(креал z){return cimagl(z);}\n\n//кдво конъюнк(кдво z){return conj(z);}\n//кплав  конъюнкп(кплав z){return conjf(z);}\n//креал   конъюнкд(креал z){return conjl(z);}\n\nкдво кпроекц(кдво z){return cproj(z);}\nкплав  кпроекцп(кплав z){return cprojf(z);}\nкреал   кпроекцд(креал z){return cprojl(z);}\n\n //дво креал(кдво z){return creal(z);}\n //плав  креалп(кплав z){return crealf(z);}\n //реал  креалд(креал z){return creall(z);}\n \n \nцел числобукв_ли(цел c){return isalnum(c);}\nцел буква_ли(цел c){return isalpha(c);}\nцел пробел_ли(цел c){return isblank(c);}\nцел управ_ли(цел c){return iscntrl(c);}\nцел цифра_ли(цел c){return isdigit(c);}\nцел граф_ли(цел c){return isgraph(c);}\nцел проп_ли(цел c){return islower(c);}\nцел печат_ли(цел c){return isprint(c);}\nцел пункт_ли(цел c){return ispunct(c);}\nцел межбукв_ли(цел c){return isspace(c);}\nцел заг_ли(цел c){return isupper(c);}\nцел цифраикс_ли(цел c){return isxdigit(c);}\nцел впроп(цел c){return tolower(c);}\nцел взаг(цел c){return toupper(c);}\n\nцел числобуквш_ли(шим c){return iswalnum(cast(wchar_t) c);}\nцел букваш_ли(шим c){return iswalpha(cast(wchar_t) c);}\n//цел пробелш_ли(шим c){return iswblank(cast(wchar_t) c);}\nцел управш_ли(шим c){return iswcntrl(cast(wchar_t) c);}\nцел цифраш_ли(шим c){return iswdigit(cast(wchar_t) c);}\nцел графш_ли(шим c){return iswgraph(cast(wchar_t) c);}\nцел пропш_ли(шим c){return iswlower(cast(wchar_t) c);}\nцел печатш_ли(шим c){return iswprint(cast(wchar_t) c);}\nцел пунктш_ли(шим c){return iswpunct(cast(wchar_t) c);}\nцел межбуквш_ли(шим c){return iswspace(cast(wchar_t) c);}\nцел загш_ли(шим c){return iswupper(cast(wchar_t) c);}\nцел цифраиксш_ли(шим c){return iswxdigit(cast(wchar_t) c);}\nцел впропш(шим c){return towlower(cast(wchar_t) c);}\nцел взагш(шим c){return towupper(cast(wchar_t) c);}\n//шим    втрансш(шим ш, шим опис){return cast(шим) towctrans(cast(wchar_t) ш, cast(wctrans_t) опис);}\n//шим трансш( in ткст0 свойство){return cast(шим) wctrans(свойство);}\n\n\nцел дайНомош(){return getErrno();}      \nцел устНомош(цел n){return setErrno(n);}   \n\nпроц влекиисклфе(цел исклы){feraiseexcept(исклы);}\nпроц сотриисклфе(цел исклы){feclearexcept(исклы);}\n\nцел тестисклфе(цел исклы){return fetestexcept(исклы);}\nцел задержиисклфе(т_фсред* средп){return feholdexcept(cast(fenv_t*) средп);}\n\nпроц дайфлагисклфе(цел* флагп, цел исклы){return fegetexceptflag(cast(fexcept_t*) флагп, исклы);}\nпроц устфлагисклфе(in цел* флагп, цел исклы){return fesetexceptflag(cast(fexcept_t*)флагп, исклы);}\n\nцел дайкругфе(){return fegetround();}\nцел усткругфе(цел круг){return fesetround(круг);}\n\nпроц дайсредфе(т_фсред* средп){fegetenv(cast(fenv_t*)средп);}\nпроц устсредфе(in т_фсред* средп){fesetenv(cast(fenv_t*) средп);}\nпроц обновисредфе(in т_фсред* средп){feupdateenv(cast(fenv_t*) средп);}\n\nдол  цмаксабс(дол j){ return cast(дол) imaxabs(cast(intmax_t)j);}\nт_цмаксдел цмаксдел(дол число, дол делитель){return cast(т_цмаксдел) imaxdiv(число, делитель);}\nдол  ткствмаксц(in ткст чук, ткст* конук, цел основа){return cast(дол) strtoimax(вТкст0(чук), cast(char**) конук, основа);}\nбдол ткствбмакс(in ткст чук, ткст* конук, цел основа){return cast(бдол) strtoumax(вТкст0(чук), cast(char**)конук, основа);}\nдол  шимвцмакс(in шткст чук, шткст* конук, int основа){return cast(дол) wcstoimax(cast(wchar_t*) чук, cast(wchar_t**) конук, основа);}\nбдол шимвбмакс(in шткст чук, шткст* конук, int основа){return cast(бдол) wcstoumax(cast(wchar_t*) чук, cast(wchar_t**) конук, основа);}\n\nткст  устлокаль(int категория, in ткст локаль)\t{return вТкст(setlocale(категория, вТкст0(локаль)));}\t\nлпреобр* преобрлокаль(){return cast(лпреобр*) localeconv();}\n\n    бцел __птклассифицируй_п(плав x){return __fpclassify_f(x);}\n    бцел __птклассифицируй_д(дво x){return __fpclassify_d(x);}\n    бцел __птклассифицируй_дд(реал x){return __fpclassify_ld(x);}\n\n\n//проц exit(цел);\nпроц _си_выход(){_c_exit();}\nпроц _сивыход(){_cexit();}\nпроц _выход(цел x){_exit(x);}\nпроц _аборт(){abort();}\nпроц _деструкт(){_dodtors();}\nцел дайпид(){return getpid();}\n/*\n//цел system(сим *){rt.core.stdc.process\n\nenum { П_ЖДИ = _P_WAIT, П_НЕЖДИ = _P_NOWAIT, П_ПОВЕРХ = _P_OVERLAY }\n\nцел execl(сим *, сим *,...){rt.core.stdc.process\nцел execle(сим *, сим *,...){rt.core.stdc.process\nцел execlp(сим *, сим *,...){rt.core.stdc.process\nцел execlpe(сим *, сим *,...){rt.core.stdc.process\nцел execv(сим *, сим **){rt.core.stdc.process\nцел execve(сим *, сим **, сим **){rt.core.stdc.process\nцел execvp(сим *, сим **){rt.core.stdc.process\nцел execvpe(сим *, сим **, сим **){rt.core.stdc.process\n\n\nenum { WAIT_CHILD, WAIT_GRANDCHILD }\n\nцел cwait(цел *,цел,цел){rt.core.stdc.process\nцел жди(цел *){rt.core.stdc.process\n\nversion (Windows)\n{\n    бцел начни_нить(проц function(ук ),бцел,ук ){rt.core.stdc.process\n\n    extern  (Windows) alias бцел (*stdfp)(ук ){rt.core.stdc.process\n\n    бцел начни_нить_доп(ук security, бцел stack_size,\n\t    stdfp start_addr, ук arglist, бцел initflag,\n\t    бцел* thrdaddr){rt.core.stdc.process\n\n    проц стоп_нить(){rt.core.stdc.process\n    проц стоп_нить_доп(бцел){rt.core.stdc.process\n\n    цел spawnl(цел, сим *, сим *,...){rt.core.stdc.process\n    цел spawnle(цел, сим *, сим *,...){rt.core.stdc.process\n    цел spawnlp(цел, сим *, сим *,...){rt.core.stdc.process\n    цел spawnlpe(цел, сим *, сим *,...){rt.core.stdc.process\n    цел spawnv(цел, сим *, сим **){rt.core.stdc.process\n    цел spawnve(цел, сим *, сим **, сим **){rt.core.stdc.process\n    цел spawnvp(цел, сим *, сим **){rt.core.stdc.process\n    цел spawnvpe(цел, сим *, сим **, сим **){rt.core.stdc.process\n\n\n    цел _wsystem(wchar_t *){rt.core.stdc.process\n    цел _wspawnl(цел, wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wspawnle(цел, wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wspawnlp(цел, wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wspawnlpe(цел, wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wspawnv(цел, wchar_t *, wchar_t **){rt.core.stdc.process\n    цел _wspawnve(цел, wchar_t *, wchar_t **, wchar_t **){rt.core.stdc.process\n    цел _wspawnvp(цел, wchar_t *, wchar_t **){rt.core.stdc.process\n    цел _wspawnvpe(цел, wchar_t *, wchar_t **, wchar_t **){rt.core.stdc.process\n\n    цел _wexecl(wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wexecle(wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wexeclp(wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wexeclpe(wchar_t *, wchar_t *, ...){rt.core.stdc.process\n    цел _wexecv(wchar_t *, wchar_t **){rt.core.stdc.process\n    цел _wexecve(wchar_t *, wchar_t **, wchar_t **){rt.core.stdc.process\n    цел _wexecvp(wchar_t *, wchar_t **){rt.core.stdc.process\n    цел _wexecvpe(wchar_t *, wchar_t **, wchar_t **){rt.core.stdc.process\n}\n*/\n\n\n//stdlib\n\n\nдво  алфнапз(in ткст укнач){return atof(вТкст0(укнач));}\nцел     алфнац(in ткст укнач){return atoi(вТкст0(укнач));}\nцел алфнадл(in ткст укнач){return cast(цел) atol(вТкст0(укнач));}\nдол    алфнадлдл(in ткст укнач){return atoll(вТкст0(укнач));}\n\nдво  стрнад(in ткст укнач, ткст* укнакон){return strtod(вТкст0(укнач), cast(char**) укнакон);}\nплав   стрнапз(in ткст укнач, ткст* укнакон){return strtof(вТкст0(укнач), cast(char**) укнакон);}\nреал    стрнадлд(in ткст укнач, ткст* укнакон){return strtold(вТкст0(укнач), cast(char**) укнакон);}\nцел  стрнадл(in ткст укнач, ткст* укнакон, цел ова){return cast(цел) strtol(вТкст0(укнач), cast(char**) укнакон, ова);}\nдол    стрнадлдл(in ткст укнач, ткст* укнакон, цел ова){return strtoll(вТкст0(укнач), cast(char**)  укнакон, ова);}\nбцел стрнабдл(in ткст укнач, ткст* укнакон, цел ова){return cast(бцел) strtoul(вТкст0(укнач), cast(char**) укнакон, ова);}\nбдол   стрнабдлдл(in ткст укнач, ткст* укнакон, цел ова){return strtoull(вТкст0(укнач), cast(char**) укнакон, ова);}\n\n\nцел     случ(){return rand();}\nпроц    сслуч(бцел семя){srand(семя);}\n\n\nук   празмести(т_мера разм){return адаптВыхУкз(malloc(разм));}\nук   кразмести(т_мера члочленов, т_мера разм){return адаптВыхУкз(calloc(члочленов, разм));}\nук   перемести(ук указ, т_мера разм){return адаптВыхУкз(realloc(указ, разм));}\nпроц    освободи(ук указ){ free(адаптВхоУкз(указ));}\n\n\nпроц    аборт(){abort();}\nпроц    выход(цел статус){ exit(статус);}\nцел     навыходе(проц function() функц){return atexit(функц);}\nпроц    _Выход(цел статус){_Exit(статус);}\n\n\nткст   дайсреду(in ткст имя){return вТкст(getenv(вТкст0(имя)));}\nцел     система(in ткст текст){return system(вТкст0(текст));}\n\n\nук   бпоиск(in ук key, in ук ова, т_мера члочленов, т_мера разм, цел function(in проц*, in проц*) compar){return адаптВыхУкз(bsearch(адаптВхоУкз(key), ова, члочленов, разм, compar));}\nпроц    бсорт(ук ова, т_мера члочленов, т_мера разм, цел function(in проц*, in проц*) compar){ qsort(адаптВхоУкз(ова), члочленов, разм, compar);}\n\n\nцел     абс(цел j){return abs(j);}\nцел  абсц(цел j){return cast(цел) labs(cast(c_long) j);}\nдол    абсд(дол j){return llabs(j);}\n\n\nт_дели   дели(цел число, цел делитель){return cast(т_дели) div(число, делитель);}\nт_делиц  делиц(цел число, цел делитель){return cast(т_делиц) ldiv(cast(c_long) число, cast(c_long) делитель);}\nт_делид делид(дол число, дол делитель){return cast(т_делид) lldiv(число, делитель);}\n\n\n\nцел     мбдлин(in ткст s, т_мера n){return mblen(вТкст0(s), n);}\nцел     мбнашк(шткст pwc, in ткст s, т_мера n){return mbtowc(cast(wchar_t*) pwc, вТкст0(s), n);}\nцел     шкнамб(ткст s, шим wc){return wctomb(вТкст0(s), cast(wchar_t)wc);}\nт_мера  мбтнашкт(шткст pwcs, in ткст s, т_мера n){return mbstowcs(cast(wchar_t*)pwcs, вТкст0(s), n);}\nт_мера  шктнамбт(ткст s, in шткст pwcs, т_мера n){return wcstombs(вТкст0(s), cast(wchar_t*)pwcs, n);}\n\n\n\nversion( DigitalMars )\n{\n    ук разместа(т_мера разм){return адаптВыхУкз(alloca(разм));} // non-standard\n}\n\nцел ширфл(фук поток, цел реж){return fwide( cast(FILE*)поток, реж);}  \n\t\n\tцел поместсфл(цел ц, фук ф){return _fputc_nlock(ц,  cast(FILE*)ф);}\n    цел поместшфл(цел ц, фук ф){return  _fputwc_nlock(ц,  cast(FILE*)ф);}\n    цел извлсфл(фук ф){return _fgetc_nlock( cast(FILE*)ф);}\n    цел извлшфл(фук ф){return _fgetwc_nlock( cast(FILE*)ф);}\n    цел блокфл(фук ф){return  __fp_lock( cast(FILE*)ф);}\n    проц разблокфл(фук ф){__fp_unlock( cast(FILE*)ф);}\n\n/*\nalias цел     mbstate_t;\n//alias wchar_t wцел_t;\n\n//const wchar_t WEOF = 0xFFFF;\n\nцел fwprintf(фук поток, in wchar_t* format, ...);\nцел fwscanf(фук поток, in wchar_t* format, ...);\nцел swprintf(wchar_t* s, т_мера n, in wchar_t* format, ...);\nцел swscanf(in wchar_t* s, in wchar_t* format, ...);\nцел vfwprintf(фук поток, in wchar_t* format, va_list арг);\nцел vfwscanf(фук поток, in wchar_t* format, va_list арг);\nцел vswprintf(wchar_t* s, т_мера n, in wchar_t* format, va_list арг);\nцел vswscanf(in wchar_t* s, in wchar_t* format, va_list арг);\nцел vwprintf(in wchar_t* format, va_list арг);\nцел vwscanf(in wchar_t* format, va_list арг);\nцел wprintf(in wchar_t* format, ...);\nцел wscanf(in wchar_t* format, ...);\n\nwint_t fgetwc(фук поток);\nwint_t fputwc(wchar_t c, фук поток);\n\nwchar_t* fgetws(wchar_t* s, цел n, фук поток);\nцел      fputws(in wchar_t* s, фук поток);\n\nextern  (D)\n{\n    wint_t getwchar()                     { return fgetwc(stdin);     }\n    wint_t putwchar(wchar_t c)            { return fputwc(c,stdout);  }\n    wint_t getwc(фук поток)            { return fgetwc(поток);    }\n    wint_t putwc(wchar_t c, фук поток) { return fputwc(c, поток); }\n}\n\nwint_t ungetwc(wint_t c, фук поток);\nцел    fwide(фук поток, цел mode);\n\ndouble  wcstod(in wchar_t* nptr, wchar_t** endptr);\nfloat   wcstof(in wchar_t* nptr, wchar_t** endptr);\nreal    wcstold(in wchar_t* nptr, wchar_t** endptr);\nc_long  wcstol(in wchar_t* nptr, wchar_t** endptr, цел base);\nдол    wcstoll(in wchar_t* nptr, wchar_t** endptr, цел base);\nc_ulong wcstoul(in wchar_t* nptr, wchar_t** endptr, цел base);\nulong   wcstoull(in wchar_t* nptr, wchar_t** endptr, цел base);\n\nwchar_t* wcscpy(wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsncpy(wchar_t* s1, in wchar_t* s2, т_мера n);\nwchar_t* wcscat(wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsncat(wchar_t* s1, in wchar_t* s2, т_мера n);\nцел      wcscmp(in wchar_t* s1, in wchar_t* s2);\nцел      wcscoll(in wchar_t* s1, in wchar_t* s2);\nцел      wcsncmp(in wchar_t* s1, in wchar_t* s2, т_мера n);\nт_мера   wcsxfrm(wchar_t* s1, in wchar_t* s2, т_мера n);\nwchar_t* wcschr(in wchar_t* s, wchar_t c);\nт_мера   wcscspn(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcspbrk(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsrchr(in wchar_t* s, wchar_t c);\nт_мера   wcsspn(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcsstr(in wchar_t* s1, in wchar_t* s2);\nwchar_t* wcstok(wchar_t* s1, in wchar_t* s2, wchar_t** ptr);\nт_мера   wcslen(in wchar_t* s);\n\nwchar_t* wmemchr(in wchar_t* s, wchar_t c, т_мера n);\nцел      wmemcmp(in wchar_t* s1, in wchar_t* s2, т_мера n);\nwchar_t* wmemcpy(wchar_t* s1, in wchar_t* s2, т_мера n);\nwchar_t* wmemmove(wchar_t*s1, in wchar_t* s2, т_мера n);\nwchar_t* wmemset(wchar_t* s, wchar_t c, т_мера n);\n\nт_мера wcsftime(wchar_t* s, т_мера maxsize, in wchar_t* format, in tm* timeptr);\n\nversion( Windows )\n{\n    wchar_t* _wasctime(tm*);      // non-standard\n    wchar_t* _wctime(time_t*);\t  // non-standard\n    wchar_t* _wstrdate(wchar_t*); // non-standard\n    wchar_t* _wstrtime(wchar_t*); // non-standard\n}\n\nwцел_t btowc(цел c);\nцел    wctob(wint_t c);\nцел    mbsinit(in mbstate_t* ps);\nт_мера mbrlen(in char* s, т_мера n, mbstate_t* ps);\nт_мера mbrtowc(wchar_t* pwc, in char* s, т_мера n, mbstate_t* ps);\nт_мера wcrtomb(char* s, wchar_t wc, mbstate_t* ps);\nт_мера mbsrtowcs(wchar_t* dst, in char** src, т_мера len, mbstate_t* ps);\nт_мера wcsrtombs(char* dst, in wchar_t** src, т_мера len, mbstate_t* ps);\n*/\n\nversion (Windows)\n{\n    \t///////////////////////////\n\t/*\n\t* memicmp /сравнибуфлюб/: Сравнивает символы из двух буферов (без учета региста).\n\t*/\n\tцел сравбуфлюб(ткст0 буф1, ткст0 буф2, т_мера члоб)\n\t{\n\treturn cast(цел) memicmp(буф1, буф2, члоб);\n\t}\n\t\n\talias сравбуфлюб сравни_буферы_люб ;\n}\n\n/////////////////////////////////////////////////////\n/*\n* memchr /ищисим/ ищет первый случай сим в \n* строке, состоящей из члабайт буфера. Она\n* останавливается, когда найдёт сим, либо\n* проверив первое члобайт.\n*/\nук ищисим(in ук строка, цел симв, т_мера члобайт)\n\t{\n\t//return memchr(строка, симв, члобайт);\n\n    ббайт *cs_ = cast(ббайт*) адаптВхоУкз(строка);\n    ббайт c_ = cast(ббайт) симв;\n    т_мера i;\n\n    for (i = 0; i < члобайт; ++i)\n    {\n\tif (cs_[i] == c_) return адаптВыхУкз(cast(ук) (cs_ + i));\n    }\n\n    return null;\n\n\n\t}\n\t\nalias ищисим ищи_символ;\n\n///////////////////////////////////////////////////////////\n/*\n* memcmp /сравбуф/: Сравнение символов двух буферов.\n* Если возврат < 0, то буф1 меньше буф2; возврат = 0, буферы идентичны;\n* возврат > 0, буф1 больше буф2.\n*/\nцел сравбуф(in ук буф1, in ук буф2, т_мера члобайт)\n\t{\n\treturn cast(цел)   memcmp(адаптВхоУкз(буф1), адаптВхоУкз(буф2), члобайт);\n\t/+\n\tint memcmp(const void *cs, const void *ct, size_t n)\n\t\n\tconst сим *cs_ = cs;\n    const сим *ct_ = ct;\n    size_t i;\n\n    for (i = 0; i < n; ++i)\n    {\n\tif (cs_[i] != ct_[i]) return cs_[i] - ct_[i];\n    }\n\n    return 0;\n\t+/\n\t}\n\t\nalias  сравбуф сравни_буферы;\n\n///////////////////////////////////////////////////////////\nversion(WinCRT_s)\n{\n\textern(C)\n\t{\n\tint memcpy_s(   void *dest,   size_t numberOfElements,   void *src,   size_t count );\n\tint wmemcpy_s(   wchar_t *dest,   size_t numberOfElements,   wchar_t *src,   size_t count);\n\t}\n}\n/*\n* memcpy /копирбуф/ копирует члобайт из истока в приёмник;\n* если исток и приёмник накладываются, то поведение\n* memcpy неопределено. Для обработки накладывающихся\n* регионов лучше использовать memmove /перембуф/.\n*/\nук копирбуф(ук приёмник, in ук источник, т_мера члобайт)\n{\t\n\t//version(useSNN)\n\treturn адаптВыхУкз(cast(ук) memcpy(адаптВхоУкз(приёмник), адаптВхоУкз(источник), cast(size_t) члобайт));\n\t/+  version(WinCRT_s)  memcpy_s(   п,   п.sizeof,   и,   члобайт );\n\t\n\tversion(вариант2)\n\t{\n\tт_мера i;\n\tсим *п = cast(char*) приёмник;\n    сим *и = cast(char*) источник;\n\t\n\t\tfor (i = 0; i < члобайт; ++i)\n\t\t{ \n\t\tп[i] = и[i];\n\t\t}\n\t}\n\t\n\ttry\n\t{\t\n\t\tсим *п = cast(char*) приёмник;\n\t\tсим *и = cast(char*) источник;\n\t\tт_мера чб = члобайт;\n\t\t\n\t\tif(приёмник <= источник)\n\t\t{\n\t\t\t while (чб--)\n\t\t\t\tп[чб] = и[чб];\n\t\t}\n\t\telse \n\t\t{\n\t\tперемести_буфер(приёмник, источник, члобайт);\n\t\t}\n\t}\n\t\tcatch(Объект ош){эхо(\"Error in cidrus.memcpy (ln 2042)\\n\");}\t\n\n    \n   return приёмник;+/\n}\n\t\nalias  копирбуф копируй_буфер;\n\n/////////////////////////////////////////////////////////////\n/*\n* memmove /перембуф/ копирует байты из откуда в куда.\n* Если некоторые области исходной зоны и приёмной нахлёстываются,\n* то гарантируется копирование исходных байтов из области\n* накладки до того, как будет произведена перезапись.\n*/\nук перембуф(ук куда, in ук откуда, т_мера сколько)\n\t{\n\treturn адаптВыхУкз(cast(ук) memmove(адаптВхоУкз(куда), адаптВхоУкз(откуда), cast(size_t) сколько));\n\t/+try\n\t{\n\t\tббайт *s_ = cast(ббайт*) куда;\n\t\tббайт *ct_ = cast(ббайт*) откуда;\n\n\t\tif (куда <= откуда)\n\t\t{\n\t\treturn копирбуф(куда, откуда, сколько);\n\t\t} else {\n\t\tfor ( ; сколько; --сколько) s_[сколько - 1] = ct_[сколько - 1];\n\t\t}\n\t}\n\tcatch(Объект ош){эхо(\"Error in cidrus.memmove (ln 2090)\\n\");}\n\n    return куда;+/\n\t\n\t}\n\t\nalias перембуф перемести_буфер;\n\n///////////////////////////////////////////////////\n/*\n* memset /устанбуф/ устанавливает первое чло символов приёмника\n* где на символ сим.\n*/\nук устбуф(ук куда, цел что, т_мера члосим)\n\t{\n\treturn адаптВыхУкз(memset(адаптВхоУкз(куда), что, члосим));\n\t\n\t/+ббайт *s_ = cast(ббайт*) куда;\n    ббайт c_ = cast(ббайт) что;\n    т_мера i;\n\n    for (i = 0; i < члосим; ++i) s_[i] = c_;\n\n    return куда;+/\n\t}\n\t\nalias  устбуф установи_буфер ;\n\n/////////////////////////////////////////////\n/*\n* Функция strcpy /копиртекс/ копирует символы откуда,\n* включая оканчивающий нуль, в место,\n* указанное параметром куда. Поведение strcpy\n* неопределено при накладке между источником и приёмником.\n*/\nткст0 копиртекс(ткст0 куда, in ткст0 откуда)\n\t{\n\t\n\treturn strcpy(куда, откуда);\n\t\n\t/+сим *p = cast(char*) куда;\n    while (*откуда) *p++ = *откуда++;\n    *p = 0;\n    return куда;+/\n\t}\n\t\nalias копиртекс копируй_символы;\n\n/////////////////////////////////////////////////\n/*\n* Функция strncpy /копирчтекс/ копирует начальное число символов\n* из  откуда в куда, и возвращает куда. Если члосим меньше или\n* равно длине откуда, то к копированной строке нулевой символ\n* автоматически не добавляется. Если же члосим больше длины\n* откуда, то принимающая строка заполняется на всю остаточную\n* длину нулями. При накладке источника и приёмника поведение\n* strncpy неопределено.\n*/\nткст0 копирчтекс(ткст0 куда, in ткст0 откуда, т_мера члосим)\n\t{\n\treturn strncpy( куда, откуда, члосим );\n\t}\n\t\nalias  копирчтекс копируй_чло_сим;\n\n/////////////////////////////////////////////\n/*\n* Функция strcat /сотекс/ добавляет текст_плюс к ткст1,\n* и завершает полученную строку нулевым символом.\n* Начальный сивол текст_плюс переписывает конечный\n* нулевой символ текст1. При накладке источника и\n* приёмника поведение неопределено.\n*/\nткст0 сотекс(ткст0 текст1, in ткст0 текст_плюс)\n\t{\n\treturn strcat(текст1, текст_плюс);\n\t}\n\t\nalias сотекс соедини_тексты;\n\n////////////////////////////////////////////////////\n/*\n* Функция strncat /сочтекс/ добавляет не более первого\n* чласим ткст2 к ткст1. Начальный символ ткст2 переписывает\n* конечный нулевой ткст1. Если до окончания добавления\n* в стр2 попадается нулевой символ, то strncat добавляет\n* все символы из ткст2, вплоть до нулевого. Если члосим\n* больше длины ткст2, то эта длина ткст2 используется\n* вместо члосим. Во всех случаях  получаемая строка\n* оканчивается на нулевой символ. Если происходит копирование\n* между налагающимися строками, то поведение её остаётся не выясненным.\n*/\nткст0 сочтекс(ткст0 ткст1, in ткст0 ткст2, т_мера члосим)\n\t{\n\treturn strncat(ткст1, ткст2, члосим);\n\t}\n\t\nalias  сочтекс соедини_чло_сим;\n\n////////////////////////////////////////////\n/*\n* Сравнение символов двух строк. Функция strncmp /сравнитекс/ сравнивает\n* лексикографически текст1 и текст2 и возвращает значение, показывающее их\n* взаимоотношение.\n* Если возврат < 0, то текст1 меньше текст2; возврат = 0, тексты идентичны;\n* возврат > 0, текст1 больше текст2.\n*/\nцел сравтекс(in ткст0 текст1, in ткст0 текст2)\n\t{\n\treturn cast(цел)    strcmp(текст1, текст2);\n\t}\n\t\nalias сравтекс сравни_тексты ;\n\n/////////////////////////////////////////////\n/*\n.........................\n*/\nцел кодстрсравнитекс( in ткст0 текст1, in ткст0 текст2)\n\t{\n\treturn cast(цел)    strcoll(текст1, текст2);\n\t}\n\t\nalias кодстрсравнитекс кссравтекс;\n///////////////////////////////////////////////\n/*\n* Сравнение символов двух строк с использованием текущей локали\n* или заданной локали. Функция strncmp /сравничтекс/ сравнивает \n* лексикографически не более чем первые члосим в текст1 и текст2,\n* и возвращает значение, показывающее взаимоотнощение между подстроками.\n* strncmp - это регистрочувствительная версия _strnicmp.\n*/\nцел сравчтекс(in ткст0 текст1, in ткст0 текст2, т_мера члосим)\n\t{\n\treturn cast(цел) strncmp(текст1, текст2, члосим);\n\t}\n\nalias сравчтекс сравни_чло_сим ;\n\n/////////////////////////////////////////////////\n/*\n* Функция strxfrm /форматчтекс/ преобразует строку, указанную как\n* из, в новую форму, сохраняемую в в. Преобразуется не более\n* чла символов, включая и нулевой, который помещаются в\n* результат. Трансформация происходит с применением\n* установки категории LC_COLLATE локали.\n*/\nт_мера форматчтекс(ткст0 в, in ткст0 из, т_мера чло)\n\t{\n\treturn cast(т_мера) strxfrm(в, из, чло);\n\t}\n\nalias форматчтекс преобразуй_чло_сим_лок ;\n\n//////////////////////////////////////////\n/*\n* Функция strchr /найдипер/ находит первый случай с в строке т,\n* либо возвращает NULL, если с не найден. В поиск включается и\n* завершающий символ нуля.\n*/\nткст  найдипер(in ткст0 т, цел с)\n\t{\n\treturn вТкст(strchr( т, с));\n\t}\n\t\nalias найдипер найди_перв_сим ;\n\n/////////////////////////////////////////\n/*\n* strcspn /персиндекс/: Возвращает индекс первого случая символа\n* что в строке где, который принадлежит к указанному в что\n* набору символов.\n*/\nт_мера персинд (in ткст0 где, in ткст0 что)\n\t{\n\treturn cast(т_мера) strcspn ( где, что);\n\t}\n\nalias персинд дай_индекс_перв_сим ;\n\n///////////////////////////////////////\n/*\n* Функция strpbrk /найдитексвнаб/ возвращает указатель на первый\n* символ в строке вчём, принадлежащий набору символов\n* из ряда изчего. Поиск не включает оканчивающего\n* нулевого символа.\n*/\nткст0  найдитексвнаб(in ткст0 вчём, in ткст0 изчего)\n\t{\n\treturn  strpbrk( вчём, изчего );\n\t}\n\t\nalias  найдитексвнаб найди_сим_из_набора ;\n\n/////////////////////////////////////\n/*\n* Функция strrchr /найдипос/ находит последний случай символа сим \n* (преобразованного в сим) в строке ткс. В поиск входит \n* оканчивающий нулевой символ.\n*/\nткст0  найдипос(in  ткст0 ткс, цел сим)\n\t{\n\treturn  strrchr ( ткс, сим );\n\t}\n\t\nalias найдипос найди_посл_сим ;\n\n/////////////////////////////////////\n/*\n* Функция strspn /найдитекснеизнаб/ возвращает индекс\n* первого символа в строке вчём,не принадлежащего набору\n* символов изчего. В поиск не входят\n* оканчивающие нулевые символы.\n*/\n\nт_мера найдитекснеизнаб(in ткст0 вчём, in ткст0 изчего)\n\t{\n\treturn cast(т_мера) strspn(вчём, изчего);\n\t}\n\t\nalias найдитекснеизнаб найди_сим_не_из_набора ;\n\n/////////////////////////////////////////\n/*\n* Функция strstr /найдиподтекст/ возвращает указатель на первый случай\n* искомой строки в строке стр. В поиске не участвуют\n* завершающие нулевые символы.\n*/\nткст0  найдиподтекс(in ткст0 стр, in ткст0 иском)\n\t{\n\treturn strstr(стр, иском);\n\t}\n\t\nalias найдиподтекс найди_подтекст ;\n\n/////////////////////////////////////////\n/*\n* Функция strtok /стрзнак/ находит следующий знак в стрзнак.\n* Набор символов в строгран определяет возможные\n* разграничители искомого в стрзнак знака.\n*/\nткст0  стрзнак(ткст0 стрзнак, in ткст0 строгран)\n\t{\n\treturn strtok(стрзнак, строгран);\n\t}\n////////////////////////////////////////\n/*\n* Функция strerror /строшиб/ преобразует номош в\n* строку сообщения об ошибке, возвращая указатель на\n* эту строку. Ни strerror, ни _strerror на самом деле\n* не выводят сообщения: для этого требуется вызвать\n* функцию вывода типа fprintf:\n\n\tif (( _access( \"datafile\",2 )) == -1 )\n   fprintf( stderr, _strerror(NULL) );\n   \n* Если  strErrMsg передано как NULL, _strerror возвратит указатель\n* на строку, содержащую системное сообщение об ошибке для последней\n* вызваной библиотеки, создавшей ошибку. Строка сообщения об ошибке\n* завершается символом перехода на новую строку ('\\n'). Если strErrMsg\n* не равно NULL, то _strerror возвращает уккзатель на строку,\n* содержащую ваше сообщение об ошибке, точку с запятой, пробел, системное\n* сообщение об ошибке последней вызванной библиотеки и символ новой строки.\n* Строковое сообщение может быть длиной не более 94 символов.\n\n* Действительный номер ошибки для _strerror хранится в переменной errno.\n* Системные сообщения об ошибке доступны через переменную _sys_errlist,\n* являющую собой масссив упорядоченных по номеру ошибки сообщений.\n* _strerror получает доступ к соответствующему сообщению по значению errno,\n* представляющему индекс в переменной _sys_errlist. Значение переменной _sys_nerr\n* определено как максимальное число элементов в массиве _sys_errlist. \n* Для правильной работы _strerror вызывается сразу после того, как процедура\n* библиотеки вернула ошибку. Иначе последующие вызовы strerror или _strerror\n* могут переписать значение errno.\n*/\nткст  строшиб(цел номош)\n\t{\n\treturn вТкст(strerror(cast(цел) номош));\n\t}\n\n////////////////////////////////////////\n/*\n* strlen /длинтекс/ воспринимает строку как однобайтный символьный ряд, поэтому значение\n* возврата всегда равно числу байтов, даже если в строке есть многобайтные\n* символы. wcslen -это широкосимвольная версия strlen.\n*/\nт_мера длинтекс(in ткст0 текст)\n\t{\n\t//return cast(т_мера) strlen (текст);\n\t\n\tт_мера len = 0;\n    while (текст[len]) ++len;\n    return len;\n\t}\n////////////////\n\nт_мера длинашкс (in шим* с){return wcslen(cast(wchar_t*) с);}\n\n//////////////////////////////////////////////////////////////////////\nук начнить(сифунк_У адр, бцел размстэка, ук аргспис)\n{\nreturn адаптВыхУкз(cast(ук) _beginthread(адр, размстэка, адаптВхоУкз(аргспис))); \n}\n\nпроц стопнить(){_endthread();}\n\nук начнитьдоп(ук безоп, бцел размстэка, винфункбЦ_У адр, ук аргспис, бцел иницфлаг, бцел* адрнити)\n{\nreturn адаптВыхУкз(cast(ук) _beginthreadex(адаптВхоУкз(безоп), размстэка, cast(stdfp) адр, аргспис, иницфлаг, адрнити));\n}\n\nпроц стопнитьдоп(бцел кодвых){_endthreadex(кодвых);}\n\n",
			"file": "cidrus.d",
			"file_size": 95956,
			"file_write_time": 131261088102519531,
			"settings":
			{
				"buffer_size": 74712,
				"line_ending": "Windows"
			}
		},
		{
			"contents": " /***\nМодуль рантайма языка Динрус. Разработчик Виталий Кулич.\n\n*/\nmodule runtime;\nimport gc, cidrus: выход;\nimport  sys.WinFuncs;\n\n//debug = НА_КОНСОЛЬ;\n\nextern (C)\n{\n\t\tпроц нить_объединиВсе();\n\t\tпроц нить_иниц();\n\t\tvoid _d_callfinalizer(ук  p);\n\t\tпроц установиКонсоль();\n}\n\nextern (Windows) int WideCharToMultiByte(uint, uint, wchar_t*, int, char*, int, char*, int);\n\nalias extern(C) проц function() МодИниц;\n\n//======================================================================\n//Получение аргументов командной строки\n\n//Функция для получения этих аргументов \n//вызывающей программой в обработанном виде:\nexport extern(C) ткст[] дайАргиКС(){return арги;}\n//Функция, с помощью которой библиотека получает \"сырые\" аргументы от\n//от вызывающей программы:\nexport extern (C) ткст[] ртПолучиАрги(int argc, char **argv)\n{\t\n\n        wchar*    wcbuf = GetCommandLineW();\n        size_t    wclen = wcslen(wcbuf);\n        int       wargc = 0;\n        wchar**   wargs = CommandLineToArgvW(wcbuf, &wargc);\n        assert(wargc == argc, stdrus.вТкст(\"Расхождение числа аргументов командной строки\"));\n\n        char*     cargp = null;\n        size_t    cargl = WideCharToMultiByte(65001, 0, wcbuf, wclen, null, 0, null, 0);\n\n        cargp = cast(char*) alloca(cargl);\n        арги  = ((cast(char[]*) alloca(wargc * (char[]).sizeof)))[0 .. wargc];\n\n        for (size_t i = 0, ptr = 0; i < wargc; i++)\n        {\n            int wlen = wcslen( wargs[i] );\n            int clen = WideCharToMultiByte(65001, 0, &wargs[i][0], wlen, null, 0, null, 0);\n            арги[i]  = cargp[ptr .. ptr+clen];\n            ptr += clen; assert(ptr <= cargl);\n            WideCharToMultiByte(65001, 0, &wargs[i][0], wlen, &арги[i][0], clen, null, 0);\n        }\n        LocalFree(cast(HLOCAL) wargs);\n        wargs = null;\n        wargc = 0;\n\t\treturn арги;\n/*\n\nstatic цел шдлина;\nstatic цел чдлин;\nstatic ушим*   шарги;\n\t\t\t\t\t\n\t\tпроц ошиб()\n\t\t{\n\t\tбцел кодош = ДайПоследнююОшибку();\n\t\tthrow new Исключение (текстСисОшибки(кодош));\n\t\t}\n\ntry{\n\t\t \tушим    шбуфчтен = ДайКомСтроку();\n\t\t\tт_мера    шстрдлин = длинашкс(шбуфчтен);\n\t\t\tцел       шаргчло = 0;\n\t\t\tшарги = КомСтрокаВАрги(шбуфчтен, &шаргчло);\n\t\t\tassert(шаргчло == аргчло);\n\n\t\t\tstatic усим     аргук = null;\n\t\t\tт_мера    аргстр = ШирСимВМультиБайт(ПКодСтр.УТФ8, cast(ПШирСим) 0, шбуфчтен, шстрдлин, null, 0, null, нет);\n\n\t\t\tаргук = cast(усим) разместа(аргстр);\n\t\t\tарги  = ((cast(char[]*) разместа(шаргчло * (char[]).sizeof)))[0 .. шаргчло];\n\t\n\t\t\tfor (т_мера i = 0, укз = 0; i < шаргчло; i++)\n\t\t\t{\n\t\t\t\tшдлина = длинашкс( шарги[i] );\n\t\t\t\tassert(шдлина <= int.max, stdrus.вТкст(\"Длина аргументов не может превышать int.max\"));\n\t\t\t\tчдлин = ШирСимВМультиБайт(ПКодСтр.УТФ8, cast(ПШирСим) 0, &шарги[i][0], шдлина, null, 0, null, нет);\n\t\t\t\tарги[i]  = аргук[укз .. укз+чдлин];\n\t\t\t\tукз += чдлин; assert(укз <= аргстр);\n\t\t\t\tif(!ШирСимВМультиБайт(ПКодСтр.УТФ8, cast(ПШирСим) 0, &шарги[i][0], шдлина, &арги[i][0], чдлин, null, нет))ошиб;\t\t\t\t\t\n\t\t\t}\n\t\t\tОсвободиЛок(шарги);\n\t\t\tшарги = null;\n\t\t\tшаргчло = 0;\n\t\t\treturn арги;\n\t\t}\n\tcatch(Исключение и)\n\t\t\t\t\t\t{и.вТкст(); }//return арги = [\"<пусто>\"];}\n\t\t*/\t\n}\n\n//==============================================================\n\nstatic ОбработчикСборки сбобр = null;\nalias сбобр collectHandler;//нужно для модуля rt.lifetime\nstatic Следопыт следопыт = null;\n\nstatic\tт_см _см;//Рабочий экземпляр сборщика мусора\n\nstatic\tбул задержка_ли = нет;\nstatic\tбул ртПущен_ли = нет;\t\nstatic\tбул смИнициирован = нет;\n\n//Аргументы командной строки:\nstatic ткст[] арги;\n\n\n//++=====================================================================\nextern(C) ИнфОМодуле[] _moduleinfo_array;\nexport extern(C) struct Рантайм\n{\nenum\n{   НКМНачато = 1,\t// построение модулей началось\n    НКМВыполнено = 2,\t// завершилось\n    НКМОдиночно = 4,\t// конструктор модуля не зависимый от\n\t\t\t// ранее инициализированных конструкторов\n    ЕстьНКМ = 8,\t// есть независимые конструкторы\n}\n\nstatic ИнфОМодуле[] конструкторы;\nstatic ИнфОМодуле[] деструкторы;\nstatic бцел квоПостроений = 0;\nstatic бцел индекс;\n\n//Запуск сборщика мусора:\n/*private*/ проц смСтарт()\n\t\t{\t\t  \n\t\t\tук укз;\n\t\t\tИнфОКлассе ci = СМ.classinfo;\n\n\t\t\tукз = cidrus.празмести(ci.init.length);\n\t\t\t(cast(байт*)укз)[0 .. ci.init.length] = ci.init[];\n\t\t\t_см = cast(т_см)  укз;\n\t\t\t_см.иниц();\n\t\t\tсмИнициирован = да;\n\t\t\t_см.сканируйСтатДан( _см);\n\t\t\t\tdebug(НА_КОНСОЛЬ) скажинс (\"смСтарт передаёт команду пускНити\");\n\t\t\tнить_иниц();\n\t\t\t\tdebug(НА_КОНСОЛЬ) скажинс(\"СборщикМусора успешно инициализирован. Поздравляю!\");\n\t\t\t\tdebug(НА_КОНСОЛЬ) смСтат();\t   \n\t\t}\n//Передача адреса СМ вовне:\t\t\nexport extern(C) т_см дайСборщикМусора()\n{\nreturn cast(т_см) _см;\n}\n\n//Функции для передаче информации о подключенных модулях, их\n//а.Конструкторы:\nexport extern(C) ИнфОМодуле[] дайКонструкторы()\n{\nreturn конструкторы;\n}\n//б.Деструкторы:\nexport extern(C) ИнфОМодуле[] дайДеструкторы()\n{\nreturn деструкторы;\n}\n\n//Необходимая процедура для переучёта конструкторов и деструкторов\n//при присоединении к библиотеке новых запущеных модулей и формирования списка модулей\n//для их обработки сборщиком мусора.\n/*private*/ проц перерасчётИнфоСтруктур(ИнфОМодуле[] масмод)\n{\n\tif(квоПостроений >= 1 && масмод !is null)\n\t{\n\t\tИнфОМодуле[] м = конструкторы~масмод;\n\t\tassert(м.length == (конструкторы.length+масмод.length));\n\t\tконструкторы = м;\n\t\tassert(конструкторы.length == м.length);\n\n\t\tИнфОМодуле[] д = деструкторы~new ИнфОМодуле[масмод.length];\n\t\tassert(д.length == (деструкторы.length+масмод.length));\n\t\tдеструкторы = д;\n\t\tassert(деструкторы.length == д.length);\n\n\t\tбцел пересчёт;\n\t\tforeach(дест; деструкторы)\n\t\t{\n\t\t  if(дест !is null) пересчёт++;\t\t  \n\t\t}\n\t\t//assert(пересчёт > индекс);\n\t\tиндекс = пересчёт;\n\t\tassert(индекс < деструкторы.length);\n\t\tdebug(НА_КОНСОЛЬ) скажинс(\"НАШ ПЕРЕРАСЧЁТ СРАБОТАЛ!))))))\");\n\t}\n}\n//Выполняет инициализацию модулей как для самой библиотеки, так и для\n//запускаемых и присоединяемых к ней программ.\n/*private*/ проц модИниц(МодИниц миниц = &_minit, ИнфОМодуле[] масмод = null)\n {\nif(миниц) миниц();\nif(масмод is null && квоПостроений == 0)\n{\nконструкторы = _moduleinfo_array;\nдеструкторы = new ИнфОМодуле[конструкторы.length];\n}\nelse перерасчётИнфоСтруктур(масмод);\n квоПостроений++;\n\ndebug(НА_КОНСОЛЬ) эхо(\"moduli.vsye = x%x\\n\", cast(ук )конструкторы);\n\ndebug(НА_КОНСОЛЬ) эхо(\"moduli.destructory = x%x\\n\", cast(ук )деструкторы);\n//delete _moduleinfo_array;\n}\n\n/*private*/ проц проверка() \n\t\t{\n\t\t\t\tdebug(НА_КОНСОЛЬ) скажи(\"проверкаМодулей()\\n\");\n\t\t\tfor (бцел i = 0; i < конструкторы.length; i++)\n\t\t\t{\n\t\t\tИнфОМодуле m = конструкторы[i];\n\n\t\t\tif (!m)\n\t\t\t\tcontinue;\n\n\t\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"\\tmodule[%d] = '%.*s'\\n\", i, m.name);\n\t\t\tif (m.unitTest)\n\t\t\t{\n\t\t\t\t(*m.unitTest)();\n\t\t\t}\n\t\t\t}\n\t\t}\n\n/*private*/ бул стройНезависимые()\n\t\t\t{\n\t\t\t\tdebug(НА_КОНСОЛЬ) скажи(\"констрНезависимыхМодулей()\\n\");\n\t\t\t\tint raz = 1;\n\t\t\t\tforeach (m; конструкторы)\n\t\t\t\t{\n\t\t\t\tif (m && m.flags & ЕстьНКМ && m.ictor)\n\t\t\t\t\t{\n\t\t\t\t\t\t(*m.ictor)();\n\t\t\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"\\tindependent module '%.*s'\\n\", m.name);\n\t\t\t\t\t}\n\t\t\t\tdebug(НА_КОНСОЛЬ) скажинс(фм(\"%d цикл конструктора независимых (не импортирующих) модулей\", raz));\n\t\t\t\traz++;\n\t\t\t\t}\n\t\t\t\treturn да;\n\t\t\t}\n\t\t\t\n/*private*/ бул стройМодули(ИнфОМодуле[] ми, бул пропуск)\n{\n\t//перерасчётИнфоСтруктур(ми);\n\t\t\t\t\t\n\t\tdebug(НА_КОНСОЛЬ)\n\t\t\t\t{\n\t\t\t\tскажинс(\"\\nНОВЫЙ ВЫЗОВ ПОСТРОЙЩИКА МОДУЛЕЙ\");\n\t\t\t\tскажинс(фм(\"\\nконструкторМодулей(): %d модулей\", ми.length));\n\t\t\t\tскажинс(\"Список всех модулей: \");\n\t\t\t\t\tint n = 1;\n\t\t\t\t\tforeach(m; ми)\n\t\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tэхо(\"%d.< %.*s >: %p\\n\", ми.length - (ми.length - n), m.name, m);\n\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t\tнс;\n\t\t\t\t\tскажинс(\"Обработка\");\n\t\t\t\t\tнс;\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (бцел i = 0; i < ми.length; i++)\n\t\t\t{\n\t\t\t\tИнфОМодуле m = ми[i];\n\n\t\t\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"Module[%d] = '%p' = '%.*s'\\n\", i, m, m.name);\n\t\t\t\tif (!m)\n\t\t\t\t{\n\t\t\t\tdebug(НА_КОНСОЛЬ) скажинс(\"ИнфОМодуле отсутствует\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif (m.flags & НКМВыполнено)\n\t\t\t\t{\n\t\t\t\tdebug(НА_КОНСОЛЬ) скажинс(\"Модуль уже построен\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"Module[%d] = '%.*s', m = x%x, m.flags = x%x\\n\", i, m.name, m, m.flags);\n\n\t\t\t\tif (m.ctor || m.dtor)\n\t\t\t\t{\n\t\t\t\t\tif (m.flags & НКМНачато)\n\t\t\t\t\t{\tif (пропуск || m.flags & НКМОдиночно)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tdebug(НА_КОНСОЛЬ) скажи(\"Пропущен модуль: \");\n\t\t\t\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"module[%d] = '%.*s', m = x%x, m.flags = x%x\\n\", i, m.name, m, m.flags);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\tthrow new ОшКтораМодуля(m);\n\t\t\t\t\t}\n\n\t\t\t\t\tm.flags |= НКМНачато;\n\t\t\t\t\tdebug(НА_КОНСОЛЬ) скажинс(\"\\nРекурсивный вызов  1\");\n\t\t\t\t\tthis.стройМодули(m.importedModules, нет);\n\t\t\t\t\tif (m.ctor)\n\t\t\t\t\tdebug(НА_КОНСОЛЬ)\n\t\t\t\t\t{\n\t\t\t\t\tскажи(\"Выполняется конструктор для модуля: \\n\");\n\t\t\t\t\tэхо(\"\\tmodule[%d] = '%.*s', m = x%x, m.flags = x%x\\n\", i, m.name, m, m.flags);\n\t\t\t\t\t}\n\t\t\t\t\t(*m.ctor)();\n\t\t\t\t\tdebug(НА_КОНСОЛЬ) скажи(\"Конструктор выполнен \\n\");\n\t\t\t\t\tm.flags &= ~НКМНачато;\n\t\t\t\t\tm.flags |= НКМВыполнено;\n\t\t\t\t\tdebug(НА_КОНСОЛЬ) скажи(\"Флаги установлены \\n\");\n\t\t\t\t\t// После выполнения конструктора регистрируем деструктор\n\t\t\t\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"\\tadding module dtor x%x\\n\", m);\n\t\t\t\t\tassert(индекс < деструкторы.length);\t\t\t\t\t\n\t\t\t\t\tдеструкторы[индекс++] = m;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.flags |= НКМВыполнено;\n\t\t\t\t\tdebug(НА_КОНСОЛЬ) скажинс(\"\\nРекурсивный вызов  2\");\n\t\t\t\t\tthis.стройМодули(m.importedModules, да);\n\t\t\t\t}\n\t\t\t}\n\t\treturn да;\n\t\t}\n\nexport extern(C) бул старт()\n{\nсмСтарт();\ndebug(НА_КОНСОЛЬ) скажинс(\"ПУСК СМ - отлично!\");\nмодИниц();\ndebug(НА_КОНСОЛЬ) скажинс(\"ИНИЦИАЛИЗАЦИЯ МАССИВА МОДУЛЕЙ - отлично!\");\nстройНезависимые();\ndebug(НА_КОНСОЛЬ) скажинс(\"ПОСТРОЕНИЕ НЕЗАВИСИМЫХ МОДУЛЕЙ - отлично!\");\nстройМодули(конструкторы, нет);\ndebug(НА_КОНСОЛЬ) скажинс(\"ПОСТРОЙКА МОДУЛЕЙ - отлично!\");\t\nпроверка();\ndebug(НА_КОНСОЛЬ) скажинс(\"ПРОВЕРКА МОДУЛЕЙ - отлично!\");\nртПущен_ли = да;\nreturn да;\n}\n\nexport extern(C) бул интегрируй(ИнфОМодуле[] масмод)\n{\nмодИниц(null, масмод);\nстройНезависимые();\nстройМодули(конструкторы, нет);\nreturn да;\n}\n\n/*private*/ проц деструктор() \n{\n\tdebug(НА_КОНСОЛЬ) скажи(фм(\"деструкторМодулей(): %d модулей\\n\", индекс));\n\tfor (бцел i = индекс; i-- != 0;)\n\t{\n\t\tИнфОМодуле m = деструкторы[i];\n\n\t\tdebug(НА_КОНСОЛЬ) эхо(\"\\tmodule[%d] = '%.*s', x%x\\n\", i, m.name, m);\n\t\tif (m.dtor)\n\t\t{\n\t\t\t(*m.dtor)();\n\t\t}\n\t}\n}\n\t\t\n/*private*/ проц смСтоп()\n\t\t{\n\t\t_см.полныйСборБезСтэка(); \t\t\t\t\t\t\t\t\t\n\t\t_см.Дтор();\t\n\t\tcidrus.освободи(cast(ук )_см);\n\t\t}\n\nexport extern(C) проц стоп()\n\t{\n\tртПущен_ли = нет;\n\tдеструктор();\n\tсмСтоп();\t\n\t}\n\n}\n\nstatic Рантайм _рт;\nexport extern (C) Рантайм рантайм(){return _рт;}\n//=========================================================\nexport extern (C)\tбул ртСтарт(ПередВходом передвхо = null, ОбработчикИсключения дг = null)\n\t{\n\n\tif (ртПущен_ли)\t\t\n\t\t\treturn да;\n\t\t\t\n\t\ttry\n\t\t{\n\t\t_рт.старт();\n\t\tif(передвхо) передвхо();\n\t\t\t\t\t\t\t\t\n\t\t}\n\t\tcatch( Исключение e )\n\t\t{\n\t\t\tif( дг )\n\t\t\t\tдг( e );\n\t\t\t\t\treturn нет;\n\t\t}\n\t\tfinally\n\t\t{\n\t\tустановиКонсоль();\n\t\t}\n\t\treturn да;\n\t}\n//}\n//===========================================================================================\t\t\n\n\n\nexport extern (C)\tпроц ртСтоп()//ПередВыходом передвых = пусто, ОбработчикИсключения дг = пусто )\n\t{\n\t\n\t\n\n\t\n\t\ttry\n\t\t\t{\n\t\t\tзадержка_ли = да;\n\t\t\tобъединиВсеНити(); \n\t\t\t_рт.стоп();\t\n\t\t\t\tвыход(0);\t\t\t\n\t\t\t}\n\t\t\tcatch( Исключение e )\n\t\t\t{\n\t\t\t\tвыход(-1);\t\t\n\t\t\t}\t\n\t\t\t\n\t\n\t}\n\t\n\nexport extern (C) бул ртПущен(){ return ртПущен_ли;}\nexport extern (C) бул ртОстановлен(){ return !ртПущен_ли;}\t\n\n//==================================================================\n/+\nпроц создайПроцесс( )\n{\n    ИНФОСТАРТА si;\n    ИНФОПРОЦ pi;\n\n    ОбнулиПамять( &si, si.sizeof );\n    si.размер = si.sizeof;\n    ОбнулиПамять( &pi, pi.sizeof );\n\n    // Start the child process. \n    if( !СоздайПроцесс( пусто,   // Без названия модуля (использовать комстроку). \n        \"MyChildProcess\", // Комстрока. \n        пусто,             // Хендл процесса ненаследуемый. \n        пусто,             // Хендл нити ненаследуемый. \n        нет,            // Устанавливает наследование хендла в нет. \n        0,                // Без флагов создания. \n        пусто,             // Используется блок среды родителя. \n        пусто,             // Используется стартовая папка родителя. \n        &si,              // Указатель на структуру STARTUPINFO.\n        &pi )             // Указатель на структуру PROCESS_INFORMATION.\n    ) \n    {\n        скажифнс( \"CreateProcess не удался, т.к. (%d).\\n\", ДайПоследнююОшибку() );\n        return;\n    }\n\n    // Ожидание завершения дочернего процесса.\n    ЖдиОдинОбъект( pi.процесс, БЕСК );\n\n    // Закрытие хендлов процесса и нити. \n    ЗакройДескр( pi.процесс );\n    ЗакройДескр( pi.нить );\n}\n+/\n/**\n* Функция требует дополнения (и продолжения) из Танго.\n*/\n\n\n\n//========================================================================\n\nexport extern (C) проц  ртСоздайОбработчикСледа( Следопыт h )\n\t{\n\t\tследопыт = h;\n\t}\n\n/**\n*Функция требует дополнения (и продолжения) из Танго.\n*/\nexport extern (C) Исключение.ИнфОСледе ртСоздайКонтекстСледа( ук  укз ){\n\t\tif( следопыт is null )\n\t\t\treturn null;\n\t\treturn следопыт( укз );\n\t\t}\n\n/**\n*Обработчик сборки взят из Танго и требуется\n*добавка кода оттуда, чтобы эта функция оказалась полезной.\n*(Дублировать на английском?)\n*/\nexport extern (C) проц  ртУстановиОбработчикСборки(ОбработчикСборки h)\n\t{\n\t\tсбобр = h;\t\n\t}\n/**\n* По идее у нас должно выполниться построение списков данных о модулях\n* библиотеки внутри самой библиотеки. Такое же построение происходит и\n* в параллельно запущенном исполнимом процессе. Поскольку их память\n* разграничена и не пересекается, эти процессы проводятся отдельно,\n* а далее - при слиянии сборщиков - все они объединяются в одно целое.\n*\n* Концептуально можно следовать двум путям:\n* а) использовать один общий сборщик мусора для всех выполняющихся модулей\n* Динрус, что позволило бы контролировать общую рабочую среду для данного\n* языка программирования, мониторировать все работающие программы, написанные\n* на Динрусе, объединить все эти процессы одним общим сервисным узлом,\n* который выполняет контролирующие функции и следит за \"поведением\"\n* своего \"братства\"...\n* \n* б) создавать локальный СМ для каждой отдельной программы, то есть\n* загружать память лишним мусором, тормозя быстродействие машины...\n* \n* В первом варианте рантайм выступает серверной службой, постоянно\n* работающей для всех процессов; во втором - он загружается каждым процессом\n* в своё \"личное\" адресное пространство и ничего не знает о сосуществовании\n* других процессов, использующих его же копию в своём индивидуальном\n* пространстве...\n* \n* На данный момент реализуемо и то и другое, но приоритет, кажется,\n* нужно отдать первому варианту - это гарантия обеспечения безопасности\n* для компьютера в целом со стороны программ, написанных на Динрусе и\n* возможность точного мониторинга и контроля за общей рабочей средой.\n* \n* Собственно, Майкрософт так и делает в случае своего CLR.(!)\n* \n* в) Третий вариант более замысловатый: СЛУЖБА КОНТРОЛЯ над\n* мусоросборщиками локальных процессов, т.е некий общий мусорособрщик-\n* супервайзер, контролирующий работу внутренних мусоросборщиков\n* каждой отдельной из программ. То есть, сетевая структура (!)\n* с общим центром контроля...\n* \n* Как только появится библиотека VIZ - визуализации интерфейса\n* пользователя, в трее может быть размещен \"рычаг\" для управления и\n* мониторинга; а рантайм будет пополнен множеством модулей мониторинга\n* всей рабочей среды Динрус, вплоть до регистрации времени работы каждой из программ.\n* \n* Те части Рулады, которые вряд ли будут далее изменяться, можно\n* руссифицировать в виде обёрток и поместить в динамические библиотеки типа\n* Dinrus.DBI.dll  и т.д. Это зрелые продукты, исходные коды которых\n* можно будет надолго заархивировать и забыть об их \"толщине\",\n* оставив только интерфейсные файлы для пользования реализованным в них \"добром\".\n* \n* У Рулады свой рантайм, поэтому Динрус должен регистрировать кэш подобных\n* модулей. Впрочем, Такие же модули могут быть и на других языках программирования,\n* с интерфейсом импорта типа lib.sdl или lib.arc, которые уже есть в Динрусе...\n* \n* Желательно не доверять чуждым продуктам, а пользоваться открытым кодом и\n* создавать проверенные экземпляры с префиксом Dinrus (Dinrus.SDL.dll etc),\n* чтобы в случае чего образовался самостоятельный кластер, на основе которого\n* можно было бы создать собственную операционную систему.\n* \n*/\t\n\t\nexport extern (C)\n{\n///////////////////////////////////////////////////////////\t\n\tбул рт_вЗадержке()\n\t\t{\n\t\t\treturn задержка_ли;\n\t\t}\n////////////////////////////////////////////////////////\t\n\t\n\tбул смПроверь(ук укз)\n\t\t{\n\t\t_см.проверь(укз); return да;\n\t\t}\t\t \n\t\n\tбул смУменьши()\n\t\t{\n\t\t_см.экономь(); return да;\n\t\t}\n\t\n\t бул смДобавьКорень( ук укз )\n\t\t{ \n\t\t_см.добавьКорень( укз ); return да;\n\t\t}\t \n\t\n\t бул смДобавьПространство( ук укз, т_мера разм )\n\t\t{\n\t\t_см.добавьПространство( укз, разм ); return да;\n\t\t}\n\t\t\n\t бул смДобавьПространство2( ук укз, ук разм )\n\t\t {\n\t\t _см.добавьПространство( укз, разм ); return да;\n\t\t }\n\t\t \n\t бул смУдалиКорень( ук укз )\n\t\t{\n\t\t_см.удалиКорень( укз ); return да;\n\t\t}\n\t\t\n\t бул смУдалиПространство( ук укз )\n\t\t{ \n\t\t_см.удалиПространство( укз );return да;\n\t\t}\n\t\t\n\tт_мера смЁмкость(ук укз)\n\t\t { \n\t\t   return _см.ёмкость(укз);\t\t\n\t\t }\n\t\t\n\t бул смМонитор(ddel начало, dint конец )\n\t\t{\n\t\t_см.монитор(начало, конец); return да;\n\t\t}\n\t \n\t бул смСтат()\n\t\t {\n\t\t СМСтат стат = смДайСтат();\n\t\tскажинс(фм(\"\n\t\tИНФО О СОСТОЯНИИ СМ:\n\t\t#размер пула = x%x,\n\t\t#используемый размер = x%x,\n\t\t#размер списка очистки = x%x,\n\t\t#блоков очистки = %d,\n\t\t#блоков страниц = %d\",\tстат.размерПула, стат.испРазмер, стат.размСпискаСвобБлоков, стат.свобБлоки, стат.блокиСтр));\n\t\t\treturn да;\n\t\t}\n\t\t\n\t СМСтат смДайСтат()\n\t\t {\n\t\t\tСМСтат стат;\n\t\t\t_см.дайСтат(стат);\t\t\t\n\t\t\treturn стат;\n\t\t}\n\t\t\n\t проц[] смПразместиМас(т_мера члобайт)\n\t\t {\n\t\t\tук  укз = смКразмести(члобайт);\n\t\t\treturn cast(проц[]) укз[0 .. члобайт];\t\n\t\t }\n\t\n\t проц[] смПереместиМас(ук  укз, т_мера члобайт)\n\t\t{\n\t\t\tук  q = смПеремести(укз, члобайт);\n\t\t\treturn cast(проц[]) q[0 .. члобайт];\n\t\t}\n\t \n\t бул устИнфОТипе(ИнфОТипе иот, ук  укз)\n\t {\n\t\tsetTypeInfo(иот, укз);\n\t\treturn да;\n\t }\n\t\n\t ук  дайУкНаСМ()\n\t\t{\n\t\treturn адаптВыхУкз(&_см);\n\t\t}\n\t\n\t бул укНаСМ(ук  укз)\n\t \t{\n\t\tук oldp = дайУкНаСМ();\n\t\tт_см g = cast(т_см)адаптВхоУкз(укз);\n\t\t// Add our static data to the new gc\n\t\t_см.сканируйСтатДан(g);\n\t\t_см = g;\n\t\treturn да;\n\t\t}\n\t\t\n\t бул сбросьУкНаСМ()\n\t\t{\n\t\t_см.отсканируйСтатДан(_см);return да;\n\t\t}\n\t\n\t\n\t бцел смДайАтр( ук  укз )\n\t\t {\n\t\t  return _см.дайАтр( укз );\t\n\t\t }\n\t\n\t бцел смУстАтр( ук  укз, ПАтрБлока a )\n\t \t{\n\t   \treturn _см.устАтр( укз, a );\n\t\t}\t\n\t\n\t бцел смУдалиАтр( ук  укз, ПАтрБлока a )\n\t\t {\n\t\t\treturn _см.удалиАтр( укз, a );\t\n\t\t }\n\t \n\t ук  смПразмести( т_мера разм, бцел ba = 0 )\n\t\t {\n\t\t\treturn адаптВыхУкз(_см.празмести( разм, ba ));\t\n\t\t }\n\t\t \n\t ук  смКразмести( т_мера разм, бцел ba = 0 )\n\t\t {\n\t\t return адаптВыхУкз(_см.кразмести( разм, ba ));\t\t\n\t\t }\n\t\t \n\t ук  смПеремести( ук  укз, т_мера разм, бцел ba = 0 )\n\t\t{\n\t\t  return адаптВыхУкз(_см.перемести( укз, разм, ba ));\t\t\n\t\t}\n\t\n\t т_мера смРасширь( ук укз, т_мера mx, т_мера разм )\n\t\t{\n\t\treturn _см.расширь( укз, mx, разм );\t\t\n\t\t}\n\t\t\n\t т_мера смРезервируй( т_мера разм )\n\t\t{\n\t\treturn _см.резервируй( разм );\t\t\n\t\t}\n\t\n\t бул смОсвободи( ук  укз )\n\t\t{\n\t\t_см.освободи( адаптВхоУкз(укз) ); return да;\n\t\t}\n\t\n\t ук  смАдрес( ук  укз )\n\t\t{\n\t\treturn адаптВыхУкз(_см.адрес_у(адаптВхоУкз( укз)));\n\t\t}\n\t\n\t т_мера смРазмер( ук  укз )\n\t\t{\n\t\treturn _см.размер_у( адаптВхоУкз(укз) );\n\t\t}\n\t\t\n\t ук  смСоздайСлабУк( Объект r )\n\t\t{\n\t\t  return адаптВыхУкз(_см.создайСлабУк(r));\t\n\t\t}\n\t\n\t бул смУдалиСлабУк( ук  wp )\n\t \t{\n\t\t_см.удалиСлабУк(адаптВхоУкз(wp));return да;\t\t\n\t\t}\n\t\t\n\t Объект смДайСлабУк( ук  wp )\n\t {\n\t return _см.дайСлабУк(адаптВхоУкз(wp));\t\n\t }\n\t\n\t ИнфОБл смОпроси( ук  укз )\n\t\t{\n\t\t return cast(ИнфОБл) _см.опроси(адаптВхоУкз( укз) );\t\n\t\t}\n\t\n\t бул смВключи()\n\t\t {\n\t\t  _см.вкл(); return да;\n\t\t }\n\t\n\t бул смОтключи()\n\t\t{\n\t\t _см.откл(); return да;\n\t\t}\n\t \n\t бул смСобери()\n\t\t{\n\t\t _см.собери();return да;\n\t\t}\n\t\t\n\tбул смИниц_ли(){return смИнициирован;}\n\t\n\t//цел смОбходКорня(){return _см.обходКорня;}\n\t\n\t//цел смОбходПространства(){return _см.обходПространства;}\n}\n\n\tпроц объединиВсеНити() {нить_объединиВсе();}\t\n\n//////////////////////////////////////////////////////////\n\t\nalias СМСтат GCStats;\nalias ИнфОБл BlkInfo;\nalias ФИНАЛИЗАТОР_СМ GC_FINALIZER;\nalias т_см gc_t;\nModuleInfo[] _moduleinfo_dtors;\nuint _moduleinfo_dtors_i;\n\nexport extern (D)\n{\n\t\t void addRoot(ук укз)\t\t      { _см.добавьКорень(укз); }\n\t\t void removeRoot(ук укз)\t      { _см.удалиКорень(укз); }\n\t\t void addRange(ук pbot, ук ptop) {_см.добавьПространство( pbot, ptop );}\n\t\t void removeRange(ук pbot)\t      { _см.удалиПространство(pbot); }\n\t\t void fullCollect()\t\t      { _см.собери(); }\n\t\t void fullCollectNoStack()\t      {_см.полныйСборБезСтэка();}\n\t\t void genCollect()\t\t      { _см.генСбор();}\n\t\t void minimize()\t\t\t      { _см.экономь(); }\n\t\t void disable()\t\t\t      { _см.откл(); }\n\t\t void enable()\t\t\t      { _см.вкл(); }\n\t\t void getStats(out GCStats stats)      {  _см.дайСтат(stats);}\n\t\t void hasPointers(ук  укз)\t      { _см.естьУказатели(укз); }\n\t\t void hasNoPointers(ук  укз)\t      {  _см.нетУказателей(укз);}\n\t\t void setV1_0()\t\t\t      { _см.устВ1_0();}\n\t\t \n\tvoid[] malloc(size_t nbytes)\n\t\t{\n\t\t\tук  укз = _см.празмести(nbytes);\n\t\t\treturn cast(void[]) укз[0 .. nbytes];\t\n\t\t}\n\n\tvoid[] realloc(ук  укз, size_t nbytes)\n\t\t{\n\t\t\tук  q = _см.перемести(укз, nbytes);\n\t\t\treturn cast(void[]) q[0 .. nbytes];\n\t\t}\n\n\tsize_t extend(ук  укз, size_t minbytes, size_t maxbytes)\n\t\t{\n\t\t\treturn _см.расширь(укз, minbytes, maxbytes);\n\t\t}\n\n\tsize_t capacity(ук  укз)\n\t\t{\n\t\t\treturn _см.ёмкость(укз);\n\t\t}\n }\n \n////////////////////////////////////////////////\n\nexport extern (C) проц _moduleCtor()\n{\n    _рт.модИниц();\n    _рт.стройНезависимые();\n    _рт.стройМодули(_рт.конструкторы, нет);    \n}\n\nexport extern (C) проц _moduleCtor2(ИнфОМодуле[] mi, бул skip)\n{\n    _рт.стройМодули(mi, skip);\n}\n\n\n/**********************************\n * Destruct the modules.\n */\n\n// Starting the name with \"_STD\" means under linux a pointer to the\n// function gets put in the .dtors segment.\n\n  export extern (C) проц _moduleDtor()\n\t{\n\t_рт.деструктор();\n\t}\n\n\t/**********************************\n\t * Run unit tests.\n\t */\n\n\t export extern (C) проц _moduleUnitTests()\n\t{\n\t_рт.проверка();\n\t}\n\n\t/**********************************\n\t * Run unit tests.\n\t */\n\n\texport  extern (C) проц _moduleIndependentCtors()\n\t{\n\t_рт.стройНезависимые();\n\t}\n\n\n////////////////////////////////////////////////////////////////\n//приводится чисто для использования библиотеки из Си\nexport:\n   \n extern (C)  void _d_gc_addrange(ук pbot, ук ptop)\n\t{\n\t\t_см.добавьПространство(pbot, ptop);\n\t}\n\n\t//for gcosxc.c\nextern (C)  void _d_gc_removerange(ук pbot)\n\t{\n\t\t_см.удалиПространство(pbot);\n\t}\n\n\nextern (C) void setTypeInfo(TypeInfo ti, ук  укз)\n\t{\n\ttry{\n\t\tif (ti.flags() & 1)\n\t\t_см.нетУказателей(укз);\n\t\telse\n\t\t_см.естьУказатели(укз);\n\t\t}\n\tcatch(Исключение искл)\n\t\t{\n\t\tdebug(TypeInfo) искл.выведи;\n\t\t_см.нетУказателей(укз);\n\t\t}\n\t}\n\nextern (C) ук  getGCHandle()\n\t{\n\t\treturn адаптВыхУкз(&_см);\n\t}\n\nextern (C) void setGCHandle(ук  укз)\n\t{\n\t\tук  oldp = getGCHandle();\n\t\tт_см g = cast(т_см)укз;\n\t\t\n\n\t\t// Add our static data to the new gc\n\t\t_см.сканируйСтатДан(g);\n\n\t\t_см = g;\n\t//    return oldp;\n\t}\n\nextern (C) void endGCHandle()\n\t{\n\t\t_см.отсканируйСтатДан(_см);\n\t}\n\nextern (C) void gc_init()\n\t{\n\t\t\tук укз;\n\t\t\t\tИнфОКлассе ci = СМ.classinfo;\n\n\t\t\t\tукз = cidrus.празмести(ci.init.length);\n\t\t\t\t(cast(byte*)укз)[0 .. ci.init.length] = ci.init[];\n\t\t\t\t_см = cast(т_см)  укз;\n\t\t\t\t_см.иниц();\n\t\t\t\t_см.сканируйСтатДан( _см);\n\t\t\t\tнить_иниц();\t\t\t\n\t}\n\nextern (C) void gc_term()\n\t{\n\t\t_см.полныйСборБезСтэка(); \t\t\t\t\t\t\t\t\t\n\t\t_см.Дтор();\n\t\t\n\t}\n\n void new_finalizer(ук укз, bool dummy)\n\t{\n\t\t//эхо(\"new_finalizer(укз = %укз)\\n\", укз);\n\t\t_d_callfinalizer(укз);\n\t}\n\n\t extern (C) void _d_callinterfacefinalizer(ук укз)\n\t{\n\t\t//эхо(\"_d_callinterfacefinalizer(укз = %укз)\\n\", укз);\n\t\tif (укз)\n\t\t{\n\t\tInterface *pi = **cast(Interface ***)укз;\n\t\tObject o = cast(Object)(укз - pi.offset);\n\t\t_d_callfinalizer(cast(ук )o);\n\t\t}\n\t}\n\n\n\t extern (C)  size_t gc_newCapacity(size_t новдлин, size_t size)\n\t{\n\t\tversion(none)\n\t\t{\n\t\tsize_t новёмксть = новдлин * size;\n\t\t}\n\t\telse\n\t\t{\n\n\t\tsize_t новёмксть = новдлин * size;\n\t\tsize_t newext = 0;\n\n\t\tif (новёмксть > 4096)\n\t\t{\n\t\t\t//double mult2 = 1.0 + (size / log10(pow(новёмксть * 2.0,2.0)));\n\n\t\t\t// Redo above line using only integer math\n\n\t\t\tstatic int log2plus1(size_t c)\n\t\t\t{   int i;\n\n\t\t\tif (c == 0)\n\t\t\t\ti = -1;\n\t\t\telse\n\t\t\t\tfor (i = 1; c >>= 1; i++)\n\t\t\t\t{   }\n\t\t\treturn i;\n\t\t\t}\n\n\t\t\t/* The following setting for mult sets how much bigger\n\t\t\t * the new size will be over what is actually needed.\n\t\t\t * 100 means the same size, more means proportionally more.\n\t\t\t * More means faster but more memory consumption.\n\t\t\t */\n\t\t\t//long mult = 100 + (1000L * size) / (6 * log2plus1(новёмксть));\n\t\t\tlong mult = 100 + (1000L * size) / log2plus1(новёмксть);\n\n\t\t\t// testing shows 1.02 for large arrays is about the point of diminishing return\n\t\t\tif (mult < 102)\n\t\t\tmult = 102;\n\t\t\tnewext = cast(size_t)((новёмксть * mult) / 100);\n\t\t\tnewext -= newext % size;\n\t\t\t//эхо(\"mult: %2.2f, mult2: %2.2f, alloc: %2.2f\\n\",mult/100.0,mult2,newext / cast(double)size);\n\t\t}\n\t\tновёмксть = newext > новёмксть ? newext : новёмксть;\n\t\t//эхо(\"новёмксть = %d, новдлин = %d, size = %d\\n\", новёмксть, новдлин, size);\n\t\t}\n\t\treturn новёмксть;\n\t}\n\n\n\t/**\n\t * Append dchar to char[]\n\t */\n\t extern (C)  char[] _d_arrayappendcd(inout char[] x, dchar c)\n\t{\n\t\tconst размэлта = c.sizeof;            // array element size\n\t\tauto ёмксть = _см.ёмкость(адаптВхоУкз(x.ptr));\n\t\tauto длина = x.length;\n\n\t\t// c could encode into from 1 to 4 characters\n\t\tint члосим;\n\t\tif (c <= 0x7F)\n\t\t\tчлосим = 1;\n\t\telse if (c <= 0x7FF)\n\t\t\tчлосим = 2;\n\t\telse if (c <= 0xFFFF)\n\t\t\tчлосим = 3;\n\t\telse if (c <= 0x10FFFF)\n\t\t\tчлосим = 4;\n\t\telse\n\t\tassert(0, \"Символ УТФ неверен\");\t// invalid utf character - should we throw an exception instead?\n\n\t\tauto новдлин = длина + члосим;\n\t\tauto новразм = новдлин * размэлта;\n\t\t\n\t\tdebug(НА_КОНСОЛЬ) эхо(\"_d_arrayappendcd(elemSize = %d, ptr = %ptr, length = %d, Capacity = %d)\\n\", размэлта, x.ptr, x.length, ёмксть);\n\n\t\tassert(ёмксть == 0 || длина * размэлта <= ёмксть, \"Произведение длины на размер элемента больше ёмкости памяти, \\nвыделенной сборщиком мусора под текстовый массив \"~x);\n\n\t\tif (ёмксть <= новразм)\n\t\t{   byte* newdata;\n\n\t\tif (ёмксть >= 4096)\n\t\t{   // Try to extend in-place\n\t\t\tauto u = _см.расширь(x.ptr, (новразм + 1) - ёмксть, (новразм + 1) - ёмксть);\n\t\t\tif (u)\n\t\t\t{\n\t\t\tgoto L1;\n\t\t\t}\n\t\t}\n\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"_d_arrayappendcd(length = %d, новдлин = %d, ёмксть = %d)\\n\", длина, новдлин, ёмксть);\n\t\t\tauto новёмксть = gc_newCapacity(новдлин, размэлта);\n\t\t\tassert(новёмксть >= новдлин * размэлта);\n\t\t\tnewdata = cast(byte *)_см.празмести(новёмксть + 1);\n\t\t_см.нетУказателей(newdata);\n\t\t\tcidrus.memcpy(newdata, x.ptr, длина * размэлта);\n\t\t\t(cast(ук *)(&x))[1] = newdata;\n\t\t}\n\t  L1:\n\t\t*cast(size_t *)&x = новдлин;\n\t\tchar* ptr = &x.ptr[длина];\n\n\t\tif (c <= 0x7F)\n\t\t{\n\t\t\tptr[0] = cast(char) c;\n\t\t}\n\t\telse if (c <= 0x7FF)\n\t\t{\n\t\t\tptr[0] = cast(char)(0xC0 | (c >> 6));\n\t\t\tptr[1] = cast(char)(0x80 | (c & 0x3F));\n\t\t}\n\t\telse if (c <= 0xFFFF)\n\t\t{\n\t\t\tptr[0] = cast(char)(0xE0 | (c >> 12));\n\t\t\tptr[1] = cast(char)(0x80 | ((c >> 6) & 0x3F));\n\t\t\tptr[2] = cast(char)(0x80 | (c & 0x3F));\n\t\t}\n\t\telse if (c <= 0x10FFFF)\n\t\t{\n\t\t\tptr[0] = cast(char)(0xF0 | (c >> 18));\n\t\t\tptr[1] = cast(char)(0x80 | ((c >> 12) & 0x3F));\n\t\t\tptr[2] = cast(char)(0x80 | ((c >> 6) & 0x3F));\n\t\t\tptr[3] = cast(char)(0x80 | (c & 0x3F));\n\t\t}\n\t\telse\n\t\tassert(0);\n\n\t\tassert((cast(size_t)x.ptr & 15) == 0);\n\t\tassert(_см.ёмкость(x.ptr) > x.length * размэлта);\n\t\treturn x;\n\t}\n\n\n\t/**\n\t * Append dchar to wchar[]\n\t */\n\t extern (C)  wchar[] _d_arrayappendwd(inout wchar[] x, dchar c)\n\t{\n\t\tconst размэлта = c.sizeof;            // array element size\n\t\tauto ёмксть = _см.ёмкость(x.ptr);\n\t\tauto length = x.length;\n\n\t\t// c could encode into from 1 to 2 w characters\n\t\tint члосим;\n\t\tif (c <= 0xFFFF)\n\t\t\tчлосим = 1;\n\t\telse\n\t\t\tчлосим = 2;\n\n\t\tauto новдлин = length + члосим;\n\t\tauto новразм = новдлин * размэлта;\n\n\t\tassert(ёмксть == 0 || length * размэлта <= ёмксть);\n\n\t\tdebug(НА_КОНСОЛЬ) эхо(\"_d_arrayappendwd(размэлта = %d, ptr = %укз, length = %d, ёмксть = %d)\\n\", размэлта, x.ptr, x.length, ёмксть);\n\n\t\tif (ёмксть <= новразм)\n\t\t{   byte* newdata;\n\n\t\tif (ёмксть >= 4096)\n\t\t{   // Try to extend in-place\n\t\t\tauto u = _см.расширь(x.ptr, (новразм + 1) - ёмксть, (новразм + 1) - ёмксть);\n\t\t\tif (u)\n\t\t\t{\n\t\t\tgoto L1;\n\t\t\t}\n\t\t}\n\n\t\t\tdebug(НА_КОНСОЛЬ) эхо(\"_d_arrayappendwd(length = %d, новдлин = %d, ёмксть = %d)\\n\", length, новдлин, ёмксть);\n\t\t\tauto новёмксть = gc_newCapacity(новдлин, размэлта);\n\t\t\tassert(новёмксть >= новдлин * размэлта);\n\t\t\tnewdata = cast(byte *)_см.празмести(новёмксть + 1);\n\t\t_см.нетУказателей(newdata);\n\t\t\tcidrus.memcpy(newdata, x.ptr, length * размэлта);\n\t\t\t(cast(ук *)(&x))[1] = newdata;\n\t\t}\n\t  L1:\n\t\t*cast(size_t *)&x = новдлин;\n\t\twchar* ptr = &x.ptr[length];\n\n\t\tif (c <= 0xFFFF)\n\t\t{\n\t\t\tptr[0] = cast(wchar) c;\n\t\t}\n\t\telse\n\t\t{\n\t\tptr[0] = cast(wchar) ((((c - 0x10000) >> 10) & 0x3FF) + 0xD800);\n\t\tptr[1] = cast(wchar) (((c - 0x10000) & 0x3FF) + 0xDC00);\n\t\t}\n\n\t\tassert((cast(size_t)x.ptr & 15) == 0);\n\t\tassert(_см.ёмкость(x.ptr) > x.length * размэлта);\n\t\treturn x;\n\t}\n\n\n\t/**********************************\n\t * Support for array.dup property.\n\t */\n\n extern (C) uint gc_getAttr( ук  укз )\n\t{\t\t\n        return _см.дайАтр( укз );  \n\t}\n\n extern (C) uint gc_setAttr( ук  укз, uint a )\n\t{\n\t\treturn _см.устАтр( укз, cast(ПАтрБлока) a );   \n\t}\n\nextern (C) uint gc_clrAttr( ук  укз, uint a )\n\t{\n\t\t return _см.удалиАтр( укз, cast(ПАтрБлока) a );\n\t}\n\nextern (C) ук  gc_malloc( size_t разм, uint ba = 0 )\n\t{\t    \n        return адаптВыхУкз(_см.празмести( разм, ba ));    \n\t}\n\n\t extern (C) ук  gc_calloc( size_t разм, uint ba = 0 )\n\t{\t\t\n        return адаптВыхУкз(_см.кразмести( разм, ba ));    \n\t}\n\n\t extern (C) ук  gc_realloc( ук  укз, size_t разм, uint ba = 0 )\n\t{\n\t        return адаптВыхУкз(_см.перемести( укз, разм, ba ));   \n\t}\n\n\t extern (C) size_t gc_extend( ук  укз, size_t mx, size_t разм )\n\t{\t\t\n        return _см.расширь( укз, mx, разм );   \n\t}\n\n\t extern (C) size_t gc_reserve( size_t разм )\n\t{\t\t\n        return _см.резервируй( разм );   \n\t}\n\n\t extern (C) void gc_free( ук  укз )\n\t{\t\t\n        _см.освободи( укз );\n \t}\n\n\t extern (C) ук  gc_addrOf( ук  укз )\n\t{\t\t\n        return адаптВыхУкз(_см.адрес_у( укз ));    \n\t}\n\n\t extern (C) size_t gc_sizeOf( ук  укз )\n\t{\t\t\n        return _см.размер_у( укз );   \n\t}\n\n\t extern (C) ук  gc_weakpointerCreate( Object r )\n\t{\n\t\treturn адаптВыхУкз(_см.создайСлабУк(r));\t\t\n\t}\n\n\t extern (C) void gc_weakpointerDestroy( ук  wp )\n\t{\n\t\t_см.удалиСлабУк(wp);\t\n\t}\n\n\t extern (C) Object gc_weakpointerGet( ук  wp )\n\t{\t\n\t\treturn _см.дайСлабУк(wp);\n\t}\n\n\t extern (C) BlkInfo gc_query( ук  укз )\n\t{\n\t        return cast(BlkInfo) _см.опроси( укз );   \n\t}\n\nextern (C) void gc_enable()\n\t{\n\t_см.вкл();\n\t}\n\nextern (C) void gc_disable()\n\t{\n\t_см.откл();\n\t}\n\nextern (C) void gc_collect()\n\t{\n\t _см.собери();\n\t}\n\nextern (C) проц setFinalizer(ук укз, GC_FINALIZER pFn)\n\t{\t\n      \t_см.устФинализатор(укз, pFn);\t\n\t}\n\n\nextern (C) void gc_printStats(gc_t gc)\n{\nСМСтат стат;\ngc.дайСтат(стат);\nскажинс(фм(\"\n\nИНФО О СОСТОЯНИИ СМ:\n#размер пула = x%x,\n#используемый размер = x%x,\n#размер списка очистки = x%x,\n#блоков очистки = %d,\n#блоков страниц = %d\\n\n\n\",\n\t\tстат.размерПула, стат.испРазмер, стат.размСпискаСвобБлоков, стат.свобБлоки, стат.блокиСтр));\n}\n\nextern (C) bool rt_isHalting()\n{\n    return задержка_ли;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n/+ Текст из CRITICAL.c Задача: ---Переделать в Динрус---\n\n/*\n * Placed into the Public Domain\n * written by Walter Bright, Digital Mars\n * www.digitalmars.com\n */\n\n/* ================================= Win32 ============================ */\n\n#if _WIN32\n\n#include\t<windows.h>\n\n/******************************************\n * Enter/exit critical section.\n */\n\n/* Критические секции не инициализируются без нужды в этом.\n * Поэтому сохраняется линкованный список используемых секций.\n * В коде статического деструктора список обходится и\n * указанные в нём критические секции освобождаются.\n */\n\ntypedef struct D_CRITICAL_SECTION\n{\n    struct D_CRITICAL_SECTION *next;\n    CRITICAL_SECTION cs;\n} D_CRITICAL_SECTION;\n\nstatic D_CRITICAL_SECTION *dcs_list;\nstatic D_CRITICAL_SECTION critical_section;\nstatic volatile int inited;\n\n/*__declspec(dllexport)*/ void _d_criticalenter(D_CRITICAL_SECTION *dcs)\n{\n    if (!dcs->next)\n    {\n\tEnterCriticalSection(&critical_section.cs);\n\tif (!dcs->next)\t// if, in the meantime, another thread didn't set it\n\t{\n\t    dcs->next = dcs_list;\n\t    dcs_list = dcs;\n\t    InitializeCriticalSection(&dcs->cs);\n\t}\n\tLeaveCriticalSection(&critical_section.cs);\n    }\n    EnterCriticalSection(&dcs->cs);\n}\n\n/*__declspec(dllexport)*/ void _d_criticalexit(D_CRITICAL_SECTION *dcs)\n{\n    LeaveCriticalSection(&dcs->cs);\n}\n\n/*__declspec(dllexport)*/ void _STI_critical_init()\n{\n    if (!inited)\n    {\tInitializeCriticalSection(&critical_section.cs);\n\tdcs_list = &critical_section;\n\tinited = 1;\n    }\n}\n\n/*__declspec(dllexport)*/ void _STD_critical_term()\n{\n    if (inited)\n    {\tinited = 0;\n\twhile (dcs_list)\n\t{\n\t    DeleteCriticalSection(&dcs_list->cs);\n\t    dcs_list = dcs_list->next;\n\t}\n    }\n}\n\n#endif\n\n/* ================================= linux ============================ */\n\n#if linux || __APPLE__ || __FreeBSD__ || __sun&&__SVR4\n\n#include\t<stdio.h>\n#include\t<stdlib.h>\n#include\t<pthread.h>\n\n// PTHREAD_MUTEX_RECURSIVE is the \"standard\" symbol,\n#if linux || __APPLE__\n// while the _NP version is specific to Linux\n#ifndef PTHREAD_MUTEX_RECURSIVE\n#    define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP\n#endif\n#endif\n\n/******************************************\n * Enter/exit critical section.\n */\n\n/* We don't initialize critical sections unless we actually need them.\n * So keep a linked list of the ones we do use, and in the static destructor\n * code, walk the list and release them.\n */\n\ntypedef struct D_CRITICAL_SECTION\n{\n    struct D_CRITICAL_SECTION *next;\n    pthread_mutex_t cs;\n} D_CRITICAL_SECTION;\n\nstatic D_CRITICAL_SECTION *dcs_list;\nstatic D_CRITICAL_SECTION critical_section;\nstatic pthread_mutexattr_t _criticals_attr;\n\nvoid _STI_critical_init(void);\nvoid _STD_critical_term(void);\n\nvoid _d_criticalenter(D_CRITICAL_SECTION *dcs)\n{\n    if (!dcs_list)\n    {\t_STI_critical_init();\n\tatexit(_STD_critical_term);\n    }\n    //printf(\"_d_criticalenter(dcs = x%x)\\n\", dcs);\n    if (!dcs->next)\n    {\n\tpthread_mutex_lock(&critical_section.cs);\n\tif (!dcs->next)\t// if, in the meantime, another thread didn't set it\n\t{\n\t    dcs->next = dcs_list;\n\t    dcs_list = dcs;\n\t    pthread_mutex_init(&dcs->cs, &_criticals_attr);\n\t}\n\tpthread_mutex_unlock(&critical_section.cs);\n    }\n    pthread_mutex_lock(&dcs->cs);\n}\n\nvoid _d_criticalexit(D_CRITICAL_SECTION *dcs)\n{\n    //printf(\"_d_criticalexit(dcs = x%x)\\n\", dcs);\n    pthread_mutex_unlock(&dcs->cs);\n}\n\nvoid _STI_critical_init()\n{\n    if (!dcs_list)\n    {\t//printf(\"_STI_critical_init()\\n\");\n\tpthread_mutexattr_init(&_criticals_attr);\n\tpthread_mutexattr_settype(&_criticals_attr, PTHREAD_MUTEX_RECURSIVE);\n\n\t// The global critical section doesn't need to be recursive\n\tpthread_mutex_init(&critical_section.cs, 0);\n\tdcs_list = &critical_section;\n    }\n}\n\nvoid _STD_critical_term()\n{\n    if (dcs_list)\n    {\t//printf(\"_STI_critical_term()\\n\");\n\twhile (dcs_list)\n\t{\n\t    //printf(\"\\tlooping... %x\\n\", dcs_list);\n\t    pthread_mutex_destroy(&dcs_list->cs);\n\t    dcs_list = dcs_list->next;\n\t}\n    }\n}\n\n#endif\n\n\n+/",
			"file": "runtime.d",
			"file_size": 49134,
			"file_write_time": 131266929177026029,
			"settings":
			{
				"buffer_size": 35481,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "module stdrus;\n\nprivate import  exception, runtime;\nprivate import tpl.args, tpl.stream;\n\nimport std.base64, std.bitarray, std.path, std.string /*rt.console*/;\n\n\n//debug = РегВыр;\n//debug = Нить;\nimport std.io;\n\n\nextern(Windows) бцел mciSendCommandA(бцел, бцел, бцел, бцел);\n\n\t\nбцел винВерсия;\t\n\t\nstatic this()\n\t{\t\n\tвинВерсия = win.ДайВерсию();\n\t\n\tВИНСОКДАН вд;\n\n\t\tцел знач;\n\t\tзнач = ВСАСтарт(0x2020, &вд);\n\t\tif(знач) // Request Winsock 2.2 for IPv6.\n\t\t\tthrow new СокетИскл(\"Не удалось инициализовать библиотеку сокетов\", знач);\n\t}\n\t\n\t\n\t        static ~this()\n        {\n                ВСАЧистка();\n        }\n\t\t\n\nconst т_время т_время_нч = cast(т_время) дол.min;\ntypedef бцел ФВремяДос;\n//typedef сим рсим;\n//typedef ткст рткст;\n\n//alias сим рсим;\n//alias ткст рткст;\n\nstruct т_регсвер\n{\n    цел рснач;\t\t\t// индекс начала совпадения\n    цел рскон;\t\t\t// индекс по завершению совпадения\n}\n\nexport extern(D) class Модуль\n{\n\nexport:\n\nprivate  ук м_укМодуль;\n\n\tthis(ук умодуль, бул овладеть)\n\t\n\t\tin\n\t\t{\n\t\t\tassert(null !is умодуль);\n\t\t}\n\t\tbody\n\t\t{\n\t\t\tif(овладеть)\n\t\t\t{\n\t\t\t\tм_укМодуль = адаптВхоУкз(умодуль);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t\n\t\t\tткст путь = Путь();\n\t\t\tм_укМодуль = cast(ук)ЗагрузиБиблиотекуА(путь);\n\t\t\tif (м_укМодуль == null)\n\t\t\t\tthrow new ИсклВнешнМодуля(ДайПоследнююОшибку());\n\t\t\t}\n\t\t}\n\t\n\t\n\tthis(ткст имяМодуля)\n\t\n\t\tin\n\t\t{\n\t\t\tassert(null !is имяМодуля);\n\t\t}\n\t\tbody\n\t\t{\n\t\tм_укМодуль = cast(ук) ЗагрузиБиблиотекуА(имяМодуля);\n\t\t\tif (null is м_укМодуль)\n\t\t\tthrow new ИсклВнешнМодуля(ДайПоследнююОшибку());\n\t\t}\n\t\n\t\n\t~this()\n    {\n        закрой();\n    }\n\t\n\t\n\tпроц закрой()\n\t{\n\t\tif(null !is м_укМодуль)\n        {\n\t\tif(!ОсвободиБиблиотеку(м_укМодуль))\n\t\t    throw new ИсклВнешнМодуля(ДайПоследнююОшибку());\n\t\t}\n\t}\n\t\n\tук дайСимвол(in ткст симв)\n\tin\n\t{\n\t\tassert(симв !is null);\t\t\n\t}\n\tbody\n\t{\n\tук символ = cast(ук) ДайАдресПроц(м_укМодуль, симв);\n\t    if(null is символ)\n\t    {\n\t\tthrow new ИсклВнешнМодуля(ДайПоследнююОшибку());\n\t    }\n\treturn адаптВыхУкз(символ);\n\t}\n\t\n\tук найдиСимвол(in ткст симв)\n\t{\n\treturn адаптВыхУкз(дайСимволИМодуля(м_укМодуль, симв));\n\t}\n\t\n\tук Ук()\n\t{\n\treturn адаптВыхУкз(м_укМодуль);\n\t}\n\t\n\tткст Путь()\n\t{\n\tassert(null != м_укМодуль);\n\t\n\tткст имяФ = new сим[260];\n\t\n\tбцел cch = ДайИмяФайлаМодуляА(м_укМодуль, &имяФ, имяФ.length);\n\t    if (cch == 0)\n\t\tthrow new ИсклВнешнМодуля(ДайПоследнююОшибку());\n\n\t    return имяФ[0 .. cch].dup;\n\t\n\t}\n}//end of class\n\nexport extern(D)\n{\n\tпроц инфо(ткст сооб)\n\t\t\t{\n\t\t\tОкноСооб(null, toUTF16(сооб), \"Сообщение Динрус\", ПСооб.Инфо|ПСооб.Поверх);\n\t\t\t}\n\n\timport std.md5;\n\n\tпроц суммаМД5(ббайт[16] дайджест, проц[] данные){std.md5.sum(дайджест, данные);}\n\tпроц выведиМД5Дайджест(ббайт дайджест[16]){std.md5.printDigest(дайджест);}\n\tткст дайджестМД5вТкст(ббайт[16] дайджест){return std.md5.digestToString(дайджест);}\n\n\timport rt.syserror;\n\n\tткст текстСисОшибки(бцел кодош){return  rt.syserror.sysErrorString(кодош);}\n\n\timport std.loader;\n\n\tцел иницМодуль(){return std.loader.ExeModule_Init();}\n\tпроц деиницМодуль(){return std.loader.ExeModule_Uninit();}\n\tук загрузиМодуль(in ткст имямод){return cast(ук) адаптВыхУкз(std.loader.ExeModule_Load(имямод));}\n\tук добавьСсылНаМодуль(ук умодуль){return cast(ук) std.loader.ExeModule_AddRef(cast(HXModule) умодуль);}\n\tпроц отпустиМодуль(inout ук умодуль){return std.loader.ExeModule_Release(cast(HXModule) умодуль);}\n\tук дайСимволИМодуля(inout ук умодуль, in ткст имяСимвола){return std.loader.ExeModule_GetSymbol(cast(HXModule) умодуль, имяСимвола);}\n\tткст ошибкаИМодуля(){return std.loader.ExeModule_Error();}\t\n\n\n\timport std.intrinsic;\n\n\tцел пуб(бцел х){return std.intrinsic.bsf(х);}//Поиск первого установленного бита (узнаёт его номер)\n\tцел пубр(бцел х){return std.intrinsic.bsr(х);}//Поиск первого установленного бита (от старшего к младшему)\n\tцел тб(in бцел *х, бцел номбит){return std.intrinsic.bt(х, номбит);}//Тест бит\n\tцел тбз(бцел *х, бцел номбит){return std.intrinsic.btc(х, номбит);}// тест и заполнение\n\tцел тбп(бцел *х, бцел номбит){return std.intrinsic.btr(х, номбит);}// тест и переустановка\n\tцел тбу(бцел *х, бцел номбит){return std.intrinsic.bts(х, номбит);}// тест и установка\n\tбцел развербит(бцел б){return std.intrinsic.bswap(б);}//Развернуть биты в байте\n\tббайт чипортБб(бцел адр_порта){return std.intrinsic.inp(адр_порта);}//читает порт ввода с указанным адресом\n\tбкрат чипортБк(бцел адр_порта){return std.intrinsic.inpw(адр_порта);}\n\tбцел чипортБц(бцел адр_порта){return std.intrinsic.inpl(адр_порта);}\n\tббайт пипортБб(бцел адр_порта, ббайт зап){return std.intrinsic.outp(адр_порта, зап);}//пишет в порт вывода с указанным адресом\n\tбкрат пипортБк(бцел адр_порта, бкрат зап){return std.intrinsic.outpw(адр_порта, зап);}\n\tбцел пипортБц(бцел адр_порта, бцел зап){return std.intrinsic.outpl(адр_порта, зап);}\n\tцел члоустбит32( бцел x )\n\t{\n\t\tx = x - ((x>>1) & 0x5555_5555);\n\t\tx = ((x&0xCCCC_CCCC)>>2) + (x&0x3333_3333);\n\t\tx += (x>>4);\n\t\tx &= 0x0F0F_0F0F;\n\t\tx += (x>>8);\n\t\tx &= 0x00FF_00FF;\n\t\tx += (x>>16);\n\t\tx &= 0xFFFF;\n\t\treturn x;\n\t}\n\n\tбцел битсвоп( бцел x )\n\t{\n\n\t\tversion( D_InlineAsm_X86 )\n\t\t{\n\t\t\tasm\n\t\t\t{\n\t\t\t\t// Author: Tiago Gasiba.\n\t\t\t\tmov EDX, EAX;\n\t\t\t\tshr EAX, 1;\n\t\t\t\tand EDX, 0x5555_5555;\n\t\t\t\tand EAX, 0x5555_5555;\n\t\t\t\tshl EDX, 1;\n\t\t\t\tor  EAX, EDX;\n\t\t\t\tmov EDX, EAX;\n\t\t\t\tshr EAX, 2;\n\t\t\t\tand EDX, 0x3333_3333;\n\t\t\t\tand EAX, 0x3333_3333;\n\t\t\t\tshl EDX, 2;\n\t\t\t\tor  EAX, EDX;\n\t\t\t\tmov EDX, EAX;\n\t\t\t\tshr EAX, 4;\n\t\t\t\tand EDX, 0x0f0f_0f0f;\n\t\t\t\tand EAX, 0x0f0f_0f0f;\n\t\t\t\tshl EDX, 4;\n\t\t\t\tor  EAX, EDX;\n\t\t\t\tbswap EAX;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx = ((x >> 1) & 0x5555_5555) | ((x & 0x5555_5555) << 1);\n\t\t\tx = ((x >> 2) & 0x3333_3333) | ((x & 0x3333_3333) << 2);\n\t\t\tx = ((x >> 4) & 0x0F0F_0F0F) | ((x & 0x0F0F_0F0F) << 4);\n\t\t\tx = ((x >> 8) & 0x00FF_00FF) | ((x & 0x00FF_00FF) << 8);\n\t\t\tx = ( x >> 16              ) | ( x               << 16);\n\t\t\treturn x;\n\n\t\t}\n\t}\n}///extern Windows\n\n\nexport extern(D) struct ПерестановкаБайт\n{\nexport:\n\n        final static проц своп16 (проц[] приёмн)\n        {\n                своп16 (приёмн.ptr, приёмн.length);\n        }\n\n\n        final static проц своп32 (проц[] приёмн)\n        {\n                своп32 (приёмн.ptr, приёмн.length);\n        }\n\n\n        final static проц своп64 (проц[] приёмн)\n        {\n                своп64 (приёмн.ptr, приёмн.length);\n        }\n\n\n        final static проц своп80 (проц[] приёмн)\n        {\n                своп80 (приёмн.ptr, приёмн.length);\n        }\n\n\n        final static проц своп16 (проц *приёмн, бцел байты)\n        {\n                assert ((байты & 0x01) is 0);\n\n                auto p = cast(ббайт*) приёмн;\n                while (байты)\n                      {\n                      ббайт b = p[0];\n                      p[0] = p[1];\n                      p[1] = b;\n\n                      p += крат.sizeof;\n                      байты -= крат.sizeof;\n                      }\n        }\n\n\n        final static проц своп32 (проц *приёмн, бцел байты)\n        {\n                assert ((байты & 0x03) is 0);\n\n                auto p = cast(бцел*) приёмн;\n                while (байты)\n                      {\n                      *p = bswap(*p);\n                      ++p;\n                      байты -= цел.sizeof;\n                      }\n        }\n\n\n        final static проц своп64 (проц *приёмн, бцел байты)\n        {\n                assert ((байты & 0x07) is 0);\n\n                auto p = cast(бцел*) приёмн;\n                while (байты)\n                      {\n                      бцел i = p[0];\n                      p[0] = bswap(p[1]);\n                      p[1] = bswap(i);\n\n                      p += (дол.sizeof / цел.sizeof);\n                      байты -= дол.sizeof;\n                      }\n        }\n\n\n        final static проц своп80 (проц *приёмн, бцел байты)\n        {\n                assert ((байты % 10) is 0);\n               \n                auto p = cast(ббайт*) приёмн;\n                while (байты)\n                      {\n                      ббайт b = p[0];\n                      p[0] = p[9];\n                      p[9] = b;\n\n                      b = p[1];\n                      p[1] = p[8];\n                      p[8] = b;\n\n                      b = p[2];\n                      p[2] = p[7];\n                      p[7] = b;\n\n                      b = p[3];\n                      p[3] = p[6];\n                      p[6] = b;\n\n                      b = p[4];\n                      p[4] = p[5];\n                      p[5] = b;\n\n                      p += 10;\n                      байты -= 10;\n                      }\n        }\n}///end of struct\n\ntypedef extern (D) ткст function(дим) Обрвызов_диэксп_Дим;\n\nexport extern(D)\n{\t\n\n\tбул вОбразце(дим с, ткст образец){return cast(бул) std.string.inPattern(с, образец);}\n\tбул вОбразце(дим с, ткст[] образец){return cast(бул) std.string.inPattern(с, образец);}\n\t\n\tпроц пишиф(...)/////\n\t{\n\tauto args = _arguments;\n\tstd.io.writefx( cidrus.стдвых, _arguments, _argptr, 0);\n\t}\n\n\tпроц пишифнс(...)//////\n\t{\n\tstd.io.writefx( cidrus.стдвых, _arguments, _argptr, 1);\n\t}\n\t\n\tпроц скажифнс(...)//////\n\t{\n\tauto args = _arguments;\n    auto argptr = _argptr;\n   // ткст fmt = null;\n    //разборСпискаАргументов(args, argptr, fmt);\n\t\n    ткст т;\n\n    проц putc(дим c)\n    {\n\tstd.utf.encode(т, c);\n    }\n\n\t\tформатДелай(&putc, args, argptr);\n\t\twin.скажинс(т);\n\t}\n\t\n\tпроц скажиф(...)///////\n\t{\n\tauto args = _arguments;\n    auto argptr = _argptr;\n   // ткст fmt = null;\n    //разборСпискаАргументов(args, argptr, fmt);\n\t\n    ткст т;\n\n    проц putc(дим c)\n    {\n\tstd.utf.encode(т, c);\n    }\n\n\t\tформатДелай(&putc, args, argptr);\n\t\twin.скажи(т);\n\t}\n\t\n\tпроц пишиф_в(cidrus.фук чф, ...)//////\n\t{\n\t\n\t\tstd.io.writefx( чф, _arguments, _argptr, 0);\n\t}\n\n\tпроц пишифнс_в(cidrus.фук чф, ...)///////\n\t{\n\t\tstd.io.writefx( чф, _arguments, _argptr, 1);\n\t}\n\t\n\tткст фм(...)//////\n\t{\n\tauto args = _arguments;\n    auto argptr = _argptr;\n   // ткст fmt = null;\n    //разборСпискаАргументов(args, argptr, fmt);\n\t\n    ткст т;\n\n    проц putc(дим c)\n    {\n\tstd.utf.encode(т, c);\n    }\n\n\t\tформатДелай(&putc, args, argptr);\n\t\treturn т;\n\t}\nalias фм форматируй;\n\t\n\tткст форматируйс(ткст т, ...)\n\t{   \n\t\n\tт_мера i;\n\n\t\tпроц putc(дим c)\n\t\t{\n\t\tif (c <= 0x7F)\n\t\t{\n\t\t\tif (i >= т.length)\n\t\t\tthrow new ГранМасОшиб(\"stdrus.форматируйс\", __LINE__);\n\t\t\tт[i] = cast(сим)c;\n\t\t\t++i;\n\t\t}\n\t\telse\n\t\t{   сим[4] буф;\n\t\t\tткст b;\n\n\t\t\tb = std.utf.toUTF8(буф, c);\n\t\t\tif (i + b.length > т.length)\n\t\tthrow new ГранМасОшиб(\"stdrus.форматируйс\", __LINE__);\n\t\t\tт[i..i+b.length] = b[];\n\t\t\ti += b.length;\n\t\t}\n\t\t}\n\n\t\tформатДелай(&putc, _arguments, _argptr);\n\t\treturn т[0 .. i];\n\t}\n}/////extern D\n///////////////////////////////////////////////////\nexport extern(D)\n{\n\timport std.demangle;\n\n\tткст разманглируй(ткст имя){return std.demangle.demangle(имя);}\n\n\tбцел кодируйДлину64(бцел сдлин)\n\t\t{\n\t\treturn cast(бцел) encodeLength(cast(бцел) сдлин);\n\t\t}\n\tткст кодируй64(ткст стр, ткст буф = ткст.init)\n\t\t{\n\t\tif(буф)\treturn cast(ткст) std.base64.encode(cast(сим[]) стр, cast(сим[]) буф);\n\t\telse return cast(ткст) std.base64.encode(cast(сим[])стр);\n\t\t}\n\n\tбцел раскодируйДлину64(бцел кдлин)\n\t\t{\n\t\treturn cast(бцел) decodeLength(cast(бцел) кдлин);\n\t\t}\n\tткст раскодируй64(ткст кстр, ткст буф = ткст.init)\n\t\t{\n\t\tif(буф) return cast(ткст) std.base64.decode(cast(сим[]) кстр, cast(сим[]) буф);\n\t\telse return cast(ткст) std.base64.decode(cast(сим[]) кстр);\n\t\t}\n\nimport rt.charset;\n\n///////////////////////////////////////////////////////\nткст0 ю8Вин16н(ткст с, бцел кодСтр = 0)\n{\nreturn cast(усим) rt.charset.toMBSz(cast(char[]) с, cast(uint) кодСтр);\n}\n////////////////////////////////////////////////////////////\nткст вин16нЮ8(ткст0 с, цел кодСтр = 0)\n{\nreturn cast(сим[]) rt.charset.fromMBSz(cast(char*) с, cast(int) кодСтр);\n}\n////////////////////////////////////////////////////////////\n\tткст читайстр()\n\t{\n\t\tткст buf;\n\t\tstd.io.readln(cidrus.стдвхо, buf);\n\t\t return buf;\n\t\t/+\n\tбцел  mode, get;\n\tткст input[8];\n\t\n\tGetConsoleMode( ДайСтдДескр(ПСтд.Ввод), &mode );\n\tSetConsoleMode( ДайСтдДескр(ПСтд.Ввод), 0 );\n\tReadConsoleA( ДайСтдДескр(ПСтд.Ввод), input, 1, &get, NULL );\n\tSetConsoleMode( ДайСтдДескр(ПСтд.Ввод), mode );\n\treturn input[0];\n\t+/\n\t}\n\n\tт_мера читайстр(inout ткст буф)\n\t{\n\t/+\n\t\tDWORD i = буф.length / 4;\n\t\tconst Кф = -1;\n\t\tшим[] ввод = new шим [1024 * 1];\n\n                                   assert (i);\n\n                                   if (i > ввод.length)\n                                       i = ввод.length;\n                                       \n                                   // читай a chunk of wchars из_ the console\n                                   if (! ReadConsoleW (ДайСтдДескр(ПСтд.Ввод), ввод.ptr, i, &i, null))\n                                         exception.ошибка(\"Неудачное чтение консоли\");\n\n                                   // no ввод ~ go home\n                                   if (i is 0)\n                                       return Кф;\n\n                                   // translate в_ utf8, directly преобр_в приёмн\n                                   i = sys.WinFuncs.WideCharToMultiByte (65001, 0, ввод.ptr, i, \n                                                            cast(PCHAR) буф.ptr, буф.length, null, 0);\n                                   if (i is 0)\n                                       exception.ошибка (\"Неудачное преобразование консольного вввода\");\n\n                                   return i;\n\t\t\t\t\t\t\t\t   +/\n\t\treturn читайстр(cidrus.стдвхо, буф);\n\t\t\t\t\t\t\t\t   \n\t}\n\t\n\tт_мера читайстр(фук чф, inout ткст буф)\n\t{\t\n\treturn std.io.readln(чф, буф);\n\t}\n\n\tпроц скажи(ткст ткт){ win.скажи(ткт);}\n\tпроц скажинс(ткст ткт){ win.скажинс(ткт);}\n\tпроц скажи(бдол ткт){ win.скажи(ткт);}\n\tпроц скажинс(бдол ткт){ win.скажинс(ткт);}\n\n\tпроц нс(){win.нс();}\n\tпроц таб(){win.таб();}\t\n\t\n\timport std.ctype;\n\n\tцел числобукв_ли(дим б){return std.ctype.isalnum(б);}\n\tцел буква_ли(дим б){return  std.ctype.isalpha(б);}\n\tцел управ_ли(дим б){return std.ctype.iscntrl(б);}\n\tцел цифра_ли(дим б){return std.ctype.isdigit(б);}\n\tцел проп_ли(дим б){return std.ctype.islower(б);}\n\tцел пунктзнак_ли(дим б){return  std.ctype.ispunct(б);}\n\tцел межбукв_ли(дим б){return std.ctype.isspace(б);}\n\tцел заг_ли(дим б){return std.ctype.isupper(б);}\n\tцел цифраикс_ли(дим б){return std.ctype.isxdigit(б);}\n\tцел граф_ли(дим б){return  std.ctype.isgraph(б);}\n\tцел печат_ли(дим б) {return  std.ctype.isprint(б);}\n\tцел аски_ли(дим б){return  std.ctype.isascii(б);}\n\tдим впроп(дим б){return  std.ctype.tolower(б);}\n\tдим взаг(дим б){return std.ctype.toupper(б);}\n}//////////// extern C\n///////////////////////////////////////\nexport extern(D) struct МассивБит\n{\n    т_мера длин;\n    бцел* укз;\n\t\n\talias  укз ptr;\n\n\texport т_мера разм()\n\t{\n\treturn cast(т_мера) dim();\n\t}\n\t\n    т_мера dim()\n    {\n\treturn (длин + 31) / 32;\n    }\n\t\n\texport т_мера длина()\n\t{\n\treturn cast(т_мера) length();\n\t}\n\t\n    т_мера length()\n    {\n\treturn длин;\n    }\n\n\texport проц длина(т_мера новдлин)\n\t{\n\treturn length(новдлин);\n\t}\n\t\n    проц length(т_мера newlen)\n    {\n\tif (newlen != длин)\n\t{\n\t    т_мера olddim = dim();\n\t    т_мера newdim = (newlen + 31) / 32;\n\n\t    if (newdim != olddim)\n\t    {\n\t\t// Create a fake array so we can use D'т realloc machinery\n\t\tбцел[] b = ptr[0 .. olddim];\n\t\tb.length = newdim;\t\t// realloc\n\t\tptr = b.ptr;\n\t\tif (newdim & 31)\n\t\t{   // Уст any pad bits to 0\n\t\t    ptr[newdim - 1] &= ~(~0 << (newdim & 31));\n\t\t}\n\t    }\n\n\t    длин = newlen;\n\t}\n    }\n\n  export  бул opIndex(т_мера i)\n    in\n    {\n\tassert(i < длин);\n    }\n    body\n    {\n\treturn cast(бул)bt(ptr, i);\n    }\n\n    /** ditto */\n   export бул opIndexAssign(бул b, т_мера i)\n    in\n    {\n\tassert(i < длин);\n    }\n    body\n    {\n\tif (b)\n\t    bts(ptr, i);\n\telse\n\t    btr(ptr, i);\n\treturn b;\n    }\n\n   \n\texport МассивБит дубль()\n\t {\n\t return dup();\n\t }\n\t \n    МассивБит dup()\n    {\n\tМассивБит ba;\n\n\tбцел[] b = ptr[0 .. dim].dup;\n\tba.длин = длин;\n\tba.ptr = b.ptr;\n\treturn ba;\n    }\n\n   export цел opApply(цел delegate(inout бул) дг)\n    {\n\tцел результат;\n\n\tfor (т_мера i = 0; i < длин; i++)\n\t{   бул b = opIndex(i);\n\t    результат = дг(b);\n\t    (*this)[i] = b;\n\t    if (результат)\n\t\tbreak;\n\t}\n\treturn результат;\n    }\n\n  \n   export цел opApply(цел delegate(inout т_мера, inout бул) дг)\n    {\n\tцел результат;\n\n\tfor (т_мера i = 0; i < длин; i++)\n\t{   бул b = opIndex(i);\n\t    результат = дг(i, b);\n\t    (*this)[i] = b;\n\t    if (результат)\n\t\tbreak;\n\t}\n\treturn результат;\n    }\n\n\texport МассивБит реверсни()\n\t{\n\treturn  reverse();\n\t}\n\t\n    МассивБит reverse()\n\tout (результат)\n\t{\n\t    assert(результат == *this);\n\t}\n\tbody\n\t{\n\t    if (длин >= 2)\n\t    {\n\t\tбул t;\n\t\tт_мера lo, hi;\n\n\t\tlo = 0;\n\t\thi = длин - 1;\n\t\tfor (; lo < hi; lo++, hi--)\n\t\t{\n\t\t    t = (*this)[lo];\n\t\t    (*this)[lo] = (*this)[hi];\n\t\t    (*this)[hi] = t;\n\t\t}\n\t    }\n\t    return *this;\n\t}\n\n  \n\texport МассивБит сортируй()\n\t{\n\treturn sort();\n\t}\n\t\n    МассивБит sort()\n\tout (результат)\n\t{\n\t    assert(результат == *this);\n\t}\n\tbody\n\t{\n\t    if (длин >= 2)\n\t    {\n\t\tт_мера lo, hi;\n\n\t\tlo = 0;\n\t\thi = длин - 1;\n\t\twhile (1)\n\t\t{\n\t\t    while (1)\n\t\t    {\n\t\t\tif (lo >= hi)\n\t\t\t    goto Ldone;\n\t\t\tif ((*this)[lo] == да)\n\t\t\t    break;\n\t\t\tlo++;\n\t\t    }\n\n\t\t    while (1)\n\t\t    {\n\t\t\tif (lo >= hi)\n\t\t\t    goto Ldone;\n\t\t\tif ((*this)[hi] == нет)\n\t\t\t    break;\n\t\t\thi--;\n\t\t    }\n\n\t\t    (*this)[lo] = нет;\n\t\t    (*this)[hi] = да;\n\n\t\t    lo++;\n\t\t    hi--;\n\t\t}\n\t    Ldone:\n\t\t;\n\t    }\n\t    return *this;\n\t}\n\n    export цел opEquals(МассивБит a2)\n    {   цел i;\n\n\tif (this.length != a2.length)\n\t    return 0;\t\t// not equal\n\tбайт *p1 = cast(байт*)this.ptr;\n\tбайт *p2 = cast(байт*)a2.ptr;\n\tбцел n = this.length / 8;\n\tfor (i = 0; i < n; i++)\n\t{\n\t    if (p1[i] != p2[i])\n\t\treturn 0;\t\t// not equal\n\t}\n\n\tббайт маска;\n\n\tn = this.length & 7;\n\tмаска = cast(ббайт)((1 << n) - 1);\n\t//prцелf(\"i = %d, n = %d, маска = %x, %x, %x\\n\", i, n, маска, p1[i], p2[i]);\n\treturn (маска == 0) || (p1[i] & маска) == (p2[i] & маска);\n    }\n\n   export цел opCmp(МассивБит a2)\n    {\n\tбцел длин;\n\tбцел i;\n\n\tдлин = this.length;\n\tif (a2.length < длин)\n\t    длин = a2.length;\n\tббайт* p1 = cast(ббайт*)this.ptr;\n\tббайт* p2 = cast(ббайт*)a2.ptr;\n\tбцел n = длин / 8;\n\tfor (i = 0; i < n; i++)\n\t{\n\t    if (p1[i] != p2[i])\n\t\tbreak;\t\t// not equal\n\t}\n\tfor (бцел j = i * 8; j < длин; j++)\n\t{   ббайт маска = cast(ббайт)(1 << j);\n\t    цел c;\n\n\t    c = cast(цел)(p1[i] & маска) - cast(цел)(p2[i] & маска);\n\t    if (c)\n\t\treturn c;\n\t}\n\treturn cast(цел)this.длин - cast(цел)a2.length;\n    }\n\n\texport проц иниц(бул[] бм)\n\t{\n\tinit(cast(бул[]) бм);\n\t}\n\t\n    проц init(бул[] ba)\n    {\n\tlength = ba.length;\n\tforeach (i, b; ba)\n\t{\n\t    (*this)[i] = b;\n\t}\n    }\n\n\texport проц иниц(проц[] в, т_мера члобит)\n\t{\n\tinit(cast(проц[]) в, cast(т_мера) члобит);\n\t}\n\t\n    проц init(проц[] v, т_мера numbits)\n    in\n    {\n\tassert(numbits <= v.length * 8);\n\tassert((v.length & 3) == 0);\n    }\n    body\n    {\n\tptr = cast(бцел*)v.ptr;\n\tдлин = numbits;\n    }\n\n  export  проц[] opCast()\n    {\n\treturn cast(проц[])ptr[0 .. dim];\n    }\n\n    \n  export  МассивБит opCom()\n    {\n\tauto dim = this.dim();\n\n\tМассивБит результат;\n\n\tрезультат.length = длин;\n\tfor (т_мера i = 0; i < dim; i++)\n\t    результат.ptr[i] = ~this.ptr[i];\n\tif (длин & 31)\n\t    результат.ptr[dim - 1] &= ~(~0 << (длин & 31));\n\treturn результат;\n    }\n\n  export  МассивБит opAnd(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tМассивБит результат;\n\n\tрезультат.length = длин;\n\tfor (т_мера i = 0; i < dim; i++)\n\t    результат.ptr[i] = this.ptr[i] & e2.ptr[i];\n\treturn результат;\n    }\n\n    export МассивБит opOr(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tМассивБит результат;\n\n\tрезультат.length = длин;\n\tfor (т_мера i = 0; i < dim; i++)\n\t    результат.ptr[i] = this.ptr[i] | e2.ptr[i];\n\treturn результат;\n    }\n\n   export МассивБит opXor(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tМассивБит результат;\n\n\tрезультат.length = длин;\n\tfor (т_мера i = 0; i < dim; i++)\n\t    результат.ptr[i] = this.ptr[i] ^ e2.ptr[i];\n\treturn результат;\n    }\n\n  export  МассивБит opSub(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tМассивБит результат;\n\n\tрезультат.length = длин;\n\tfor (т_мера i = 0; i < dim; i++)\n\t    результат.ptr[i] = this.ptr[i] & ~e2.ptr[i];\n\treturn результат;\n    }\n\n   export МассивБит opAndAssign(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tfor (т_мера i = 0; i < dim; i++)\n\t    ptr[i] &= e2.ptr[i];\n\treturn *this;\n    }\n\n   export МассивБит opOrAssign(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tfor (т_мера i = 0; i < dim; i++)\n\t    ptr[i] |= e2.ptr[i];\n\treturn *this;\n    }\n\n   export МассивБит opXorAssign(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tfor (т_мера i = 0; i < dim; i++)\n\t    ptr[i] ^= e2.ptr[i];\n\treturn *this;\n    }\n\n   export МассивБит opSubAssign(МассивБит e2)\n    in\n    {\n\tassert(длин == e2.length);\n    }\n    body\n    {\n\tauto dim = this.dim();\n\n\tfor (т_мера i = 0; i < dim; i++)\n\t    ptr[i] &= ~e2.ptr[i];\n\treturn *this;\n    }\n\n    export МассивБит opCatAssign(бул b)\n    {\n\tlength = длин + 1;\n\t(*this)[длин - 1] = b;\n\treturn *this;\n    }\n\n   export МассивБит opCatAssign(МассивБит b)\n    {\n\tauto istart = длин;\n\tlength = длин + b.length;\n\tfor (auto i = istart; i < длин; i++)\n\t    (*this)[i] = b[i - istart];\n\treturn *this;\n    }\n\n   export МассивБит opCat(бул b)\n    {\n\tМассивБит r;\n\n\tr = this.dup;\n\tr.length = длин + 1;\n\tr[длин] = b;\n\treturn r;\n    }\n\n   export МассивБит opCat_r(бул b)\n    {\n\tМассивБит r;\n\n\tr.length = длин + 1;\n\tr[0] = b;\n\tfor (т_мера i = 0; i < длин; i++)\n\t    r[1 + i] = (*this)[i];\n\treturn r;\n    }\n\n  export  МассивБит opCat(МассивБит b)\n    {\n\tМассивБит r;\n\n\tr = this.dup();\n\tr ~= b;\n\treturn r;\n    }\n\n}/////end of class\n\nМассивБит вМасБит(std.bitarray.BitArray ба)\n\t{\n\tМассивБит рез;\n\tрез.длин = ба.длин;\n\tрез.укз = ба.ptr;\n\treturn  рез;\n\t}\n\t\nBitArray изМасБита(МассивБит мб)\n\t{\n\tstd.bitarray.BitArray рез;\n\tрез.длин = мб.длин;\n\tрез.ptr = мб.укз;\n\treturn  рез;\n\t}\n\n/*************************/\n////////////////////////////////////////////\nimport std.string, std.utf;\n\nexport extern(D)\n{\t/////////////////////////////////\n\tбул пробел_ли(дим т)\n\t{\n\treturn cast(бул)(std.string.iswhite(cast(дим) т));\n\t}\n\t/////////////////////////////\n\tдол ткствцел(ткст т)\n\t{\n\treturn cast(дол)(std.string.atoi(cast(сим[]) т));\n\t}\n\t/////////////////////////////////\n\tреал ткствдробь(ткст т)\n\t{\n\treturn cast(реал)(std.string.atof(cast(сим[]) т));\n\t}\n\t/////////////////////////////////////\n\tцел сравни(ткст s1, ткст s2)\n\t{\n\treturn cast(цел)(std.string.cmp(cast(сим[]) s1, cast(сим[]) s2));\n\t}\n\t///////////////////////////////////////\n\tцел сравнлюб(ткст s1, ткст s2)\n\t{\n\treturn cast(цел)(std.string.icmp(cast(сим[]) s1, cast(сим[]) s2));\n\t}\n\t/////////////////////////////////////////////\n\tсим* вТкст0(ткст т)\n\t{\n\treturn cast(сим*)(std.string.toStringz(cast(сим[]) т));\n\t}\n\t/////////////////////////////////////////////\n\tцел найди(ткст т, дим c)\n\t{\n\treturn cast(цел)(std.string.find(cast(сим[]) т, cast(дим) c));\n\t}\n\t/////////////////////////////////////////////////\n\tцел найдлюб(ткст т, дим c)\n\t{\n\treturn cast(цел)(std.string.ifind(cast(сим[]) т, cast(дим) c));\n\t}\n\t////////////////////////////////////////////////\n\tцел найдрек(ткст т, дим c)\n\t{\n\treturn cast(цел)(std.string.rfind(cast(сим[]) т, cast(дим) c));\n\t}\n\t///////////////////////////////////////////////\n\tцел найдлюбрек(ткст т, дим c)\n\t{\n\treturn cast(цел)(std.string.irfind(cast(сим[]) т, cast(дим) c));\n\t}\n\t/////////////////////////////////////////////////\n\tцел найди(ткст т, ткст тзам)\n\t{\n\treturn cast(цел)(std.string.find(cast(сим[]) т, cast(сим[]) тзам));\n\t}\n\t/////////////////////////////////////////////////\n\tцел найдлюб(ткст т, ткст тзам)\n\t{\n\treturn  cast(цел)(std.string.ifind(cast(сим[]) т, cast(сим[]) тзам));\n\t}\n\t/////////////////////////////////////////////////\n\tцел найдрек(ткст т, ткст тзам)\n\t{\n\treturn  cast(цел)(std.string.rfind(cast(сим[]) т, cast(сим[]) тзам));\n\t}\n\t///////////////////////////////////////////////\n\tцел найдлюбрек(ткст т, ткст тзам)\n\t{\n\treturn  cast(цел)(std.string.irfind(cast(сим[]) т, cast(сим[]) тзам));\n\t}\n\t//////////////////////////////////////////////\n\tткст впроп(ткст т)\n\t{\n\treturn cast(ткст)(std.string.tolower(cast(ткст) т));\n\t}\n\t//////////////////////////////////////////////////\n\tткст взаг(ткст т)\n\t{\n\treturn cast(ткст)(std.string.toupper(cast(ткст) т));\n\t}\n\t////////////////////////////////////////////////////\n\tткст озаг(ткст т){return std.string.capitalize(т);}\n\t////////////////////////////////////////////////////\n\tткст озагслова(ткст т){return std.string.capwords(т);}\n\t/////////////////////////////////////////////\n\tткст повтори(ткст т, т_мера м){return std.string.repeat(т, м);}\n\t///////////////////////////////////////////\n\tткст объедини(ткст[] слова, ткст разд){return  std.string.join(слова, разд);}\n\t///////////////////////////////////////\n\tткст[] разбей(ткст т){ткст м_т = т; return std.string.split(м_т);}\n\tткст[] разбейдоп(ткст т, ткст разделитель){ткст м_т = т; ткст м_разделитель = разделитель; return std.string.split(м_т, м_разделитель);}\n\t//////////////////////////////\n\tткст[] разбейнастр(ткст т){return std.string.splitlines(т);}\n\t////////////////////////\n\tткст уберислева(ткст т){return  std.string.stripl(т);}\n\tткст уберисправа(ткст т){return  std.string.stripr(т);}\n\tткст убери(ткст т){return  std.string.strip(т);}\n\t///////////////////////////\n\tткст убериразгр(ткст т){return  std.string.chomp(т);}\n\tткст уберигран(ткст т){return  std.string.chop(т);}\n\t/////////////////\n\tткст полев(ткст т, цел ширина){return  ljustify(т, ширина);}\n\tткст поправ(ткст т, цел ширина){return  rjustify(т, ширина);}\n\tткст вцентр(ткст т, цел ширина){return  center(т, ширина);}\n\tткст занули(ткст т, цел ширина){return  zfill(т, ширина);}\n\t\n\tткст замени(ткст т, ткст с, ткст на){ ткст м_т = т.dup; ткст м_с = т.dup; ткст м_на = т.dup; return  std.string.replace(м_т, м_с, м_на);}\n\tткст заменисрез(ткст т, ткст срез, ткст замена){ткст м_т = т; ткст м_срез = срез; ткст м_замена = замена; return  std.string.replaceSlice(м_т, м_срез, м_замена);}\n\tткст вставь(ткст т, т_мера индекс, ткст подст){ return  std.string.insert(т, индекс, подст);}\n\tт_мера счесть(ткст т, ткст подст){return  std.string.count(т, подст);}\n\n\n\tткст заменитабнапбел(ткст стр, цел размтаб=8){return std.string.expandtabs(стр, размтаб);}\n\tткст заменипбелнатаб(ткст стр, цел размтаб=8){return std.string.entab(стр, размтаб);}\n\tткст постройтранстаб(ткст из, ткст в){return maketrans(из, в);}\n\tткст транслируй(ткст т, ткст табтранс, ткст удсим){return translate(т, табтранс, удсим);}\n\t\t\n\n\tт_мера посчитайсимв(ткст т, ткст образец){return  std.string.countchars(т, образец);}\n\tткст удалисимв(ткст т, ткст образец){return  std.string.removechars(т, образец);}\n\tткст сквиз(ткст т, ткст образец= null){return  std.string.squeeze(cast(сим[]) т, cast(сим[]) образец);}\n\tткст следщ(ткст т){return std.string.succ(т);}\n\t\n\tткст тз(ткст ткт, ткст из, ткст в, ткст модифф = null){return std.string.tr(ткт, из, в, модифф);}\n\tбул чис_ли(in ткст т, in бул раздВкл = false){return cast(бул) std.string.isNumeric(т, раздВкл);}\n\tт_мера колном(ткст ткт, цел размтаб=8){return std.string.column(ткт, размтаб);}\n\tткст параграф(ткст т, цел колонки = 80, ткст первотступ = null, ткст отступ = null, цел размтаб = 8){return std.string.wrap(т, колонки, первотступ, отступ, размтаб);}\n\tткст эладр_ли(ткст т){return  std.string.isEmail(т);}\n\tткст урл_ли(ткст т){return  std.string.isURL(т);}\n\tткст целВЮ8(ткст врем, бцел знач){return std.string.intToUtf8(врем, знач);}\n\tткст бдолВЮ8(ткст врем, бцел знач){return std.string.ulongToUtf8(врем, знач);}\n\nimport std.conv;\n\n\tцел вЦел(ткст т){return std.conv.toInt(т);}\n\tбцел вБцел(ткст т){return std.conv.toUint(т);}\n\tдол вДол(ткст т){return std.conv.toLong(т);}\n\tбдол вБдол(ткст т){return std.conv.toUlong(т);}\n\tкрат вКрат(ткст т){return std.conv.toShort(т);}\n\tбкрат вБкрат(ткст т){return std.conv.toUshort(т);}  \n\tбайт вБайт(ткст т){return std.conv.toByte(т);}\n\tббайт вБбайт(ткст т){return std.conv.toUbyte(т);} \n\tплав вПлав(ткст т){return std.conv.toFloat(т);}   \n\tдво вДво(ткст т){return std.conv.toDouble(т);} \n\tреал вРеал(ткст т){return std.conv.toReal(т);}\n\n}///extern C\n////////////////////////////\n\nenum ПМангл : сим\n{\n    Тпроц     = 'v',\n    Тбул     = 'b',\n    Тбайт     = 'g',\n    Тббайт    = 'h',\n    Ткрат    = 's',\n    Тбкрат   = 't',\n    Тцел      = 'i',\n    Тбцел     = 'k',\n    Тдол     = 'l',\n    Тбдол    = 'm',\n    Тплав    = 'f',\n    Тдво   = 'd',\n    Треал     = 'e',\n\n    Твплав   = 'o',\n    Твдво  = 'p',\n    Твреал    = 'j',\n    Ткплав   = 'q',\n    Ткдво  = 'r',\n    Ткреал    = 'c',\n\n    Тсим     = 'a',\n    Тшим    = 'u',\n    Тдим    = 'w',\n\n    Тмассив    = 'A',\n    Тсмассив   = 'G',\n    Тамассив   = 'H',\n    Туказатель  = 'P',\n    Тфункция = 'F',\n    Тидент    = 'I',\n    Ткласс    = 'C',\n    Тструкт   = 'S',\n    Тперечень     = 'E',\n    Ттипдеф  = 'T',\n    Тделегат = 'D',\n\n    Тконст    = 'x',\n    Тинвариант = 'y',\n}\n\nexport extern(D) ИнфОТипе простаяИнфОТипе(ПМангл м) \n{\n  ИнфОТипе ti;\n\n  switch (м)\n    {\n    case ПМангл.Тпроц:\n      ti = typeid(проц);break;\n    case ПМангл.Тбул:\n      ti = typeid(бул);break;\n    case ПМангл.Тбайт:\n      ti = typeid(байт);break;\n    case ПМангл.Тббайт:\n      ti = typeid(ббайт);break;\n    case ПМангл.Ткрат:\n      ti = typeid(крат);break;\n    case ПМангл.Тбкрат:\n      ti = typeid(бкрат);break;\n    case ПМангл.Тцел:\n      ti = typeid(цел);break;\n    case ПМангл.Тбцел:\n      ti = typeid(бцел);break;\n    case ПМангл.Тдол:\n      ti = typeid(дол);break;\n    case ПМангл.Тбдол:\n      ti = typeid(бдол);break;\n    case ПМангл.Тплав:\n      ti = typeid(плав);break;\n    case ПМангл.Тдво:\n      ti = typeid(дво);break;\n    case ПМангл.Треал:\n      ti = typeid(реал);break;\n    case ПМангл.Твплав:\n      ti = typeid(вплав);break;\n    case ПМангл.Твдво:\n      ti = typeid(вдво);break;\n    case ПМангл.Твреал:\n      ti = typeid(вреал);break;\n    case ПМангл.Ткплав:\n      ti = typeid(кплав);break;\n    case ПМангл.Ткдво:\n      ti = typeid(кдво);break;\n    case ПМангл.Ткреал:\n      ti = typeid(креал);break;\n    case ПМангл.Тсим:\n      ti = typeid(сим);break;\n    case ПМангл.Тшим:\n      ti = typeid(шим);break;\n    case ПМангл.Тдим:\n      ti = typeid(дим);break;\n    default:\n      ti = null;\n    }\n  return ti;\n}\n\nversion (Windows)\n{\n    version (DigitalMars)\n    {\n\tversion = DigitalMarsC;\n    }\n}\n\nversion (DigitalMarsC)\n{\n    // This is DMC'т internal floating poцел formatting function\n    extern  (C)\n    {\n\textern  сим* function(цел c, цел флаги, цел точность, реал* pdзнач,\n\t    сим* буф, цел* psl, цел width) __pfloatfmt;\n    }\n}\nelse\n{\n    // Use C99 snprцелf\n    extern  (C) цел snprintf(сим* т, т_мера n, сим* format, ...);\n}\n\nexport extern(D)\n{\n\tткст вТкст(бул с){return std.string.toString(с);}\n\tткст вТкст(сим с)\n\t{\n\t\tткст результат = new сим[2];\n\t\tрезультат[0] = с;\n\t\tрезультат[1] = 0;\n\t\treturn результат[0 .. 1];\n\t}\n\tткст вТкст(ббайт с){return std.string.toString(с);}\n\tткст вТкст(бкрат с){return std.string.toString(с);}\n\tткст вТкст(бцел с){return std.string.toString(с);}\n\tткст вТкст(бдол с){return std.string.toString(с);}\n\tткст вТкст(байт с){return std.string.toString(с);}\n\tткст вТкст(крат с){return std.string.toString(с);}\n\tткст вТкст(цел с){return std.string.toString(с);}\n\tткст вТкст(дол с){return std.string.toString(с);}\n\tткст вТкст(плав с){return std.string.toString(с);}\n\tткст вТкст(дво с){return std.string.toString(с);}\n\tткст вТкст(реал с){return std.string.toString(с);}\n\tткст вТкст(вплав с){return std.string.toString(с);}\n\tткст вТкст(вдво с){return std.string.toString(с);}\n\tткст вТкст(вреал с){return std.string.toString(с);}\n\tткст вТкст(кплав с){return std.string.toString(с);}\n\tткст вТкст(кдво с){return std.string.toString(с);}\n\tткст вТкст(креал с){return std.string.toString(с);}\n\tткст вТкст(дол знач, бцел корень){return std.string.toString(знач, корень);}\n\tткст вТкст(бдол знач, бцел корень){return std.string.toString(знач, корень);}\n\tткст вТкст(сим *с){return std.string.toString(с);}\n\t\n\tпроц разборСпискаАргументов(ref ИнфОТипе[] args, ref спис_ва argptr, out ткст format)\n\t {\n\t  if (args.length == 2 && args[0] == typeid(ИнфОТипе[]) && args[1] == typeid(спис_ва)) {\n\t\targs = ва_арг!(ИнфОТипе[])(argptr);\n\t\targptr = *cast(спис_ва*)argptr;\n\n\t\tif (args.length > 1 && args[0] == typeid(ткст)) {\n\t\t  format = ва_арг!(ткст)(argptr);\n\t\t  args = args[1 .. $];\n\t\t}\n\n\t\tif (args.length == 2 && args[0] == typeid(ИнфОТипе[]) && args[1] == typeid(спис_ва)) {\n\t\t  разборСпискаАргументов(args, argptr, format);\n\t\t}\n\t  }\n\t  else if (args.length > 1 && args[0] == typeid(ткст)) {\n\t\tformat = ва_арг!(ткст)(argptr);\n\t\targs = args[1 .. $];\n\t  }\n\t} \n/*\nauto args = _arguments;\n    auto argptr = _argptr;\n    ткст fmt = null;\n    разборСпискаАргументов(args, argptr, fmt);\n*/\nпроц форматДелай(проц delegate(дим) putc, ИнфОТипе[] arguments, спис_ва argptr)\n\t{\n\tцел j;\n    ИнфОТипе ti;\n    ПМангл m;\n    бцел флаги;\n    цел ширина_поля;\n    цел точность;\n\n    enum : бцел\n    {\n\tFLdash = 1,\n\tFLplus = 2,\n\tFLspace = 4,\n\tFLhash = 8,\n\tFLlngdbl = 0x20,\n\tFL0pad = 0x40,\n\tFLprecision = 0x80,\n    }\n    \n    static ИнфОТипе skipCI(ИнфОТипе типзнач)\n    {\n      while (1)\n      {\n\tif (типзнач.classinfo.name.length == 18 &&  типзнач.classinfo.name[9..18] == \"Invariant\")\n\t    типзнач =\t(cast(TypeInfo_Invariant)типзнач).следщ;\n\telse if (типзнач.classinfo.name.length == 14 && типзнач.classinfo.name[9..14] == \"Const\")\n\t    типзнач =\t(cast(TypeInfo_Const)типзнач).следщ;\n\telse\n\t    break;\n      }\n      return типзнач;\n    }\n\n    проц formatArg(сим fc)\n    {\n\tбул vbit;\n\tбдол vnumber;\n\tсим vchar;\n\tдим vdchar;\n\tОбъект vobject;\n\tреал vreal;\n\tкреал vcreal;\n\tПМангл m2;\n\tцел signed = 0;\n\tбцел base = 10;\n\tцел uc;\n\tсим[бдол.sizeof * 8] tmpbuf;\t// дол enough to print дол in binary\n\tсим* prefix = \"\";\n\tткст т;\n\n\tпроц putstr(ткст т)\n\t{\n\t    //эхо(\"флаги = x%x\\n\", флаги);\n\t\t//win.скажинс(т);\n\t    цел prepad = 0;\n\t    цел postpad = 0;\n\t\tцел padding = ширина_поля - (cidrus.strlen(prefix) + т.length);//toUCSindex(т, т.length));\n\t    if (padding > 0)\n\t    {\n\t\tif (флаги & FLdash)\n\t\t    postpad = padding;\n\t\telse\n\t\t    prepad = padding;\n\t    }\n\n\t    if (флаги & FL0pad)\n\t    {\n\t\twhile (*prefix)\n\t\t    putc(*prefix++);\n\t\twhile (prepad--)\n\t\t    putc('0');\n\t    }\n\t    else\n\t    {\n\t\twhile (prepad--)\n\t\t    putc(' ');\n\t\twhile (*prefix)\n\t\t    putc(*prefix++);\n\t    }\n\n\t    foreach (дим c; т)\n\t\tputc(c);\n\n\t    while (postpad--)\n\t\tputc(' ');\n\t}\n\n\tпроц putreal(реал v)\n\t{\n\t    //эхо(\"putreal %Lg\\n\", vreal);\n\n\t    switch (fc)\n\t    {\n\t\tcase 's':\n\t\t    fc = 'g';\n\t\t    break;\n\n\t\tcase 'f', 'F', 'e', 'E', 'g', 'G', 'a', 'A':\n\t\t    break;\n\n\t\tdefault:\n\t\t    //эхо(\"fc = '%c'\\n\", fc);\n\t\tLerror:\n\t\t    throw new ФорматИскл(\"плавающая запятая\");\n\t    }\n\t    version (DigitalMarsC)\n\t    {\n\t\tцел sl;\n\t\tткст fbuf = tmpbuf;\n\t\tif (!(флаги & FLprecision))\n\t\t    точность = 6;\n\t\twhile (1)\n\t\t{\n\t\t    sl = fbuf.length;\n\t\t    prefix = (*__pfloatfmt)(fc, флаги | FLlngdbl,\n\t\t\t    точность, &v, cast(сим*)fbuf, &sl, ширина_поля);\n\t\t    if (sl != -1)\n\t\t\tbreak;\n\t\t    sl = fbuf.length * 2;\n\t\t    fbuf = (cast(сим*)cidrus.разместа(sl * сим.sizeof))[0 .. sl];\n\t\t}\n\t\tdebug(PutStr) win.скажинс(\"путстр1\");\n\t\tputstr(fbuf[0 .. sl]);\n\t    }\n\t    else\n\t    {\n\t\tцел sl;\n\t\tткст fbuf = tmpbuf;\n\t\tсим[12] format;\n\t\tformat[0] = '%';\n\t\tцел i = 1;\n\t\tif (флаги & FLdash)\n\t\t    format[i++] = '-';\n\t\tif (флаги & FLplus)\n\t\t    format[i++] = '+';\n\t\tif (флаги & FLspace)\n\t\t    format[i++] = ' ';\n\t\tif (флаги & FLhash)\n\t\t    format[i++] = '#';\n\t\tif (флаги & FL0pad)\n\t\t    format[i++] = '0';\n\t\tformat[i + 0] = '*';\n\t\tformat[i + 1] = '.';\n\t\tformat[i + 2] = '*';\n\t\tformat[i + 3] = 'L';\n\t\tformat[i + 4] = fc;\n\t\tformat[i + 5] = 0;\n\t\tif (!(флаги & FLprecision))\n\t\t    точность = -1;\n\t\twhile (1)\n\t\t{   цел n;\n\n\t\t    sl = fbuf.length;\n\t\t    n = snprintf(fbuf.ptr, sl, format.ptr, ширина_поля, точность, v);\n\t\t    //эхо(\"format = '%s', n = %d\\n\", cast(сим*)format, n);\n\t\t    if (n >= 0 && n < sl)\n\t\t    {\tsl = n;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (n < 0)\n\t\t\tsl = sl * 2;\n\t\t    else\n\t\t\tsl = n + 1;\n\t\t    fbuf = (cast(сим*)cidrus.разместа(sl * сим.sizeof))[0 .. sl];\n\t\t}\n\t\tdebug(PutStr) win.скажинс(\"путстр2\");\n\t\tputstr(fbuf[0 .. sl]);\n\t    }\n\t    return;\n\t}\n\n\tstatic ПМангл getMan(ИнфОТипе ti)\n\t{\n\t  auto m = cast(ПМангл)ti.classinfo.name[9];\n\t  if (ti.classinfo.name.length == 20 &&\n\t      ti.classinfo.name[9..20] == \"StaticArray\")\n\t\tm = cast(ПМангл)'G';\n\t  return m;\n\t}\n\n\tпроц putArray(ук p, т_мера длин, ИнфОТипе типзнач)\n\t{\n\t  //эхо(\"\\nputArray(длин = %u), tsize = %u\\n\", длин, типзнач.tsize());\n\t  putc('[');\n\t  типзнач = skipCI(типзнач);\n\t  т_мера tsize = типзнач.tsize();\n\t  auto argptrSave = argptr;\n\t  auto tiSave = ti;\n\t  auto mSave = m;\n\t  ti = типзнач;\n\t  //эхо(\"\\n%.*т\\n\", типзнач.classinfo.name);\n\t  m = getMan(типзнач);\n\t  while (длин--)\n\t  {\n\t    //doFormat(putc, (&типзнач)[0 .. 1], p);\n\t    argptr = адаптВхоУкз(p);\n\t    formatArg('s');\n\n\t    p += tsize;\n\t    if (длин > 0) putc(',');\n\t  }\n\t  m = mSave;\n\t  ti = tiSave;\n\t  argptr = argptrSave;\n\t  putc(']');\n\t}\n\n\tпроц putAArray(ббайт[дол] vaa, ИнфОТипе типзнач, ИнфОТипе keyti)\n\t{\n\t  putc('[');\n\t  бул comma=нет;\n\t  auto argptrSave = argptr;\n\t  auto tiSave = ti;\n\t  auto mSave = m;\n\t  типзнач = skipCI(типзнач);\n\t  keyti = skipCI(keyti);\n\t  foreach(inout fakevalue; vaa)\n\t  {\n\t    if (comma) putc(',');\n\t    comma = да;\n\t    // the key comes before the значение\n\t    ббайт* key = &fakevalue - дол.sizeof;\n\n\t    //doFormat(putc, (&keyti)[0..1], key);\n\t    argptr = key;\n\t    ti = keyti;\n\t    m = getMan(keyti);\n\t    formatArg('s');\n\n\t    putc(':');\n\t    auto keysize = keyti.tsize;\n\t    keysize = (keysize + 3) & ~3;\n\t    ббайт* значение = key + keysize;\n\t    //doFormat(putc, (&типзнач)[0..1], значение);\n\t    argptr = значение;\n\t    ti = типзнач;\n\t    m = getMan(типзнач);\n\t    formatArg('s');\n\t  }\n\t  m = mSave;\n\t  ti = tiSave;\n\t  argptr = argptrSave;\n\t  putc(']');\n\t}\n\n\t//эхо(\"formatArg(fc = '%c', m = '%c')\\n\", fc, m);\n\tswitch (m)\n\t{\n\t    case ПМангл.Тбул:\n\t\tvbit = ва_арг!(бул)(argptr);\n\t\tif (fc != 's')\n\t\t{   vnumber = vbit;\n\t\t    goto Lnumber;\n\t\t}\n\t\tdebug(PutStr) win.скажинс(\"путстр3\");\n\t\tputstr(vbit ? \"да\" : \"нет\");\n\t\treturn;\n\n\n\t    case ПМангл.Тсим:\n\t\tvchar = ва_арг!(сим)(argptr);\n\t\tif (fc != 's')\n\t\t{   vnumber = vchar;\n\t\t    goto Lnumber;\n\t\t}\n\t    L2:\n\t\tdebug(PutStr) win.скажинс(\"путстр4\");\n\t\tputstr((&vchar)[0 .. 1]);\n\t\treturn;\n\n\t    case ПМангл.Тшим:\n\t\tvdchar = ва_арг!(шим)(argptr);\n\t\tgoto L1;\n\n\t    case ПМангл.Тдим:\n\t\tvdchar = ва_арг!(дим)(argptr);\n\t    L1:\n\t\tif (fc != 's')\n\t\t{   vnumber = vdchar;\n\t\t    goto Lnumber;\n\t\t}\n\t\tif (vdchar <= 0x7F)\n\t\t{   vchar = cast(сим)vdchar;\n\t\t    goto L2;\n\t\t}\n\t\telse\n\t\t{   if (!isValidDchar(vdchar))\n\t\t\tthrow new Исключение(\"Неверный дим в формате\",__FILE__, __LINE__);\n\t\t    сим[4] vbuf;\n\t\t\tdebug(PutStr) win.скажинс(\"путстр5\");\n\t\t    putstr(toUTF8(vbuf, vdchar));\n\t\t}\n\t\treturn;\n\n\n\t    case ПМангл.Тбайт:\n\t\tsigned = 1;\n\t\tvnumber = ва_арг!(байт)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Тббайт:\n\t\tvnumber = ва_арг!(ббайт)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Ткрат:\n\t\tsigned = 1;\n\t\tvnumber = ва_арг!(крат)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Тбкрат:\n\t\tvnumber = ва_арг!(бкрат)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Тцел:\n\t\tsigned = 1;\n\t\tvnumber = ва_арг!(цел)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Тбцел:\n\t    Luцел:\n\t\tvnumber = ва_арг!(бцел)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Тдол:\n\t\tsigned = 1;\n\t\tvnumber = cast(бдол)ва_арг!(дол)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Тбдол:\n\t    Lбдол:\n\t\tvnumber = ва_арг!(бдол)(argptr);\n\t\tgoto Lnumber;\n\n\t    case ПМангл.Ткласс:\n\t\tvobject = ва_арг!(Объект)(argptr);\n\t\tif (vobject is null)\n\t\t    т = \"null\";\n\t\telse\n\t\t    т = vobject.toString();\n\t\tgoto Lputstr;\n\n\t    case ПМангл.Туказатель:\n\t\tvnumber = cast(бдол)ва_арг!(проц*)(argptr);\n\t\tif (fc != 'x' && fc != 'X')\t\tuc = 1;\n\t\tфлаги |= FL0pad;\n\t\tif (!(флаги & FLprecision))\n\t\t{   флаги |= FLprecision;\n\t\t    точность = (проц*).sizeof;\n\t\t}\n\t\tbase = 16;\n\t\tgoto Lnumber;\n\n\n\t    case ПМангл.Тплав:\n\t    case ПМангл.Твплав:\n\t\tif (fc == 'x' || fc == 'X')\n\t\t    goto Luцел;\n\t\tvreal = ва_арг!(плав)(argptr);\n\t\tgoto Lreal;\n\n\t    case ПМангл.Тдво:\n\t    case ПМангл.Твдво:\n\t\tif (fc == 'x' || fc == 'X')\n\t\t    goto Lбдол;\n\t\tvreal = ва_арг!(дво)(argptr);\n\t\tgoto Lreal;\n\n\t    case ПМангл.Треал:\n\t    case ПМангл.Твреал:\n\t\tvreal = ва_арг!(реал)(argptr);\n\t\tgoto Lreal;\n\n\n\t    case ПМангл.Ткплав:\n\t\tvcreal = ва_арг!(кплав)(argptr);\n\t\tgoto Lcomplex;\n\n\t    case ПМангл.Ткдво:\n\t\tvcreal = ва_арг!(кдво)(argptr);\n\t\tgoto Lcomplex;\n\n\t    case ПМангл.Ткреал:\n\t\tvcreal = ва_арг!(креал)(argptr);\n\t\tgoto Lcomplex;\n\n\t    case ПМангл.Тсмассив:\n\t\tputArray(argptr, (cast(TypeInfo_StaticArray)ti).длин, (cast(TypeInfo_StaticArray)ti).следщ);\n\t\treturn;\n\n\t    case ПМангл.Тмассив:\n\t\tцел mi = 10;\n\t        if (ti.classinfo.name.length == 14 &&\n\t\t    ti.classinfo.name[9..14] == \"Array\") \n\t\t{ // array of non-primitive types\n\t\t  ИнфОТипе tn = (cast(TypeInfo_Array)ti).следщ;\n\t\t  tn = skipCI(tn);\n\t\t  switch (cast(ПМангл)tn.classinfo.name[9])\n\t\t  {\n\t\t    case ПМангл.Тсим:  goto LarrayChar;\n\t\t    case ПМангл.Тшим: goto LarrayWchar;\n\t\t    case ПМангл.Тдим: goto LarrayDchar;\n\t\t    default:\n\t\t\tbreak;\n\t\t  }\n\t\t  проц[] va = ва_арг!(проц[])(argptr);\n\t\t  putArray(va.ptr, va.length, tn);\n\t\t  return;\n\t\t}\n\t\tif (ti.classinfo.name.length == 25 &&\n\t\t    ti.classinfo.name[9..25] == \"AssociativeArray\") \n\t\t{ // associative array\n\t\t  ббайт[дол] vaa = ва_арг!(ббайт[дол])(argptr);\n\t\t  putAArray(vaa,\n\t\t\t(cast(TypeInfo_AssociativeArray)ti).следщ,\n\t\t\t(cast(TypeInfo_AssociativeArray)ti).key);\n\t\t  return;\n\t\t}\n\n\t\twhile (1)\n\t\t{\n\t\t    m2 = cast(ПМангл)ti.classinfo.name[mi];\n\t\t    switch (m2)\n\t\t    {\n\t\t\tcase ПМангл.Тсим:\n\t\t\tLarrayChar:\n\t\t\t    т = ва_арг!(ткст)(argptr);\n\t\t\t    goto Lputstr;\n\n\t\t\tcase ПМангл.Тшим:\n\t\t\tLarrayWchar:\n\t\t\t    шим[] sw = ва_арг!(wstring)(argptr);\n\t\t\t    т = toUTF8(sw);\n\t\t\t    goto Lputstr;\n\n\t\t\tcase ПМангл.Тдим:\n\t\t\tLarrayDchar:\n\t\t\t    дим[] sd = ва_арг!(dstring)(argptr);\n\t\t\t    т = toUTF8(sd);\n\t\t\tLputstr:\n\t\t\t    if (fc != 's')\n\t\t\t\t{\n\t\t\t\tthrow new ФорматИскл(\"ткст\");\n\t\t\t\t}\n\t\t\t    if (флаги & FLprecision && точность < т.length)\n\t\t\t\tт = т[0 .. точность];\n\t\t\t\tdebug(PutStr) win.скажинс(\"путстр6\");\n\t\t\t    putstr(т);\n\t\t\t    break;\n\n\t\t\tcase ПМангл.Тконст:\n\t\t\tcase ПМангл.Тинвариант:\n\t\t\t    mi++;\n\t\t\t    continue;\n\n\t\t\tdefault:\n\t\t\t    ИнфОТипе ti2 = простаяИнфОТипе(m2);\n\t\t\t    if (!ti2)\n\t\t\t      goto Lerror;\n\t\t\t    проц[] va = ва_арг!(проц[])(argptr);\n\t\t\t    putArray(va.ptr, va.length, ti2);\n\t\t    }\n\t\t    return;\n\t\t}\n\n\t    case ПМангл.Ттипдеф:\n\t\tti = (cast(TypeInfo_Typedef)ti).base;\n\t\tm = cast(ПМангл)ti.classinfo.name[9];\n\t\tformatArg(fc);\n\t\treturn;\n\n\t    case ПМангл.Тперечень:\n\t\tti = (cast(TypeInfo_Enum)ti).base;\n\t\tm = cast(ПМангл)ti.classinfo.name[9];\n\t\tformatArg(fc);\n\t\treturn;\n\n\t    case ПМангл.Тструкт:\n\t    {\tTypeInfo_Struct tis = cast(TypeInfo_Struct)ti;\n\t\tif (tis.xtoString is null)\n\t\t    throw new ФорматИскл(\"Не удаётся преобразовать \" ~ tis.toString() ~ \" в ткст: функция \\\"ткст вТкст()\\\" не определена\");\n\t\tт = tis.xtoString(argptr);\n\t\targptr += (tis.tsize() + 3) & ~3;\n\t\tgoto Lputstr;\n\t    }\n\n\t    default:\n\t\tgoto Lerror;\n\t}\n\n    Lnumber:\n\tswitch (fc)\n\t{\n\t    case 's':\n\t    case 'd':\n\t\tif (signed)\n\t\t{   if (cast(дол)vnumber < 0)\n\t\t    {\tprefix = \"-\";\n\t\t\tvnumber = -vnumber;\n\t\t    }\n\t\t    else if (флаги & FLplus)\n\t\t\tprefix = \"+\";\n\t\t    else if (флаги & FLspace)\n\t\t\tprefix = \" \";\n\t\t}\n\t\tbreak;\n\n\t    case 'b':\n\t\tsigned = 0;\n\t\tbase = 2;\n\t\tbreak;\n\n\t    case 'o':\n\t\tsigned = 0;\n\t\tbase = 8;\n\t\tbreak;\n\n\t    case 'X':\n\t\tuc = 1;\n\t\tif (флаги & FLhash && vnumber)\n\t\t    prefix = \"0X\";\n\t\tsigned = 0;\n\t\tbase = 16;\n\t\tbreak;\n\n\t    case 'x':\n\t\tif (флаги & FLhash && vnumber)\n\t\t    prefix = \"0x\";\n\t\tsigned = 0;\n\t\tbase = 16;\n\t\tbreak;\n\n\t    default:\n\t\tgoto Lerror;\n\t}\n\n\tif (!signed)\n\t{\n\t    switch (m)\n\t    {\n\t\tcase ПМангл.Тбайт:\n\t\t    vnumber &= 0xFF;\n\t\t    break;\n\n\t\tcase ПМангл.Ткрат:\n\t\t    vnumber &= 0xFFFF;\n\t\t    break;\n\n\t\tcase ПМангл.Тцел:\n\t\t    vnumber &= 0xFFFFFFFF;\n\t\t    break;\n\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\n\tif (флаги & FLprecision && fc != 'p')\n\t    флаги &= ~FL0pad;\n\n\tif (vnumber < base)\n\t{\n\t    if (vnumber == 0 && точность == 0 && флаги & FLprecision &&\n\t\t!(fc == 'o' && флаги & FLhash))\n\t    {\n\t\tdebug(PutStr) win.скажинс(\"путстр7\");\n\t\tputstr(null);\n\t\treturn;\n\t    }\n\t    if (точность == 0 || !(флаги & FLprecision))\n\t    {\tvchar = cast(сим)('0' + vnumber);\n\t\tif (vnumber < 10)\n\t\t    vchar = cast(сим)('0' + vnumber);\n\t\telse\n\t\t    vchar = cast(сим)((uc ? 'A' - 10 : 'a' - 10) + vnumber);\n\t\tgoto L2;\n\t    }\n\t}\n\n\tцел n = tmpbuf.length;\n\tсим c;\n\tцел hexсмещение = uc ? ('A' - ('9' + 1)) : ('a' - ('9' + 1));\n\n\twhile (vnumber)\n\t{\n\t    c = cast(сим)((vnumber % base) + '0');\n\t    if (c > '9')\n\t\tc += hexсмещение;\n\t    vnumber /= base;\n\t    tmpbuf[--n] = c;\n\t}\n\tif (tmpbuf.length - n < точность && точность < tmpbuf.length)\n\t{\n\t    цел m = tmpbuf.length - точность;\n\t    tmpbuf[m .. n] = '0';\n\t    n = m;\n\t}\n\telse if (флаги & FLhash && fc == 'o')\n\t    prefix = \"0\";\n\t\tdebug(PutStr) win.скажинс(\"путстр8\");\n\tputstr(tmpbuf[n .. tmpbuf.length]);\n\treturn;\n\n    Lreal:\n\tputreal(vreal);\n\treturn;\n\n    Lcomplex:\n\tputreal(vcreal.re);\n\tputc('+');\n\tputreal(vcreal.im);\n\tputc('i');\n\treturn;\n\n    Lerror:\n\tthrow new ФорматИскл(\"\\n\\tформат аргумента неправильно указан\");\n    }\n\n\n    for (j = 0; j < arguments.length; )\n    {\tti = arguments[j++];\n\t//эхо(\"test1: '%.*т' %d\\n\", ti.classinfo.name, ti.classinfo.name.length);\n\t//ti.print();\n\n\tфлаги = 0;\n\tточность = 0;\n\tширина_поля = 0;\n\n\tti = skipCI(ti);\n\tцел mi = 9;\n\tdo\n\t{\n\t    if (ti.classinfo.name.length <= mi)\n\t\tgoto Lerror;\n\t    m = cast(ПМангл)ti.classinfo.name[mi++];\n\t} while (m == ПМангл.Тконст || m == ПМангл.Тинвариант);\n\n\tif (m == ПМангл.Тмассив)\n\t{\n\t    if (ti.classinfo.name.length == 14 &&\n\t\tti.classinfo.name[9..14] == \"Array\") \n\t    {\n\t      ИнфОТипе tn = (cast(TypeInfo_Array)ti).следщ;\n\t      tn = skipCI(tn);\n\t      switch (cast(ПМангл)tn.classinfo.name[9])\n\t      {\n\t\tcase ПМангл.Тсим:\n\t\tcase ПМангл.Тшим:\n\t\tcase ПМангл.Тдим:\n\t\t    ti = tn;\n\t\t    mi = 9;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t      }\n\t    }\n\tL1:\n\t    ПМангл m2 = cast(ПМангл)ti.classinfo.name[mi];\n\t    ткст  fmt;\t\t\t// format ткст\n\t    wstring wfmt;\n\t    dstring dfmt;\n\n\t    /* For performance причины, this код takes advantage of the\n\t     * fact that most format strings will be ASCII, and that the\n\t     * format specifiers are always ASCII. This means we only need\n\t     * to deal with UTF in a couple of isolated spots.\n\t     */\n\n\t    switch (m2)\n\t    {\n\t\tcase ПМангл.Тсим:\n\t\t    fmt = ва_арг!(ткст)(argptr);\n\t\t    break;\n\n\t\tcase ПМангл.Тшим:\n\t\t    wfmt = ва_арг!(wstring)(argptr);\n\t\t    fmt = toUTF8(wfmt);\n\t\t    break;\n\n\t\tcase ПМангл.Тдим:\n\t\t    dfmt = ва_арг!(dstring)(argptr);\n\t\t    fmt = toUTF8(dfmt);\n\t\t    break;\n\n\t\tcase ПМангл.Тконст:\n\t\tcase ПМангл.Тинвариант:\n\t\t    mi++;\n\t\t    goto L1;\n\n\t\tdefault:\n\t\t    formatArg('s');\n\t\t    continue;\n\t    }\n\n\t    for (т_мера i = 0; i < fmt.length; )\n\t    {\tдим c = fmt[i++];\n\n\t\tдим getFmtChar()\n\t\t{   // Valid format specifier символs will never be UTF\n\t\t    if (i == fmt.length)\n\t\t\tthrow new ФорматИскл(\"Неверный спецификатор\");\n\t\t    return fmt[i++];\n\t\t}\n\n\t\tцел getFmtInt()\n\t\t{   цел n;\n\n\t\t    while (1)\n\t\t    {\n\t\t\tn = n * 10 + (c - '0');\n\t\t\tif (n < 0)\t// overflow\n\t\t\t    throw new ФорматИскл(\"Превышение размера цел\");\n\t\t\tc = getFmtChar();\n\t\t\tif (c < '0' || c > '9')\n\t\t\t    break;\n\t\t    }\n\t\t    return n;\n\t\t}\n\n\t\tцел getFmtStar()\n\t\t{   ПМангл m;\n\t\t    ИнфОТипе ti;\n\n\t\t    if (j == arguments.length)\n\t\t\tthrow new ФорматИскл(\"Недостаточно аргументов\");\n\t\t    ti = arguments[j++];\n\t\t    m = cast(ПМангл)ti.classinfo.name[9];\n\t\t    if (m != ПМангл.Тцел)\n\t\t\tthrow new ФорматИскл(\"Ожидался аргумент типа цел\");\n\t\t    return ва_арг!(цел)(argptr);\n\t\t}\n\n\t\tif (c != '%')\n\t\t{\n\t\t    if (c > 0x7F)\t// if UTF sequence\n\t\t    {\n\t\t\ti--;\t\t// back up and decode UTF sequence\n\t\t\tc = std.utf.decode(fmt, i);\n\t\t    }\n\t\tLputc:\n\t\t    putc(c);\n\t\t    continue;\n\t\t}\n\n\t\t// Get флаги {-+ #}\n\t\tфлаги = 0;\n\t\twhile (1)\n\t\t{\n\t\t    c = getFmtChar();\n\t\t    switch (c)\n\t\t    {\n\t\t\tcase '-':\tфлаги |= FLdash;\tcontinue;\n\t\t\tcase '+':\tфлаги |= FLplus;\tcontinue;\n\t\t\tcase ' ':\tфлаги |= FLspace;\tcontinue;\n\t\t\tcase '#':\tфлаги |= FLhash;\tcontinue;\n\t\t\tcase '0':\tфлаги |= FL0pad;\tcontinue;\n\n\t\t\tcase '%':\tif (флаги == 0)\n\t\t\t\t\t    goto Lputc;\n\t\t\tdefault:\tbreak;\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// Get field width\n\t\tширина_поля = 0;\n\t\tif (c == '*')\n\t\t{\n\t\t    ширина_поля = getFmtStar();\n\t\t    if (ширина_поля < 0)\n\t\t    {   флаги |= FLdash;\n\t\t\tширина_поля = -ширина_поля;\n\t\t    }\n\n\t\t    c = getFmtChar();\n\t\t}\n\t\telse if (c >= '0' && c <= '9')\n\t\t    ширина_поля = getFmtInt();\n\n\t\tif (флаги & FLplus)\n\t\t    флаги &= ~FLspace;\n\t\tif (флаги & FLdash)\n\t\t    флаги &= ~FL0pad;\n\n\t\t// Get точность\n\t\tточность = 0;\n\t\tif (c == '.')\n\t\t{   флаги |= FLprecision;\n\t\t    //флаги &= ~FL0pad;\n\n\t\t    c = getFmtChar();\n\t\t    if (c == '*')\n\t\t    {\n\t\t\tточность = getFmtStar();\n\t\t\tif (точность < 0)\n\t\t\t{   точность = 0;\n\t\t\t    флаги &= ~FLprecision;\n\t\t\t}\n\n\t\t\tc = getFmtChar();\n\t\t    }\n\t\t    else if (c >= '0' && c <= '9')\n\t\t\tточность = getFmtInt();\n\t\t}\n\n\t\tif (j == arguments.length)\n\t\t    goto Lerror;\n\t\tti = arguments[j++];\n\t\tti = skipCI(ti);\n\t\tmi = 9;\n\t\tdo\n\t\t{\n\t\t    m = cast(ПМангл)ti.classinfo.name[mi++];\n\t\t} while (m == ПМангл.Тконст || m == ПМангл.Тинвариант);\n\n\t\tif (c > 0x7F)\t\t// if UTF sequence\n\t\t    goto Lerror;\t// format specifiers can't be UTF\n\t\tformatArg(cast(сим)c);\n\t    }\n\t}\n\telse\n\t{\n\t    formatArg('s');\n\t}\n    }\n    return;\n\nLerror:\n    throw new ФорматИскл();\n}\n\t\n}//end of extern D\n//////////////////////////////////\n\nexport extern(D)\n{\n\nimport std.random;\n\n\tпроц случсей(бцел семя, бцел индекс){std.random.rand_seed(cast(бцел) семя, cast(бцел) индекс);}\n\tбцел случайно(){return cast(бцел) std.random.rand();}\n\tбцел случген(бцел семя, бцел индекс, реал члоциклов)\n\t\t{\n\t\treturn cast(бцел) std.random.randomGen(cast(бцел) семя, cast(бцел) индекс, cast(бцел) члоциклов);\n\t\t}\n\nimport std.file;\n\n\tпроц[] читайФайл(ткст имяф){return std.file.read(имяф);}\n\tпроц пишиФайл(ткст имяф, проц[] буф){std.file.write(имяф, буф);}\n\tпроц допишиФайл(ткст имяф, проц[] буф){std.file.append(имяф, буф);}\n\tпроц переименуйФайл(ткст из, ткст в){std.file.rename(из, в);}\n\tпроц удалиФайл(ткст имяф){std.file.remove(имяф);}\n\tбдол дайРазмерФайла(ткст имяф){return std.file.getSize(имяф);}\n\tпроц дайВременаФайла(ткст имяф, out т_время фтц, out т_время фта, out т_время фтм){std.file.getTimes(имяф, фтц, фта, фтм);}\n\tбул естьФайл(ткст имяф){return cast(бул) std.file.exists(имяф);}\n\tбцел дайАтрибутыФайла(ткст имяф){return std.file.getAttributes(имяф);}\n\tбул файл_ли(ткст имяф){return cast(бул) std.file.isfile(имяф);}\n\tбул папка_ли(ткст имяп){return cast(бул) std.file.isdir(имяп);}\n\tпроц сменипап(ткст имяп){std.file.chdir(имяп);}\n\tпроц сделайпап(ткст имяп){std.file.mkdir(имяп);}\n\tпроц удалипап(ткст имяп){std.file.rmdir(имяп);}\n\tткст дайтекпап(){return std.file.getcwd();}\n\tткст[] списпап(ткст имяп){return std.file.listdir(имяп);}\n\tткст[] списпап(ткст имяп, ткст образец){return std.file.listdir(имяп, образец);}\n\t\n}\n\nexport extern(D)\n{\t\n\n\timport std.utf;\n\n\tбул дим_ли(дим д){return std.utf.isValidDchar(д);}\n\tбцел байтЮ(ткст т, т_мера и)\n\t\t{\n\t\tбцел б = std.utf.stride(т, и);\n\t\tif(б == 0xFF)\n\t\t\t{ win.скажинс(\"бцел байтЮ(ткст т, т_мера и): ткт[индкс] не является началом последовательности UTF-8\");\n\t\t\t}\n\t\treturn б;\n\t\t}\n\n\tбцел байтЮ(шткст т, т_мера и)\n\t\t{\n\t\tбцел б = std.utf.stride(т, и);\n\t\tif(б == 0xFF)\n\t\t\t{ win.скажинс(\"бцел байтЮ(шткст т, т_мера и): ткт[индкс] не является началом последовательности UTF-16\");\n\t\t\t}\n\t\treturn б;\n\t\t}\n\t\t\n\tбцел байтЮ(юткст т, т_мера и)\n\t\t{\n\t\tбцел б = std.utf.stride(т, и);\n\t\tif(б == 0xFF)\n\t\t\t{ win.скажинс(\"бцел байтЮ(юткст т, т_мера и): ткт[индкс] не является началом последовательности UTF-32\");\n\t\t\t}\n\t\treturn б;\n\t\t}\n\n\tт_мера кИндексуУНС(ткст т, т_мера и){return std.utf.toUCSindex(т, и);}\n\tт_мера кИндексуУНС(шткст т, т_мера и){return std.utf.toUCSindex(т, и);}\n\tт_мера кИндексуУНС(юткст т, т_мера и){return std.utf.toUCSindex(т, и);}\n\tт_мера вИндексЮ(ткст т, т_мера и){return std.utf.toUTFindex(т, и);}\n\tт_мера вИндексЮ(шткст т, т_мера и){return std.utf.toUTFindex(т, и);}\n\tт_мера вИндексЮ(юткст т, т_мера и){return std.utf.toUTFindex(т, и);}\n\tдим раскодируйЮ(ткст т, inout т_мера инд){return std.utf.decode(т, инд);}\n\tдим раскодируйЮ(шткст т, inout т_мера инд){return std.utf.decode(т, инд);}\n\tдим раскодируйЮ(юткст т, inout т_мера инд){return std.utf.decode(т, инд);}\n\tпроц кодируйЮ(inout ткст т, дим с){std.utf.encode(т, с);}\n\tпроц кодируйЮ(inout шткст т, дим с){std.utf.encode(т, с);}\n\tпроц кодируйЮ(inout юткст т, дим с){std.utf.encode(т, с);}\n\tпроц оцениЮ(ткст т){std.utf.validate(т);}\n\tпроц оцениЮ(шткст т){std.utf.validate(т);}\n\tпроц оцениЮ(юткст т){std.utf.validate(т);}\n\tткст вЮ8(сим[4] буф, дим с){return std.utf.toUTF8(буф, с);}\n\tткст вЮ8(ткст т){return std.utf.toUTF8(т);}\n\tткст вЮ8(шткст т){return std.utf.toUTF8(т);}\n\tткст вЮ8(юткст т){return std.utf.toUTF8(т);}\n\tшткст вЮ16(шим[2] буф, дим с){return std.utf.toUTF16(буф, с);}\n\tшткст вЮ16(ткст т){return std.utf.toUTF16(т);}\n\tшим* вЮ16н(ткст т){return std.utf.toUTF16z(т);}\n\tшткст вЮ16(шткст т){return std.utf.toUTF16(т);}\n\tшткст вЮ16(юткст т){return std.utf.toUTF16(т);}\n\tюткст вЮ32(ткст т){return std.utf.toUTF32(т);}\n\tюткст вЮ32(шткст т){return std.utf.toUTF32(т);}\n\tюткст вЮ32(юткст т){return std.utf.toUTF32(т);}\n\t\n\tт_время вЦел(т_время n)\t{\t\treturn n;\t}\n\n\tткст[] списпап(ткст имяп, РегВыр рег)//////\n\t{ \n\t\tткст[] результат;\n\n\t\tбул callback(ПапЗап* de)\n\t\t{\n\t\tif (de.папка_ли)\n\t\t\tсписпап(de.имя, &callback);\n\t\telse\n\t\t{   if (рег.проверь(de.имя))\n\t\t\tрезультат ~= de.имя;\n\t\t}\n\t\treturn да; // continue\n\t\t}\n\n\t\tсписпап(имяп, &callback);\n\t\treturn результат;\n\t}\n\t\n\tпроц списпап(ткст имяп, бул delegate(ткст имяф) обрвызов)//////\n\t\t{return listdir(имяп, обрвызов);}\n\t\n\tпроц списпап(ткст имяп, бул delegate(ПапЗап* пз) обрвызов)//////\n\t{\n\t    ткст c;\n    ук  h;\n    ПапЗап пз;\n\n    c = std.path.join(имяп, \"*.*\");\n    if (useWfuncs)\n    {\n\tПОИСК_ДАННЫХ fileinfo;\n\n\th = НайдиПервыйФайл(вЮ16(c), &fileinfo);\n\tif (h != cast(ук) НЕВЕРНХЭНДЛ)\n\t{\n\t    try\n\t    {\n\t\tdo\n\t\t{\n\t\t    // Skip \".\" and \"..\"\n\t\t    if (wcscmp(fileinfo.имяФайла.ptr, \".\") == 0 ||\n\t\t\twcscmp(fileinfo.имяФайла.ptr, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t    пз.иниц(имяп, &fileinfo);\n\t\t    if (!обрвызов(&пз))\n\t\t\tbreak;\n\t\t} while (НайдиСледующийФайл(h,&fileinfo) != нет);\n\t    }\n\t    finally\n\t    {\n\t\tНайдиЗакрой(h);\n\t    }\n\t}\n    }\n    else\n    {\n\tПОИСК_ДАННЫХ_А fileinfo;\n\n\th = cast(ук) НайдиПервыйФайлА(c, &fileinfo);\n\tif (h != cast(ук) НЕВЕРНХЭНДЛ)\t// should we throw exception if inзначid?\n\t{\n\t    try\n\t    {\n\t\tdo\n\t\t{\n\t\t    // Skip \".\" and \"..\"\n\t\t    if (cidrus.сравтекс(fileinfo.имяФайла.ptr, \".\") == 0 ||\n\t\t\tcidrus.сравтекс(fileinfo.имяФайла.ptr, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t    пз.иниц(имяп, &fileinfo);\n\t\t    if (!обрвызов(&пз))\n\t\t\tbreak;\n\t\t} while (НайдиСледующийФайлА(h,&fileinfo) != нет);\n\t    }\n\t    finally\n\t    {\n\t\tНайдиЗакрой(h);\n\t    }\n\t}\n    }\t\n }\t\n\nкреал син(креал x){return std.math.sin(x);}\nвреал син(вреал x){return std.math.sin(x);} \nреал абс(креал x){return std.math.abs(x);}\nреал абс(вреал x){return std.math.abs(x);}\nкреал квкор(креал x){return std.math.sqrt(x);}\nкреал кос(креал x){return std.math.cos(x);}\nкреал конъюнк(креал y){return std.math.conj(y);}\nвреал конъюнк(вреал y){return std.math.conj(y);}\nреал кос(вреал x){return std.math.cos(x);}\nреал степень(реал а, бцел н){return std.math.pow(а, н);}\n\nцел квадрат(цел а){return std.math2.sqr(а);}\nдол квадрат(цел а){return std.math2.sqr(а);}\nцел сумма(цел[] ч){return std.math2.sum(ч);}\nдол сумма(дол[] ч){return std.math2.sum(ч);}\nцел меньш_из(цел[] ч){return std.math2.min(ч);}\nдол меньш_из(дол[] ч){return std.math2.min(ч);}\nцел меньш_из(цел а, цел б){return std.math2.min(а, б);}\nдол меньш_из(дол а, дол б){return std.math2.min(а, б);}\nцел больш_из(цел[] ч){return std.math2.max(ч);}\nдол больш_из(дол[] ч){return std.math2.max(ч);}\nцел больш_из(цел а, цел б){return std.math2.max(а, б);}\nдол больш_из(дол а, дол б){return std.math2.max(а, б);}\n}//end of extern D\n\nexport extern(D)\n{\nпроц копируйФайл(ткст из, ткст в){copy(из, в);}\n\nсим* вМБТ_0(ткст т){return toMBSz(т);}\n\t\nimport std.date;\n\nпроц  вГодНедИСО8601(т_время t, out цел год, out цел неделя){ std.date.toISO8601YearWeek(t, год, неделя);}\n\t\nцел День(т_время t)\t{return cast(цел)std.date.floor(t, 86400000);\t}\n\nцел високосныйГод(цел y)\n\t{\n\t\treturn ((y & 3) == 0 &&\n\t\t\t(y % 100 || (y % 400) == 0));\n\t}\n\nцел днейВГоду(цел y)\t{\t\treturn 365 + std.date.LeapYear(y);\t}\n\nцел деньИзГода(цел y)\t{\t\treturn std.date.DayFromYear(y);\t}\n\nт_время времяИзГода(цел y)\t{\t\treturn cast(т_время) (msPerDay * std.date.DayFromYear(y));\t}\n\nцел годИзВрем(т_время t)\t{return std.date.YearFromTime(cast(d_time) t);}\t\n\t\nбул високосный_ли(т_время t)\n\t{\n\t\tif(std.date.LeapYear(std.date.YearFromTime(cast(d_time) t)) != 0)\n\t\treturn да;\n\t\telse return нет;\n\t}\n\nцел месИзВрем(т_время t)\t{return std.date.MonthFromTime(cast(d_time) t);\t}\n\nцел датаИзВрем(т_время t)\t{return std.date.DateFromTime(cast(d_time) t);\t}\n\nт_время нокругли(т_время d, цел делитель)\t{\treturn cast(т_время) std.date.floor(cast(d_time) d, делитель);\t\t}\n\t\nцел дмод(т_время n, т_время d)\t{   return std.date.dmod(n,d);\t}\n\nцел часИзВрем(т_время t)\t{\t\treturn std.date.dmod(std.date.floor(t, msPerHour), HoursPerDay);\t}\n\t\nцел минИзВрем(т_время t)\t{\t\treturn std.date.dmod(std.date.floor(t, msPerMinute), MinutesPerHour);\t}\n\t\nцел секИзВрем(т_время t)\t{\t\treturn std.date.dmod(std.date.floor(t, TicksPerSecond), 60);\t}\n\t\nцел мсекИзВрем(т_время t)\t{\t\treturn std.date.dmod(t / (TicksPerSecond / 1000), 1000);\t}\n\t\nцел времениВДне(т_время t)\t{\t\treturn std.date.dmod(t, msPerDay);\t}\n\t\nцел ДеньНедели(т_время вр){return std.date.WeekDay(вр);}\nт_время МВ8Местное(т_время вр){return cast(т_время) std.date.UTCtoLocalTime(вр);}\nт_время местное8МВ(т_время вр){return cast(т_время) std.date.LocalTimetoUTC(вр);}\nт_время сделайВремя(т_время час, т_время мин, т_время сек, т_время мс){return cast(т_время) std.date.MakeTime(час, мин, сек, мс);}\nт_время сделайДень(т_время год, т_время месяц, т_время дата){return cast(т_время) std.date.MakeDay(год, месяц, дата);}\nт_время сделайДату(т_время день, т_время вр){return cast(т_время) std.date.MakeDate(день, вр);}\n//d_time TimeClip(d_time время)\nцел датаОтДняНеделиМесяца(цел год, цел месяц, цел день_недели, цел ч){return  std.date.DateFromNthWeekdayOfMonth(год, месяц, день_недели, ч);}\nцел днейВМесяце(цел год, цел месяц){return std.date.DaysInMonth(год, месяц);}\nткст вТкст(т_время время){return std.date.toString(время);}\nткст вТкстМВ(т_время время){return std.date.toUTCString(время);}\nткст вТкстДаты(т_время время){return std.date.toDateString(время);}\nткст вТкстВремени(т_время время){return std.date.toTimeString(время);}\nт_время разборВремени(ткст т){return cast(т_время) std.date.parse(т);}\nт_время дайВремяМВ(){return cast(т_время) std.date.getUTCtime();}\nт_время ФВРЕМЯ8т_время(ФВРЕМЯ *фв){return cast(т_время) std.date.FILETIME2d_time(фв);}\nт_время СИСТВРЕМЯ8т_время(СИСТВРЕМЯ *св, т_время вр){return cast(т_время) std.date.SYSTEMTIME2d_time(св,cast(дол) вр);}\nт_время дайМестнуюЗЧП(){return cast(т_время) std.date.дайЛокTZA();}\nцел дневноеСохранениеЧО(т_время вр){return std.date.DaylightSavingTA(вр);}\nт_время вДвремя(ФВремяДос вр){return cast(т_время) std.date.toDtime(cast(DosFileTime) вр);}\nФВремяДос вФВремяДос(т_время вр){return cast(ФВремяДос) std.date.toDosFileTime(вр);}\n\nimport std.cpuid:mmx,fxsr,sse,sse2,sse3,ssse3,amd3dnow,amd3dnowExt,amdMmx,ia64,amd64,hyperThreading, vendor, processor,family,model,stepping,threadsPerCPU,coresPerCPU;\n\nexport extern(D) struct Процессор\n{\n\texport:\n\n\tткст производитель()\t{return std.cpuid.vendor();}\n\tткст название()\t\t\t{return std.cpuid.processor();}\n\tбул поддержкаММЭкс()\t{return std.cpuid.mmx();}\n\tбул поддержкаФЭксСР()\t{return std.cpuid.fxsr();}\n\tбул поддержкаССЕ()\t\t{return std.cpuid.sse();}\n\tбул поддержкаССЕ2()\t\t{return std.cpuid.sse2();}\n\tбул поддержкаССЕ3()\t\t{return std.cpuid.sse3();}\n\tбул поддержкаСССЕ3()\t{return std.cpuid.ssse3();}\n\tбул поддержкаАМД3ДНау()\t{return std.cpuid.amd3dnow();}\n\tбул поддержкаАМД3ДНауЭкст(){return std.cpuid.amd3dnowExt();}\n\tбул поддержкаАМДММЭкс()\t{return std.cpuid.amdMmx();}\n\tбул являетсяИА64()\t\t{return std.cpuid.ia64();}\n\tбул являетсяАМД64()\t\t{return std.cpuid.amd64();}\n\tбул поддержкаГиперПоточности(){return std.cpuid.hyperThreading();}\n\tбцел потоковНаЦПБ()\t\t{return std.cpuid.threadsPerCPU();}\n\tбцел ядерНаЦПБ()\t\t{return std.cpuid.coresPerCPU();}\n\tбул являетсяИнтел()\t\t{return std.cpuid.intel();}\n\tбул являетсяАМД()\t\t{return std.cpuid.amd();}\n\tбцел поколение()\t\t{return std.cpuid.stepping();}\n\tбцел модель()\t\t\t{return std.cpuid.model();}\n\tбцел семейство()\t\t{return std.cpuid.family();}\n\tткст вТкст()\t\t\t{return о_ЦПУ();}\n}\n\nткст о_ЦПУ(){\n\n\tткст feats;\n\tif (mmx)\t\t\tfeats ~= \"MMX \";\n\tif (fxsr)\t\t\tfeats ~= \"FXSR \";\n\tif (sse)\t\t\tfeats ~= \"SSE \";\n\tif (sse2)\t\t\tfeats ~= \"SSE2 \";\n\tif (sse3)\t\t\tfeats ~= \"SSE3 \";\n\tif (ssse3)\t\t\tfeats ~= \"SSSE3 \";\n\tif (amd3dnow)\t\t\tfeats ~= \"3DNow! \";\n\tif (amd3dnowExt)\t\tfeats ~= \"3DNow!+ \";\n\tif (amdMmx)\t\t\tfeats ~= \"MMX+ \";\n\tif (ia64)\t\t\tfeats ~= \"IA-64 \";\n\tif (amd64)\t\t\tfeats ~= \"AMD64 \";\n\tif (hyperThreading)\t\tfeats ~= \"HTT\";\n\n\tткст цпу = фм(\n\t\t\"\\t\\tИНФОРМАЦИЯ О ЦПУ ДАННОГО КОМПЬЮТЕРА\\n\\t**************************************************************\\n\\t\"~\n\t\t\" Производитель   \\t|   %s                                 \\n\\t\"~\"--------------------------------------------------------------\\n\\t\", vendor(),\n\t\t\" Процессор       \\t|   %s                                 \\n\\t\"~\"--------------------------------------------------------------\\n\\t\", processor(),\n\t\t\" Сигнатура     \\t| Семейство %d | Модель %d | Поколение %d \\n\\t\"~\"--------------------------------------------------------------\\n\\t\", family(), model(), stepping(),\n\t\t\" Функции         \\t|   %s                                 \\n\\t\"~\"--------------------------------------------------------------\\n\\t\", feats,\n\t\t\" Многопоточность \\t|  %d-поточный / %d-ядерный            \\n\\t\"~\"**************************************************************\", threadsPerCPU(), coresPerCPU());\n\treturn цпу;\n\n    }\n\nimport std.path;\n\nткст извлекиРасш(ткст полнимя){return std.path.getExt(полнимя);}\n//getExt(r\"d:\\путь\\foo.bat\") // \"bat\"     getExt(r\"d:\\путь.two\\bar\") // null\nткст дайИмяПути(ткст полнимя){return std.path.getName(полнимя);}\n//getName(r\"d:\\путь\\foo.bat\") => \"d:\\путь\\foo\"     getName(r\"d:\\путь.two\\bar\") => null\nткст извлекиИмяПути(ткст пимя){return std.path.getBaseName(пимя);}//getBaseName(r\"d:\\путь\\foo.bat\") => \"foo.bat\"\nткст извлекиПапку(ткст пимя){return std.path.getDirName(пимя);}\n//getDirName(r\"d:\\путь\\foo.bat\") => \"d:\\путь\"     getDirName(getDirName(r\"d:\\путь\\foo.bat\")) => r\"d:\\\"\nткст извлекиМеткуДиска(ткст пимя){return std.path.getDrive(пимя);}\nткст устДефРасш(ткст пимя, ткст расш){return std.path.defaultExt(пимя, расш);}\nткст добРасш(ткст фимя, ткст расш){return std.path.addExt(фимя, расш);}\nбул абсПуть_ли(ткст путь){return cast(бул) std.path.isabs(путь);}\nткст слейПути(ткст п1, ткст п2){return std.path.join(п1, п2);}\nбул сравниПути(дим п1, дим п2){return cast(бул) std.path.fncharmatch(п1, п2);}\nбул сравниПутьОбразец(ткст фимя, ткст образец){return cast(бул) std.path.fnmatch(фимя, образец);}\nткст разверниТильду(ткст путь){return std.path.expandTilde(путь);}\n\nбул выведиФайл(ткст имяф){ скажи(cast(ткст) читайФайл(имяф)); return да;}\n\n\n}///end of extern C\n\n\nexport extern(D) struct Дата\n\t{\nexport:\n\tцел год;\t/// use цел.min as \"nan\" year значение\n    цел месяц;\t\t/// 1..12\n    цел день;\t\t/// 1..31\n    цел час;\t\t/// 0..23\n    цел минута;\t\t/// 0..59\n    цел секунда;\t\t/// 0..59\n    цел мс;\t\t/// 0..999\n    цел день_недели;\t/// 0: not specified, 1..7: Sunday..Saturday\n    цел коррекцияЧП;\t/// -1200..1200 correction in hours\n\n    /// Разбор даты из текста т[] и сохранение её как экземпляра Даты.\n\n    проц разбор(ткст т)\n    {\n\t\tДата а = разборДаты(т);\n\t\tгод = а.год;\t/// use цел.min as \"nan\" year значение\n\t\tмесяц = а.месяц;\t\t/// 1..12\n\t\tдень =а.день;\t\t/// 1..31\n\t\tчас =а.час;\t\t/// 0..23\n\t\tминута = а.минута;\t\t/// 0..59\n\t\tсекунда = а.секунда;\t\t/// 0..59\n\t\tмс = а.мс;\t\t/// 0..999\n\t\tдень_недели = а.день_недели;\t/// 0: not specified, 1..7: Sunday..Saturday\n\t\tкоррекцияЧП = а.коррекцияЧП;\t\t\n    }\n\n}\n\nprivate Дата вДату(Date d, out Дата рез)\n{\n\t//Дата рез;\n\tрез.год = d.year ;\t/// use цел.min as \"nan\" year значение\n    рез.месяц = d.month;\t\t/// 1..12\n    рез.день = d.day;\t\t/// 1..31\n    рез.час = d.hour;\t\t/// 0..23\n    рез.минута = d.minute;\t\t/// 0..59\n    рез.секунда = d.second;\t\t/// 0..59\n    рез.мс = d.ms;\t\t/// 0..999\n    рез.день_недели = d.weekday;\t/// 0: not specified, 1..7: Sunday..Saturday\n    рез.коррекцияЧП = d.tzcorrection;\n\treturn рез;\n}\n\n\nimport std.dateparse;\n\nexport extern(D) Дата разборДаты(ткст т)\n{\t\nDateParse dp;\nDate d;\nДата д;\ndp.parse(т, d);\n\t вДату(d, д);\n\treturn  д;\t\n}\n\t\n\t\nexport extern(D) struct ПапЗап\n\t{\n\t\nprivate DirEntry de;\n\n\n\n\tткст имя;\n    бдол размер = ~0UL;\n    т_время времяСоздания = т_время_нч;\n    т_время времяПоследнегоДоступа = т_время_нч;\t\n    т_время времяПоследнейЗаписи = т_время_нч;\n    бцел атрибуты;\n\n  export  проц иниц(ткст путь, ПОИСК_ДАННЫХ_А *дф)\n    {\n\tde.init(путь, дф);\n\tимя = de.имя;\n    размер = de.размер;\n    времяСоздания = cast(т_время) de.creationTime;\n    времяПоследнегоДоступа =cast(т_время) de.lastAccessTime ;\t\n    времяПоследнейЗаписи = cast(т_время) de.lastWriteTime ;\n    атрибуты = de.attributes;\n    }\n\n  export   проц иниц(ткст путь, ПОИСК_ДАННЫХ *дф)\n    {\n\tde.init(путь, дф);\n\tимя = de.имя;\n    размер = de.размер;\n    времяСоздания = cast(т_время) de.creationTime;\n    времяПоследнегоДоступа =cast(т_время) de.lastAccessTime ;\t\n    времяПоследнейЗаписи = cast(т_время) de.lastWriteTime ;\n    атрибуты = de.attributes;\n    }\n\n  export  бцел папка_ли()\n    {\n\treturn de.isdir();\n    }\n\n  export бцел файл_ли()\n    {\n\treturn de.isfile();\n    }\n\t\nDirEntry вДирЭнтри()\n\t{\n\tde.имя = имя;\n    de.размер = размер;\n    de.creationTime = времяСоздания;\n    de.lastAccessTime = времяПоследнегоДоступа;\t\n    de.lastWriteTime = времяПоследнейЗаписи;\n    de.attributes = атрибуты;\n\treturn de;\n\t}\n\n\t\n\n}\n\nimport std.outbuffer;\n\nexport extern (D) class БуферВывода\n{\n\n\n\nббайт данные[];\nбцел смещение;\n\ninvariant\n    {\n\t//say(format(\"this = %p, смещение = %x, данные.length = %u\\n\", this, смещение, данные.length));\n\tassert(смещение <= данные.length);\n\tassert(данные.length <= смЁмкость(данные.ptr));\n    }\n\t\n\texport this()\n    {\n\t//say(\"in OutBuffer constructor\\n\");\n\t}\n\t\nexport\tббайт[] вБайты() { return данные[0 .. смещение]; }\n\t\nexport\tпроц резервируй(бцел члобайт)\n\tin\n\t{\n\t    assert(смещение + члобайт >= смещение);\n\t}\n\tout\n\t{\n\t    assert(смещение + члобайт <= данные.length);\n\t    assert(данные.length <= смЁмкость(данные.ptr));\n\t}\n\tbody\n\t{\n\t    if (данные.length < смещение + члобайт)\n\t    {\n\t\tданные.length = (смещение + члобайт) * 2;\n\t\tsetTypeInfo(null, данные.ptr);\n\t    }\n\t}\n\n export   проц пиши(ббайт[] байты)\n\t{\n\t    резервируй(байты.length);\n\t    данные[смещение .. смещение + байты.length] = байты;\n\t    смещение += байты.length;\n\t}\n\n  export  проц пиши(ббайт b)\t\t/// ditto\n\t{\n\t    резервируй(ббайт.sizeof);\n\t    this.данные[смещение] = b;\n\t    смещение += ббайт.sizeof;\n\t}\n\n  export  проц пиши(байт b) { пиши(cast(ббайт)b); }\t\t/// ditto\n export   проц пиши(сим c) { пиши(cast(ббайт)c); }\t\t/// ditto\n\n export   проц пиши(бкрат w)\t\t/// ditto\n    {\n\tрезервируй(бкрат.sizeof);\n\t*cast(бкрат *)&данные[смещение] = w;\n\tсмещение += бкрат.sizeof;\n    }\n\n  export  проц пиши(крат т) { пиши(cast(бкрат)т); }\t\t/// ditto\n\n  export  проц пиши(шим c)\t\t/// ditto\n    {\n\tрезервируй(шим.sizeof);\n\t*cast(шим *)&данные[смещение] = c;\n\tсмещение += шим.sizeof;\n    }\n\n  export  проц пиши(бцел w)\t\t/// ditto\n    {\n\tрезервируй(бцел.sizeof);\n\t*cast(бцел *)&данные[смещение] = w;\n\tсмещение += бцел.sizeof;\n    }\n\n  export  проц пиши(цел i) { пиши(cast(бцел)i); }\t\t/// ditto\n\n  export  проц пиши(бдол l)\t\t/// ditto\n    {\n\tрезервируй(бдол.sizeof);\n\t*cast(бдол *)&данные[смещение] = l;\n\tсмещение += бдол.sizeof;\n    }\n\n  export  проц пиши(дол l) { пиши(cast(бдол)l); }\t\t/// ditto\n\n   export проц пиши(плав f)\t\t/// ditto\n    {\n\tрезервируй(плав.sizeof);\n\t*cast(плав *)&данные[смещение] = f;\n\tсмещение += плав.sizeof;\n    }\n\n   export проц пиши(дво f)\t\t/// ditto\n    {\n\tрезервируй(дво.sizeof);\n\t*cast(дво *)&данные[смещение] = f;\n\tсмещение += дво.sizeof;\n    }\n\n  export  проц пиши(реал f)\t\t/// ditto\n    {\n\tрезервируй(реал.sizeof);\n\t*cast(реал *)&данные[смещение] = f;\n\tсмещение += реал.sizeof;\n    }\n\n   export проц пиши(ткст т)\t\t/// ditto\n    {\n\tпиши(cast(ббайт[])т);\n    }\n\n   export проц пиши(БуферВывода буф)\t\t/// ditto\n    {\n\tпиши(буф.вБайты());\n    }\n\n    /****************************************\n     * Добавка члобайт of 0 to the internal буфер.\n     */\n\n  export  проц занули(бцел члобайт)\n    {\n\tрезервируй(члобайт);\n\tданные[смещение .. смещение + члобайт] = 0;\n\tсмещение += члобайт;\n    }\n\n    /**********************************\n     * 0-fill to align on power of 2 boundary.\n     */\n\n  export  проц расклад(бцел мера)\n    in\n    {\n\tassert(мера && (мера & (мера - 1)) == 0);\n    }\n    out\n    {\n\tassert((смещение & (мера - 1)) == 0);\n    }\n    body\n    {   бцел члобайт;\n\n\tчлобайт = смещение & (мера - 1);\n\tif (члобайт)\n\t    занули(мера - члобайт);\n    }\n\n    /****************************************\n     * Optimize common special case расклад(2)\n     */\n\n  export  проц расклад2()\n    {\n\tif (смещение & 1)\n\t    пиши(cast(байт)0);\n    }\n\n    /****************************************\n     * Optimize common special case расклад(4)\n     */\n\n   export проц расклад4()\n    {\n\tif (смещение & 3)\n\t{   бцел члобайт = (4 - смещение) & 3;\n\t    занули(члобайт);\n\t}\n    }\n\n    /**************************************\n     * Convert internal буфер to array of симs.\n     */\n\n   export ткст вТкст()\n    {\n\t//эхо(\"БуферВывода.вТкст()\\n\");\n\treturn cast(сим[])данные[0 .. смещение];\n    }\n\n    /*****************************************\n     * Добавка output of C'т vprintf() to internal буфер.\n     */\n\n  export  проц ввыводф(ткст формат, спис_ва арги)\n    {\n\tсим[128] буфер;\n\tсим* p;\n\tбцел psize;\n\tцел count;\n\n\tauto f = вТкст0(формат);\n\tp = буфер.ptr;\n\tpsize = буфер.length;\n\tfor (;;)\n\t\t{\n\t\t\tcount = _vsnprintf(p,psize,f,арги);\n\t\t\tif (count != -1)\n\t\t\t\tbreak;\n\t\t\tpsize *= 2;\n\t\t\tp = cast(сим *) cidrus.alloca(psize);\t// буфер too small, try again with larger размер\n\t\t}\n\tпиши(p[0 .. count]);\n    }\n\n    /*****************************************\n     * Добавка output of C'т эхо() to internal буфер.\n     */\n\n  export  проц выводф(ткст формат, ...)\n    {\n\tспис_ва ap;\n\tap = cast(спис_ва)&формат;\n\tap += формат.sizeof;\n\tввыводф(формат, ap);\n    }\n\n    /*****************************************\n     * At смещение index целo буфер, создай члобайт of space by shifting upwards\n     * all данные past index.\n     */\n\n  export  проц простели(бцел индекс, бцел члобайт)\n\tin\n\t{\n\t    assert(индекс <= смещение);\n\t}\n\tbody\n\t{\n\t    резервируй(члобайт);\n\n\t    // This is an overlapping copy - should use memmove()\n\t    for (бцел i = смещение; i > индекс; )\n\t    {\n\t\t--i;\n\t\tданные[i + члобайт] = данные[i];\n\t    }\n\t    смещение += члобайт;\n\t}\n\t\n\texport ~this(){}\n}\n\n\n\nexport extern(D)\n{\n\nткст ДАТА()\n{\nСИСТВРЕМЯ систВремя;\nДайМестнВремя(&систВремя);\nткст ДАТА = вТкст(систВремя.день)~\".\"~вТкст(систВремя.месяц)~\".\"~вТкст(систВремя.год);\nreturn  ДАТА;\n}\n\nткст ВРЕМЯ()\n{\nСИСТВРЕМЯ систВремя;\nДайМестнВремя(&систВремя);\nткст ВРЕМЯ = вТкст(систВремя.час)~\" ч. \"~вТкст(систВремя.минута)~\" мин.\";\nreturn  ВРЕМЯ;\n}\n\n\t\nimport std.math;\n\nреал абс(реал x){return std.math.abs(x);}\nдол абс(дол x){return std.math.abs(x);}\nцел абс(цел x){return std.math.abs(x);}\nреал кос(реал x){return std.math.cos(x);}\nреал син(реал x){return std.math.sin(x);}\nреал тан(реал x){return std.math.tan(x);}\nреал акос(реал x){return std.math.acos(x);}\nреал асин(реал x){return std.math.asin(x);}\nреал атан(реал x){return std.math.atan(x);}\nреал атан2(реал y, реал x){return std.math.atan2(x, y);}\nреал гкос(реал x){return std.math.cosh(x);}\nреал гсин(реал x){return std.math.sinh(x);}\nреал гтан(реал x){return std.math.tanh(x);}\nреал гакос(реал x){return std.math.acosh(x);}\nреал гасин(реал x){return std.math.asinh(x);}\nреал гатан(реал x){return std.math.atanh(x);}\nдол округливдол(реал x){return std.math.rndtol(x);}\nреал округливближдол(реал x){return std.math.rndtonl(x);}\nплав квкор(плав x){return std.math.sqrt(x);}\nдво квкор(дво x){return std.math.sqrt(x);}\nреал квкор(реал x){return std.math.sqrt(x);}\nреал эксп(реал x){return std.math.exp(x);}\nреал экспм1(реал x){return std.math.expm1(x);}\nреал эксп2(реал x){return std.math.exp2(x);}\nкреал экспи(реал x){return std.math.expi(x);}\nреал прэксп(реал знач, out цел эксп){return std.math.frexp(знач, эксп);}\nцел илогб(реал x){return std.math.ilogb(x);}\nреал лдэксп(реал н, цел эксп){return std.math.ldexp(н, эксп);}\nреал лог(реал x){return std.math.log(x);}\nреал лог10(реал x){return std.math.log10(x);}\nреал лог1п(реал x){return std.math.log1p(x);}\nреал лог2(реал x){return std.math.log2(x);}\nреал логб(реал x){return std.math.logb(x);}\nреал модф(реал x, inout реал y){return std.math.modf(x, y);}\nреал скалбн(реал x, цел н){return std.math.scalbn(x,н);}\nреал кубкор(реал x){return std.math.cbrt(x);}\nреал фабс(реал x){return std.math.fabs(x);}\nреал гипот(реал x, реал y){return std.math.hypot(x, y);}\nреал фцош(реал x){return std.math.erf(x);}\nреал лгамма(реал x){return std.math.lgamma(x);}\nреал тгамма(реал x){return std.math.tgamma(x);}\nреал потолок(реал x){return std.math.ceil(x);}\nреал пол(реал x){return std.math.floor(x);}\nреал ближцел(реал x){return std.math.nearbyint(x);}\n\nцел окрвцел(реал x)\n{\n    //version(Naked_D_InlineAsm_X86)\n   // {\n        цел n;\n        asm\n        {\n            fld x;\n            fistp n;\n        }\n        return n;\n  //  }\n  //  else\n  //  {\n   //     return cidrus.lrintl(x);\n   // }\n}\nреал окрвреал(реал x){return std.math.rint(x);}\nдол окрвдол(реал x){return std.math.lrint(x);}\nреал округли(реал x){return std.math.round(x);}\nдол докругли(реал x){return std.math.lround(x);}\nреал упрости(реал x){return std.math.trunc(x);}\nреал остаток(реал x, реал y){return std.math.remainder(x, y);}\nбул нч_ли(реал x){return cast(бул) std.math.isnan(x);}\nбул конечен_ли(реал р){return cast(бул) std.math.isfinite(р);}\n\nбул субнорм_ли(плав п){return cast(бул) std.math.issubnormal(п);}\nбул субнорм_ли(дво п){return cast(бул) std.math.issubnormal(п);}\nбул субнорм_ли(реал п){return cast(бул) std.math.issubnormal(п);}\nбул беск_ли(реал р){return cast(бул) std.math.isinf(р);}\nбул идентичен_ли(реал р, реал д){return std.math.isIdentical(р, д);}\nбул битзнака(реал р){ if(1 == std.math.signbit(р)){return да;} return нет;}\nреал копируйзнак(реал кому, реал у_кого){return std.math.copysign(кому, у_кого);}\nреал нч(ткст тэгп){return std.math.nan(тэгп);}\nреал следщБольш(реал р){return std.math.nextUp(р);}\nдво следщБольш(дво р){return std.math.nextUp(р);}\nплав следщБольш(плав р){return std.math.nextUp(р);}\nреал следщМеньш(реал р){return std.math.nextUp(р);}\nдво следщМеньш(дво р){return std.math.nextUp(р);}\nплав следщМеньш(плав р){return std.math.nextUp(р);}\nреал следщза(реал а, реал б){return std.math.nextafter(а, б);}\nплав следщза(плав а, плав б){return std.math.nextafter(а, б);}\nдво следщза(дво а, дво б){return std.math.nextafter(а, б);}\nреал пдельта(реал а, реал б){return std.math.fdim(а, б);}\nреал пбольш_из(реал а, реал б){return std.math.fmax(а, б);}\nреал пменьш_из(реал а, реал б){return std.math.fmin(а, б);}\n\nреал степень(реал а, цел н){return std.math.pow(а, н);}\nреал степень(реал а, реал н){return std.math.pow(а, н);}\n\nimport std.math2;\n\nбул правны(реал а, реал б){return std.math2.feq(а, б);}\nбул правны(реал а, реал б, реал эпс){return std.math2.feq(а, б, эпс);}\n\nреал квадрат(цел а){return std.math2.sqr(а);}\nреал дробь(реал а){return std.math2.frac(а);}\nцел знак(цел а){return std.math2.sign(а);}\nцел знак(дол а){return std.math2.sign(а);}\nцел знак(реал а){return std.math2.sign(а);}\nреал цикл8градус(реал ц){return std.math2.cycle2deg(ц);}\nреал цикл8радиан(реал ц){return std.math2.cycle2rad(ц);}\nреал цикл8градиент(реал ц){return std.math2.cycle2grad(ц);}\nреал градус8цикл(реал г){return std.math2.deg2cycle(г);}\nреал градус8радиан(реал г){return std.math2.deg2rad(г);}\nреал градус8градиент(реал г){return std.math2.deg2grad(г);}\nреал радиан8градус(реал р){return std.math2.rad2deg(р);}\nреал радиан8цикл(реал р){return std.math2.rad2cycle(р);}\nреал радиан8градиент(реал р){return std.math2.rad2grad(р);}\nреал градиент8градус(реал г){return std.math2.grad2deg(г);}\nреал градиент8цикл(реал г){return std.math2.grad2cycle(г);}\nреал градиент8радиан(реал г){return std.math2.grad2rad(г);}\nреал сариф(реал[] ч){return std.math2.avg(ч);}\nреал сумма(реал[] ч){return std.math2.sum(ч);}\nреал меньш_из(реал[] ч){return std.math2.min(ч);}\nреал меньш_из(реал а, реал б){return std.math2.min(а, б);}\nреал больш_из(реал[] ч){return std.math2.max(ч);}\nреал больш_из(реал а, реал б){return std.math2.max(а, б);}\nреал акот(реал р){return std.math2.acot(р);}\nреал асек(реал р){return std.math2.asec(р);}\nреал акосек(реал р){return std.math2.acosec(р);}\nреал кот(реал р){return std.math2.cot(р);}\nреал сек(реал р){return std.math2.sec(р);}\nреал косек(реал р){return std.math2.cosec(р);}\nреал гкот(реал р){return std.math2.coth(р);}\nреал гсек(реал р){return std.math2.sech(р);}\nреал гкосек(реал р){return std.math2.cosech(р);}\nреал гакот(реал р){return std.math2.acoth(р);}\nреал гасек(реал р){return std.math2.asech(р);}\nреал гакосек(реал р){return std.math2.acosech(р);}\nреал ткст8реал(ткст т){return std.math2.atof(т);} \n\n\nimport std.regexp;\n\n\nткст подставь(ткст текст, ткст образец, ткст формат, ткст атрибуты = null)\n\t{\n\treturn std.regexp.sub(текст, образец, формат, атрибуты);\n\t}\n}//end of extern C\n\nexport extern(D) ткст подставь(ткст текст, ткст образец, ткст delegate(РегВыр) дг, ткст атрибуты = null)\n\t{\n\t  auto r = РегВыр(образец, атрибуты);\n    рсим[] результат;\n    цел последниндкс;\n    цел смещение;\n\n    результат = текст;\n    последниндкс = 0;\n    смещение = 0;\n    while (r.проверь(текст, последниндкс))\n    {\n\tцел so = r.псовп[0].рснач;\n\tцел eo = r.псовп[0].рскон;\n\n\tрсим[] замена = дг(r);\n\n\t// Optimize by using std.string.replace if possible - Dave Fladebo\n\tрсим[] срез = результат[смещение + so .. смещение + eo];\n\tif (r.атрибуты & РегВыр.РВА.глоб &&\t\t// глоб, so replace all\n\t    !(r.атрибуты & РегВыр.РВА.любрег) &&\t// not ignoring case\n\t    !(r.атрибуты & РегВыр.РВА.многострок) &&\t// not многострок\n\t    образец == срез)\t\t\t\t// simple образец (exact match, no special символs) \n\t{\n\t    debug(РегВыр)\n\t\twin.скажинс(фм(\"образец: %s, срез: %s, замена: %s\\n\", образец, результат[смещение + so .. смещение + eo],замена));\n\t    результат = замени(результат,срез,замена);\n\t    break;\n\t}\n\n\tрезультат = replaceSlice(результат, результат[смещение + so .. смещение + eo], замена);\n\n\tif (r.атрибуты & РегВыр.РВА.глоб)\n\t{\n\t    смещение += замена.length - (eo - so);\n\n\t    if (последниндкс == eo)\n\t\tпоследниндкс++;\t\t// always consume some source\n\t    else\n\t\tпоследниндкс = eo;\n\t}\n\telse\n\t    break;\n    }\n    delete r;\n\n    return результат;\n\n\t}\n\t\nexport extern(D) РегВыр ищи(ткст текст, ткст образец, ткст атрибуты = null)\n\t{\n\tauto r = РегВыр(образец, атрибуты);\n\n    if (r.проверь(текст))\n\t\t{\n\t\t}\n\t\telse\n\t\t{\tdelete r;\n\t\tr = null;\n\t\t}\n    return r;\n\t}\n\nexport extern (D)\n{\n\tцел найди(рткст текст, ткст образец, ткст атрибуты = null)//Возврат -1=совпадений нет, иначе=индекс совпадения\n\t\t{\n\t\t\n\t//debug win.скажинс(\"РегВыр.найди\");\n\t//debug win.скажинс(текст);\n\t\t    int i = -1;\n\n    auto r = new РегВыр(образец, атрибуты);\n    if (r.проверь(текст))\n    {\n\ti = r.псовп[0].рснач;\n    }\n    delete r;\n    return i;\n\n\t\t//return std.regexp.find(текст, образец, атрибуты);\n\t\t}\n\n\tцел найдирек(рткст текст, ткст образец, ткст атрибуты = null)\n\t\t{\n\t\treturn std.regexp.rfind(текст, образец, атрибуты);\n\t\t}\n\n\tткст[] разбей(ткст текст, ткст образец, ткст атрибуты = null)\n\t\t{\n\t//debug win.скажинс(текст);\n\tauto r = new РегВыр(образец, атрибуты);\n    auto результат = r.разбей(текст);\n    delete r;\n    return результат;\n\n\t\t//return std.regexp.split(текст, образец, атрибуты);\n\t\t}\n\nimport std.uni;\n\nбул юпроп_ли(дим с){return cast(бул) std.uni.isUniLower(с);}\nбул юзаг_ли(дим с){return cast(бул) std.uni.isUniUpper(с);}\nдим в_юпроп(дим с){return std.uni.toUniLower(с);}\nдим в_юзаг(дим с){return std.uni.toUniUpper(с);}\nбул юцб_ли(дим с){return cast(бул) std.uni.isUniAlpha(с);}\n\nimport std.uri;\n\nбцел аски8гекс(дим с){return std.uri.ascii2hex(с);}\nткст раскодируйУИР(ткст кодирУИР){return std.uri.decode(кодирУИР);}\nткст раскодируйКомпонентУИР(ткст кодирКомпонУИР){return std.uri.decodeComponent(кодирКомпонУИР);}\nткст кодируйУИР(ткст уир){return std.uri.encode(уир);}\nткст кодируйКомпонентУИР(ткст уирКомпон){return std.uri.encodeComponent(уирКомпон);}\n\nimport std.zlib;\n\nбцел адлер32(бцел адлер, проц[] буф){return std.zlib.adler32(адлер, буф);}\nбцел цпи32(бцел кс, проц[] буф){return std.zlib.crc32(кс, буф);}\n\nпроц[] сожмиЗлиб(проц[] истбуф, цел ур = цел.init)\n\t{\n\tif(ур) return std.zlib.compress(истбуф, ур);\n\telse return std.zlib.compress(истбуф);\n\t}\n\nпроц[] разожмиЗлиб(проц[] истбуф, бцел итдлин = 0u, цел винбиты = 15){return std.zlib.uncompress(истбуф, итдлин, винбиты);}\n\nimport std.crc32;\n\nбцел иницЦПИ32(){return std.crc32.init_crc32();}\nбцел обновиЦПИ32б(ббайт зн, бцел црц){return std.crc32.update_crc32(зн, црц);}\nбцел обновиЦПИ32с(сим зн, бцел црц){return std.crc32.update_crc32(зн, црц);}\nбцел ткстЦПИ32(ткст т){return std.crc32.crc32(т);}\n\n}\t\n\nexport extern(D) class СжатиеЗлиб\n{\nprivate std.zlib.Compress zc;\n\nexport:\n\tenum\n\t{\n\t\tБЕЗ_СЛИВА      = 0,\n\t\tСИНХ_СЛИВ    = 2,\n\t\tПОЛН_СЛИВ    = 3,\n\t\tФИНИШ       = 4,\n\t}\n\n\tthis(цел ур){zc = new std.zlib.Compress(ур);}\n\tthis(){zc = new std.zlib.Compress();}\n\t~this(){delete zc;}\n\tпроц[] сжать(проц[] буф){return  zc.compress(буф);}\n\tпроц[] слей(цел режим = ФИНИШ){return  zc.flush(режим);}\n}\n\nexport extern(D) class РасжатиеЗлиб\n{\nprivate std.zlib.UnCompress zc;\n\nexport:\n\t\n\tthis(бцел размБуфЦели){zc = new std.zlib.UnCompress(размБуфЦели);}\n\tthis(){zc = new std.zlib.UnCompress;}\n\t~this(){delete zc;}\n\tпроц[] расжать(проц[] буф){return  zc.uncompress(буф);}\n\tпроц[] слей(){return  zc.flush();}\n}\n\n\n\nexport extern(D) class ИсключениеРегВыр : Исключение\n{\nexport:\n    this(ткст сооб)\n    {\n\tsuper(\"Неудачная операция с регулярным выражением: \"~сооб,__FILE__,__LINE__);\n\t}\n}\n\n\nexport extern (D) class РегВыр\n{\n\n   export ~this(){};\n\n    export this(рсим[] образец, рсим[] атрибуты = null)\n    {\n\tпсовп = (&гсовп)[0 .. 1];\n\tкомпилируй(образец, атрибуты);\n    }\n\n    export static РегВыр opCall(рсим[] образец, рсим[] атрибуты = null)\n    {\n\treturn new РегВыр(образец, атрибуты);\n    }\n\n    export РегВыр ищи(рсим[] текст)\n    {\n\tввод = текст;\n\tпсовп[0].рскон = 0;\n\treturn this;\n    }\n\n    /** ditto */\n   export  цел opApply(цел delegate(inout РегВыр) дг)\n    {\n\tцел результат;\n\tРегВыр r = this;\n\n\twhile (проверь())\n\t{\n\t    результат = дг(r);\n\t    if (результат)\n\t\tbreak;\n\t}\n\n\treturn результат;\n    }\n\n   export  ткст сверь(т_мера n)\n    {\n\tif (n >= псовп.length)\n\t    return null;\n\telse\n\t{   т_мера рснач, рскон;\n\t    рснач = псовп[n].рснач;\n\t    рскон = псовп[n].рскон;\n\t    if (рснач == рскон)\n\t\treturn null;\n\t    return ввод[рснач .. рскон];\n\t}\n    }\n\n   export  ткст перед()\n    {\n\treturn ввод[0 .. псовп[0].рснач];\n    }\n\n   export  ткст после()\n    {\n\treturn ввод[псовп[0].рскон .. $];\n    }\n\n    бцел члоподстр;\t\t// number of parenthesized subexpression matches\n    т_регсвер[] псовп;\t// array [члоподстр + 1]\n\n    рсим[] ввод;\t\t// the текст to ищи\n\n    // per instance:\n\n    рсим[] образец;\t\t// source text of the regular expression\n\n    рсим[] флаги;\t\t// source text of the атрибуты parameter\n\n    цел ошибки;\n\n    бцел атрибуты;\n\n    enum РВА\n    {\n\tглоб\t\t= 1,\t// has the g attribute\n\tлюбрег\t= 2,\t// has the i attribute\n\tмногострок\t= 4,\t// if treat as multiple lines separated\n\t\t\t\t// by newlines, or as a single строка\n\tтчксовплф\t= 8,\t// if . matches \\n\n    }\n\n\nprivate{\n    т_мера истк;\t\t\t// current source index in ввод[]\n    т_мера старт_истк;\t\t// starting index for сверь in ввод[]\n    т_мера p;\t\t\t// позиция of parser in образец[]\n    т_регсвер гсовп;\t\t// сверь for the entire regular expression\n\t\t\t\t// (serves as storage for псовп[0])\n\n    ббайт[] программа;\t\t// образец[] compiled целo regular expression программа\n    БуферВывода буф;\n\t}\n\n// Opcodes\n\nenum : ббайт\n{\n    РВконец,\t\t// end of программа\n    РВсим,\t\t// single символ\n    РВлсим,\t\t// single символ, case insensitive\n    РВдим,\t\t// single UCS символ\n    РВлдим,\t\t// single wide символ, case insensitive\n    РВлюбсим,\t\t// any символ\n    РВлюбзвезда,\t\t// \".*\"\n    РВткст,\t\t// текст of символs\n    РВлткст,\t\t// текст of символs, case insensitive\n    РВтестбит,\t\t// any in bitmap, non-consuming\n    РВбит,\t\t// any in the bit map\n    РВнебит,\t\t// any not in the bit map\n    РВдиапазон,\t\t// any in the текст\n    РВнедиапазон,\t\t// any not in the текст\n    РВили,\t\t// a | b\n    РВплюс,\t\t// 1 or more\n    РВзвезда,\t\t// 0 or more\n    РВвопрос,\t\t// 0 or 1\n    РВнм,\t\t// n..m\n    РВнмкю,\t\t// n..m, non-greedy version\n    РВначстр,\t\t// beginning of строка\n    РВконстр,\t\t// end of строка\n    РВвскоб,\t\t// parenthesized subexpression\n    РВгоуту,\t\t// goto смещение\n\n    РВгранслова,\n    РВнегранслова,\n    РВцифра,\n    РВнецифра,\n    РВпространство,\n    РВнепространство,\n    РВслово,\n    РВнеслово,\n    РВобрссыл,\n};\n\n// BUG: should this include '$'?\nprivate цел слово_ли(дим c) { return числобукв_ли(c) || c == '_'; }\n\nprivate бцел бескн = ~0u;\n\n/* ********************************\n * Throws ИсключениеРегВыр on error\n */\n\nexport проц компилируй(рсим[] образец, рсим[] атрибуты)\n{\n   debug(РегВыр) скажи(фм(\"РегВыр.компилируй('%s', '%s')\\n\", образец, атрибуты));\n\n    this.атрибуты = 0;\n    foreach (рсим c; атрибуты)\n    {   РВА att;\n\n\tswitch (c)\n\t{\n\t    case 'g': att = РВА.глоб;\t\tbreak;\n\t    case 'i': att = РВА.любрег;\tbreak;\n\t    case 'm': att = РВА.многострок;\tbreak;\n\t    default:\n\t\terror(\"нераспознанный атрибут\");\n\t\treturn;\n\t}\n\tif (this.атрибуты & att)\n\t{   error(\"повторяющийся атрибут\");\n\t    return;\n\t}\n\tthis.атрибуты |= att;\n    }\n\n    ввод = null;\n\n    this.образец = образец;\n    this.флаги = атрибуты;\n\n    бцел oldre_nsub = члоподстр;\n    члоподстр = 0;\n    ошибки = 0;\n\n    буф = new БуферВывода();\n    буф.резервируй(образец.length * 8);\n    p = 0;\n    разборРегвыр();\n    if (p < образец.length)\n    {\terror(\"несовпадение ')'\");\n    }\n    оптимизируй();\n    программа = буф.данные;\n    буф.данные = null;\n   // delete буф;//Вызывает ошибку!)))\n\n    if (члоподстр > oldre_nsub)\n    {\n\tif (псовп.ptr is &гсовп)\n\t    псовп = null;\n\tпсовп.length = члоподстр + 1;\n    }\n    псовп[0].рснач = 0;\n    псовп[0].рскон = 0;\n}\n\n\n export рсим[][] разбей(рсим[] текст)\n{\n    debug(РегВыр) скажи(\"РегВыр.разбей()\\n\");\n\n    рсим[][] результат;\n\n    if (текст.length)\n    {\n\tцел p = 0;\n\tцел q;\n\tfor (q = p; q != текст.length;)\n\t{\n\t    if (проверь(текст, q))\n\t    {\tцел e;\n\n\t\tq = псовп[0].рснач;\n\t\te = псовп[0].рскон;\n\t\tif (e != p)\n\t\t{\n\t\t    результат ~= текст[p .. q];\n\t\t    for (цел i = 1; i < псовп.length; i++)\n\t\t    {\n\t\t\tцел so = псовп[i].рснач;\n\t\t\tцел eo = псовп[i].рскон;\n\t\t\tif (so == eo)\n\t\t\t{   so = 0;\t// -1 gives array bounds error\n\t\t\t    eo = 0;\n\t\t\t}\n\t\t\tрезультат ~= текст[so .. eo];\n\t\t    }\n\t\t    q = p = e;\n\t\t    continue;\n\t\t}\n\t    }\n\t    q++;\n\t}\n\tрезультат ~= текст[p .. текст.length];\n    }\n    else if (!проверь(текст))\n\tрезультат ~= текст;\n    return результат;\n}\n\n export цел найди(рсим[] текст)\n{\n    цел i;\n\n    i = проверь(текст);\n    if (i)\n\ti = псовп[0].рснач;\n    else\n\ti = -1;\t\t\t// no сверь\n    return i;\n}\n\n export рсим[][] сверь(рсим[] текст)\n{\n    рсим[][] результат;\n\n    if (атрибуты & РВА.глоб)\n    {\n\tцел последниндкс = 0;\n\n\twhile (проверь(текст, последниндкс))\n\t{   цел eo = псовп[0].рскон;\n\n\t    результат ~= ввод[псовп[0].рснач .. eo];\n\t    if (последниндкс == eo)\n\t\tпоследниндкс++;\t\t// always consume some source\n\t    else\n\t\tпоследниндкс = eo;\n\t}\n    }\n    else\n    {\n\tрезультат = выполни(текст);\n    }\n    return результат;\n}\n\n export рсим[] замени(рсим[] текст, рсим[] формат)\n{\n    рсим[] результат;\n    цел последниндкс;\n    цел смещение;\n\n    результат = текст;\n    последниндкс = 0;\n    смещение = 0;\n    for (;;)\n    {\n\tif (!проверь(текст, последниндкс))\n\t    break;\n\n\tцел so = псовп[0].рснач;\n\tцел eo = псовп[0].рскон;\n\n\tрсим[] замена = замени(формат);\n\n\t// Optimize by using std.текст.замени if possible - Dave Fladebo\n\tрсим[] срез = результат[смещение + so .. смещение + eo];\n\tif (атрибуты & РВА.глоб &&\t\t// глоб, so замени all\n\t   !(атрибуты & РВА.любрег) &&\t// not ignoring case\n\t   !(атрибуты & РВА.многострок) &&\t// not многострок\n\t   образец == срез &&\t\t\t// simple образец (exact сверь, no special символs) \n\t   формат == замена)\t\t// simple формат, not $ formats\n\t{\n\t    debug(РегВыр)\n\t\tскажифнс(\"образец: %s срез: %s, формат: %s, замена: %s\\n\" ,образец,результат[смещение + so .. смещение + eo],формат, замена);\n\t    результат = std.string.replace(результат,срез,замена);\n\t    break;\n\t}\n\n\tрезультат = replaceSlice(результат, результат[смещение + so .. смещение + eo], замена);\n\n\tif (атрибуты & РВА.глоб)\n\t{\n\t    смещение += замена.length - (eo - so);\n\n\t    if (последниндкс == eo)\n\t\tпоследниндкс++;\t\t// always consume some source\n\t    else\n\t\tпоследниндкс = eo;\n\t}\n\telse\n\t    break;\n    }\n\n    return результат;\n}\n\n export рсим[][] выполни(рсим[] текст)\n{\n    debug(РегВыр) win.скажи(фм(\"РегВыр.выполни(текст = '%s')\\n\", текст));\n    ввод = текст;\n    псовп[0].рснач = 0;\n    псовп[0].рскон = 0;\n    return выполни();\n}\n\n export рсим[][] выполни()\n{\n    if (!проверь())\n\treturn null;\n\n    auto результат = new рсим[][псовп.length];\n    for (цел i = 0; i < псовп.length; i++)\n    {\n\tif (псовп[i].рснач == псовп[i].рскон)\n\t    результат[i] = null;\n\telse\n\t    результат[i] = ввод[псовп[i].рснач .. псовп[i].рскон];\n    }\n\n    return результат;\n}\n\n export цел проверь(рсим[] текст)\n{\n    return проверь(текст, 0 /*псовп[0].рскон*/);\n}\n\nexport цел проверь()\n{\n    return проверь(ввод, псовп[0].рскон);\n}\n\nexport цел проверь(ткст текст, цел стартиндекс)\n{\n    сим firstc;\n    бцел ит;\n\n    ввод = текст;\n    debug (РегВыр) win.скажи(фм(\"РегВыр.проверь(ввод[] = '%s', стартиндекс = %d)\\n\", ввод, стартиндекс));\n    псовп[0].рснач = 0;\n    псовп[0].рскон = 0;\n    if (стартиндекс < 0 || стартиндекс > ввод.length)\n    {\n\treturn 0;\t\t\t// fail\n    }\n    debug(РегВыр) выведиПрограмму(программа);\n\n    // First символ optimization\n    firstc = 0;\n    if (программа[0] == РВсим)\n    {\n\tfirstc = программа[1];\n\tif (атрибуты & РВА.любрег && буква_ли(firstc))\n\t    firstc = 0;\n    }\n\n    for (ит = стартиндекс; ; ит++)\n    {\n\tif (firstc)\n\t{\n\t    if (ит == ввод.length)\n\t\tbreak;\t\t\t// no сверь\n\t    if (ввод[ит] != firstc)\n\t    {\n\t\tит++;\n\t\tif (!чр(ит, firstc))\t// if first символ not found\n\t\t    break;\t\t// no сверь\n\t    }\n\t}\n\tfor (цел i = 0; i < члоподстр + 1; i++)\n\t{\n\t    псовп[i].рснач = -1;\n\t    псовп[i].рскон = -1;\n\t}\n\tстарт_истк = истк = ит;\n\tif (пробнсвер(0, программа.length))\n\t{\n\t    псовп[0].рснач = ит;\n\t    псовп[0].рскон = истк;\n\t    //debug(РегВыр) эхо(\"старт = %d, end = %d\\n\", гсовп.рснач, гсовп.рскон);\n\t    return 1;\n\t}\n\t// If possible сверь must старт at beginning, we are done\n\tif (программа[0] == РВначстр || программа[0] == РВлюбзвезда)\n\t{\n\t    if (атрибуты & РВА.многострок)\n\t    {\n\t\t// Scan for the следщ \\n\n\t\tif (!чр(ит, '\\n'))\n\t\t    break;\t\t// no сверь if '\\n' not found\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\tif (ит == ввод.length)\n\t    break;\n\t//debug(РегВыр) эхо(\"Starting new try: '%.*т'\\n\", ввод[ит + 1 .. ввод.length]);\n    }\n    return 0;\t\t// no сверь\n}\n\nexport цел чр(inout бцел ит, рсим c)\n{\n    for (; ит < ввод.length; ит++)\n    {\n\tif (ввод[ит] == c)\n\t    return 1;\n    }\n    return 0;\n}\n\n\nexport проц выведиПрограмму(ббайт[] прог)\n{\n  \n    бцел pc;\n    бцел длин;\n    бцел n;\n    бцел m;\n    бкрат *pu;\n    бцел *pбцел;\n\n    debug(РегВыр) win.скажи(\"Вывод Программы()\\n\");\n    for (pc = 0; pc < прог.length; )\n    {\n\tdebug(РегВыр) скажифнс(\"прог[pc] = %d, РВсим = %d, РВнмкю = %d\\n\", прог[pc], РВсим, РВнмкю);\n\tswitch (прог[pc])\n\t{\n\t    case РВсим:\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВсим '%c'\\n\", прог[pc + 1]));\n\t\tpc += 1 + сим.sizeof;\n\t\tbreak;\n\n\t    case РВлсим:\n\t\tdebug(РегВыр) скажифнс(\"\\tРВлсим '%c'\\n\", прог[pc + 1]);\n\t\tpc += 1 + сим.sizeof;\n\t\tbreak;\n\n\t    case РВдим:\n\t\tdebug(РегВыр) скажифнс(\"\\tРВдим '%c'\\n\", *cast(дим *)&прог[pc + 1]);\n\t\tpc += 1 + дим.sizeof;\n\t\tbreak;\n\n\t    case РВлдим:\n\t\tdebug(РегВыр) скажифнс(\"\\tРВлдим '%c'\\n\", *cast(дим *)&прог[pc + 1]);\n\t\tpc += 1 + дим.sizeof;\n\t\tbreak;\n\n\t    case РВлюбсим:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВлюбсим\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВткст:\n\t\tдлин = *cast(бцел *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВткст x%x, '%s'\\n\", длин,\n\t\t\t(&прог[pc + 1 + бцел.sizeof])[0 .. длин]);\n\t\tpc += 1 + бцел.sizeof + длин * рсим.sizeof;\n\t\tbreak;\n\n\t    case РВлткст:\n\t\tдлин = *cast(бцел *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВлткст x%x, '%s'\\n\", длин,\n\t\t\t(&прог[pc + 1 + бцел.sizeof])[0 .. длин]);\n\t\tpc += 1 + бцел.sizeof + длин * рсим.sizeof;\n\t\tbreak;\n\n\t    case РВтестбит:\n\t\tpu = cast(бкрат *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВтестбит %d, %d\\n\", pu[0], pu[1]);\n\t\tдлин = pu[1];\n\t\tpc += 1 + 2 * бкрат.sizeof + длин;\n\t\tbreak;\n\n\t    case РВбит:\n\t\tpu = cast(бкрат *)&прог[pc + 1];\n\t\tдлин = pu[1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВбит cmax=%x, длин=%d:\", pu[0], длин);\n\t\tfor (n = 0; n < длин; n++)\n\t\t  debug(РегВыр)  скажифнс(\" %x\", прог[pc + 1 + 2 * бкрат.sizeof + n]);\n\t\tdebug(РегВыр)скажифнс(\"\\n\");\n\t\tpc += 1 + 2 * бкрат.sizeof + длин;\n\t\tbreak;\n\n\t    case РВнебит:\n\t\tpu = cast(бкрат *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВнебит %d, %d\\n\", pu[0], pu[1]);\n\t\tдлин = pu[1];\n\t\tpc += 1 + 2 * бкрат.sizeof + длин;\n\t\tbreak;\n\n\t    case РВдиапазон:\n\t\tдлин = *cast(бцел *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВдиапазон %d\\n\", длин);\n\t\t// BUG: REAignoreCase?\n\t\tpc += 1 + бцел.sizeof + длин;\n\t\tbreak;\n\n\t    case РВнедиапазон:\n\t\tдлин = *cast(бцел *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВнедиапазон %d\\n\", длин);\n\t\t// BUG: REAignoreCase?\n\t\tpc += 1 + бцел.sizeof + длин;\n\t\tbreak;\n\n\t    case РВначстр:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВначстр\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВконстр:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВконстр\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВили:\n\t\tдлин = *cast(бцел *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВили %d, pc=>%d\\n\", длин, pc + 1 + бцел.sizeof + длин);\n\t\tpc += 1 + бцел.sizeof;\n\t\tbreak;\n\n\t    case РВгоуту:\n\t\tдлин = *cast(бцел *)&прог[pc + 1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВгоуту %d, pc=>%d\\n\", длин, pc + 1 + бцел.sizeof + длин);\n\t\tpc += 1 + бцел.sizeof;\n\t\tbreak;\n\n\t    case РВлюбзвезда:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВлюбзвезда\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнм:\n\t    case РВнмкю:\n\t\t// длин, n, m, ()\n\t\tpбцел = cast(бцел *)&прог[pc + 1];\n\t\tдлин = pбцел[0];\n\t\tn = pбцел[1];\n\t\tm = pбцел[2];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВнм = %s длин=%d, n=%u, m=%u, pc=>%d\\n\", (прог[pc] == РВнмкю) ? \"q\" : \" \",   длин, n, m, pc + 1 + бцел.sizeof * 3 + длин);\n\t\tpc += 1 + бцел.sizeof * 3;\n\t\tbreak;\n\n\t    case РВвскоб:\n\t\t// длин, n, ()\n\t\tpбцел = cast(бцел *)&прог[pc + 1];\n\t\tдлин = pбцел[0];\n\t\tn = pбцел[1];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВвскоб длин=%d n=%d, pc=>%d\\n\", длин, n, pc + 1 + бцел.sizeof * 2 + длин);\n\t\tpc += 1 + бцел.sizeof * 2;\n\t\tbreak;\n\n\t    case РВконец:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВконец\\n\");\n\t\treturn;\n\n\t    case РВгранслова:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВгранслова\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнегранслова:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнегранслова\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВцифра:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВцифра\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнецифра:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнецифра\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВпространство:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВпространство\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнепространство:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнепространство\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВслово:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВслово\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнеслово:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнеслово\\n\");\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВобрссыл:\n\t\tdebug(РегВыр) скажифнс(\"\\tРВобрссыл %d\\n\", прог[1]);\n\t\tpc += 2;\n\t\tbreak;\n\n\t    default:\n\t\tassert(0);\n\t}\n  }\n  //}\n}\n\n\nexport цел пробнсвер(цел pc, цел pcend)\n{   цел srcsave;\n    бцел длин;\n    бцел n;\n    бцел m;\n    бцел count;\n    бцел pop;\n    бцел ss;\n    т_регсвер *psave;\n    бцел c1;\n    бцел c2;\n    бкрат* pu;\n    бцел* pбцел;\n\n    debug(РегВыр)\twin.скажи(фм(\"РегВыр.пробнсвер(pc = %d, истк = '%s', pcend = %d)\\n\",\n\t    pc, ввод[истк .. ввод.length], pcend));\n    srcsave = истк;\n    psave = null;\n    for (;;)\n    {\n\tif (pc == pcend)\t\t// if done matching\n\t{   debug(РегВыр) win.скажи(\"\\tконецпрог\\n\");\n\t    return 1;\n\t}\n\n\t//эхо(\"\\top = %d\\n\", программа[pc]);\n\tswitch (программа[pc])\n\t{\n\t    case РВсим:\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВсим '%i', истк = '%i'\\n\", программа[pc + 1], ввод[истк]));\n\t\tif (программа[pc + 1] != ввод[истк])\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc += 1 + сим.sizeof;\n\t\tbreak;\n\n\t    case РВлсим:\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВлсим '%i', истк = '%i'\\n\", программа[pc + 1], ввод[истк]));\n\t\tc1 = программа[pc + 1];\n\t\tc2 = ввод[истк];\n\t\tif (c1 != c2)\n\t\t{\n\t\t    if (проп_ли(cast(рсим)c2))\n\t\t\tc2 = std.ctype.toupper(cast(рсим)c2);\n\t\t    else\n\t\t\tgoto Lnomatch;\n\t\t    if (c1 != c2)\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\tистк++;\n\t\tpc += 1 + сим.sizeof;\n\t\tbreak;\n\n\t    case РВдим:\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВдим '%i', истк = '%i'\\n\", *(cast(дим *)&программа[pc + 1]), ввод[истк]));\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (*(cast(дим *)&программа[pc + 1]) != ввод[истк])\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc += 1 + дим.sizeof;\n\t\tbreak;\n\n\t    case РВлдим:\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВлдим '%i', истк = '%i'\\n\", *(cast(дим *)&программа[pc + 1]), ввод[истк]));\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tc1 = *(cast(дим *)&программа[pc + 1]);\n\t\tc2 = ввод[истк];\n\t\tif (c1 != c2)\n\t\t{\n\t\t    if (проп_ли(cast(рсим)c2))\n\t\t\tc2 = std.ctype.toupper(cast(рсим)c2);\n\t\t    else\n\t\t\tgoto Lnomatch;\n\t\t    if (c1 != c2)\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\tистк++;\n\t\tpc += 1 + дим.sizeof;\n\t\tbreak;\n\n\t    case РВлюбсим:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВлюбсим\\n\");\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (!(атрибуты & РВА.тчксовплф) && ввод[истк] == cast(рсим)'\\n')\n\t\t    goto Lnomatch;\n\t\tистк += std.utf.stride(ввод, истк);\n\t\t//истк++;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВткст:\n\t\tдлин = *cast(бцел *)&программа[pc + 1];\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВткст x%x, '%s'\\n\", длин,\n\t\t\t(&программа[pc + 1 + бцел.sizeof])[0 .. длин]));\n\t\tif (истк + длин > ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (cidrus.memcmp(&программа[pc + 1 + бцел.sizeof], &ввод[истк], длин * рсим.sizeof))\n\t\t    goto Lnomatch;\n\t\tистк += длин;\n\t\tpc += 1 + бцел.sizeof + длин * рсим.sizeof;\n\t\tbreak;\n\n\t    case РВлткст:\n\t\tдлин = *cast(бцел *)&программа[pc + 1];\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВлткст x%x, '%s'\\n\", длин,\n\t\t\t(&программа[pc + 1 + бцел.sizeof])[0 .. длин]));\n\t\tif (истк + длин > ввод.length)\n\t\t    goto Lnomatch;\n\t\tversion (Win32)\n\t\t{\n\t\t    if (memicmp(cast(сим*)&программа[pc + 1 + бцел.sizeof], &ввод[истк], длин * рсим.sizeof))\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (icmp((cast(сим*)&программа[pc + 1 + бцел.sizeof])[0..длин],\n\t\t\t     ввод[истк .. истк + длин]))\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\tистк += длин;\n\t\tpc += 1 + бцел.sizeof + длин * рсим.sizeof;\n\t\tbreak;\n\n\t    case РВтестбит:\n\t\tpu = (cast(бкрат *)&программа[pc + 1]);\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВтестбит %d, %d, '%i', x%x\\n\",\n\t\t    pu[0], pu[1], ввод[истк], ввод[истк]));\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tдлин = pu[1];\n\t\tc1 = ввод[истк];\n\t\t//эхо(\"[x%02x]=x%02x, x%02x\\n\", c1 >> 3, ((&программа[pc + 1 + 4])[c1 >> 3] ), (1 << (c1 & 7)));\n\t\tif (c1 <= pu[0] &&\n\t\t    !((&(программа[pc + 1 + 4]))[c1 >> 3] & (1 << (c1 & 7))))\n\t\t    goto Lnomatch;\n\t\tpc += 1 + 2 * бкрат.sizeof + длин;\n\t\tbreak;\n\n\t    case РВбит:\n\t\tpu = (cast(бкрат *)&программа[pc + 1]);\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВбит %d, %d, '%c'\\n\",\n\t\t    pu[0], pu[1], ввод[истк]));\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tдлин = pu[1];\n\t\tc1 = ввод[истк];\n\t\tif (c1 > pu[0])\n\t\t    goto Lnomatch;\n\t\tif (!((&программа[pc + 1 + 4])[c1 >> 3] & (1 << (c1 & 7))))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc += 1 + 2 * бкрат.sizeof + длин;\n\t\tbreak;\n\n\t    case РВнебит:\n\t\tpu = (cast(бкрат *)&программа[pc + 1]);\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВнебит %d, %d, '%c'\\n\",\n\t\t    pu[0], pu[1], ввод[истк]));\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tдлин = pu[1];\n\t\tc1 = ввод[истк];\n\t\tif (c1 <= pu[0] &&\n\t\t    ((&программа[pc + 1 + 4])[c1 >> 3] & (1 << (c1 & 7))))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc += 1 + 2 * бкрат.sizeof + длин;\n\t\tbreak;\n\n\t    case РВдиапазон:\n\t\tдлин = *cast(бцел *)&программа[pc + 1];\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВдиапазон %d\\n\", длин));\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\t// BUG: РВА.любрег?\n\t\tif (memchr(cast(сим*)&программа[pc + 1 + бцел.sizeof], ввод[истк], длин) == null)\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc += 1 + бцел.sizeof + длин;\n\t\tbreak;\n\n\t    case РВнедиапазон:\n\t\tдлин = *cast(бцел *)&программа[pc + 1];\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВнедиапазон %d\\n\", длин));\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\t// BUG: РВА.любрег?\n\t\tif (memchr(cast(сим*)&программа[pc + 1 + бцел.sizeof], ввод[истк], длин) != null)\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc += 1 + бцел.sizeof + длин;\n\t\tbreak;\n\n\t    case РВначстр:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВначстр\\n\");\n\t\tif (истк == 0)\n\t\t{\n\t\t}\n\t\telse if (атрибуты & РВА.многострок)\n\t\t{\n\t\t    if (ввод[истк - 1] != '\\n')\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\telse\n\t\t    goto Lnomatch;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВконстр:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВконстр\\n\");\n\t\tif (истк == ввод.length)\n\t\t{\n\t\t}\n\t\telse if (атрибуты & РВА.многострок && ввод[истк] == '\\n')\n\t\t    истк++;\n\t\telse\n\t\t    goto Lnomatch;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВили:\n\t\tдлин = (cast(бцел *)&программа[pc + 1])[0];\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВили %d\\n\", длин));\n\t\tpop = pc + 1 + бцел.sizeof;\n\t\tss = истк;\n\t\tif (пробнсвер(pop, pcend))\n\t\t{\n\t\t    if (pcend != программа.length)\n\t\t    {\tцел т;\n\n\t\t\tт = истк;\n\t\t\tif (пробнсвер(pcend, программа.length))\n\t\t\t{   debug(РегВыр) win.скажи(\"\\tпервый операнд соответствует\\n\");\n\t\t\t    истк = т;\n\t\t\t    return 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // If second branch doesn't сверь to end, take first anyway\n\t\t\t    истк = ss;\n\t\t\t    if (!пробнсвер(pop + длин, программа.length))\n\t\t\t    {\n\t\t\t\tdebug(РегВыр) win.скажи(\"\\tпервый операнд соответствует\\n\");\n\t\t\t\tистк = т;\n\t\t\t\treturn 1;\n\t\t\t    }\n\t\t\t}\n\t\t\tистк = ss;\n\t\t    }\n\t\t    else\n\t\t    {\tdebug(РегВыр) win.скажи(\"\\tпервый операнд соответствует\\n\");\n\t\t\treturn 1;\n\t\t    }\n\t\t}\n\t\tpc = pop + длин;\t\t// proceed with 2nd branch\n\t\tbreak;\n\n\t    case РВгоуту:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВгоуту\\n\");\n\t\tдлин = (cast(бцел *)&программа[pc + 1])[0];\n\t\tpc += 1 + бцел.sizeof + длин;\n\t\tbreak;\n\n\t    case РВлюбзвезда:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВлюбзвезда\\n\");\n\t\tpc++;\n\t\tfor (;;)\n\t\t{   цел s1;\n\t\t    цел s2;\n\n\t\t    s1 = истк;\n\t\t    if (истк == ввод.length)\n\t\t\tbreak;\n\t\t    if (!(атрибуты & РВА.тчксовплф) && ввод[истк] == '\\n')\n\t\t\tbreak;\n\t\t    истк++;\n\t\t    s2 = истк;\n\n\t\t    // If no сверь after consumption, but it\n\t\t    // did сверь before, then no сверь\n\t\t    if (!пробнсвер(pc, программа.length))\n\t\t    {\n\t\t\tистк = s1;\n\t\t\t// BUG: should we save/restore псовп[]?\n\t\t\tif (пробнсвер(pc, программа.length))\n\t\t\t{\n\t\t\t    истк = s1;\t\t// no сверь\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    истк = s2;\n\t\t}\n\t\tbreak;\n\n\t    case РВнм:\n\t    case РВнмкю:\n\t\t// длин, n, m, ()\n\t\tpбцел = cast(бцел *)&программа[pc + 1];\n\t\tдлин = pбцел[0];\n\t\tn = pбцел[1];\n\t\tm = pбцел[2];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВнм %s длин=%d, n=%u, m=%u\\n\", (программа[pc] == РВнмкю) ? cast(сим*)\"q\" : cast(сим*)\"\", длин, n, m);\n\t\tpop = pc + 1 + бцел.sizeof * 3;\n\t\tfor (count = 0; count < n; count++)\n\t\t{\n\t\t    if (!пробнсвер(pop, pop + длин))\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\tif (!psave && count < m)\n\t\t{\n\t\t    //version (Win32)\n\t\t\tpsave = cast(т_регсвер *)cidrus.alloca((члоподстр + 1) * т_регсвер.sizeof);\n\t\t    //else\n\t\t\t//psave = new т_регсвер[члоподстр + 1];\n\t\t}\n\t\tif (программа[pc] == РВнмкю)\t// if minimal munch\n\t\t{\n\t\t    for (; count < m; count++)\n\t\t    {   цел s1;\n\n\t\t\tcidrus.memcpy(psave, псовп.ptr, (члоподстр + 1) * т_регсвер.sizeof);\n\t\t\ts1 = истк;\n\n\t\t\tif (пробнсвер(pop + длин, программа.length))\n\t\t\t{\n\t\t\t    истк = s1;\n\t\t\t    cidrus.memcpy(псовп.ptr, psave, (члоподстр + 1) * т_регсвер.sizeof);\n\t\t\t    break;\n\t\t\t}\n\n\t\t\tif (!пробнсвер(pop, pop + длин))\n\t\t\t{   debug(РегВыр) win.скажи(\"\\tнесовпадение с подвыражением\\n\");\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// If source is not consumed, don't\n\t\t\t// infinite loop on the сверь\n\t\t\tif (s1 == истк)\n\t\t\t{   debug(РегВыр) win.скажи(\"\\tисточник не потреблён\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\t// maximal munch\n\t\t{\n\t\t    for (; count < m; count++)\n\t\t    {   цел s1;\n\t\t\tцел s2;\n\n\t\t\tcidrus.memcpy(psave, псовп.ptr, (члоподстр + 1) * т_регсвер.sizeof);\n\t\t\ts1 = истк;\n\t\t\tif (!пробнсвер(pop, pop + длин))\n\t\t\t{   debug(РегВыр) win.скажи(\"\\tнесовпадение с подвыражением\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t\ts2 = истк;\n\n\t\t\t// If source is not consumed, don't\n\t\t\t// infinite loop on the сверь\n\t\t\tif (s1 == s2)\n\t\t\t{   debug(РегВыр) win.скажи(\"\\tисточник не потреблён\\n\");\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// If no сверь after consumption, but it\n\t\t\t// did сверь before, then no сверь\n\t\t\tif (!пробнсвер(pop + длин, программа.length))\n\t\t\t{\n\t\t\t    истк = s1;\n\t\t\t    if (пробнсвер(pop + длин, программа.length))\n\t\t\t    {\n\t\t\t\tистк = s1;\t\t// no сверь\n\t\t\t\tcidrus.memcpy(псовп.ptr, psave, (члоподстр + 1) * т_регсвер.sizeof);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tистк = s2;\n\t\t    }\n\t\t}\n\t\tdebug(РегВыр) win.скажинс(фм(\"\\tРВнм len=%d, n=%u, m=%u, DONE count=%d\\n\", длин, n, m, count));\n\t\tpc = pop + длин;\n\t\tbreak;\n\n\t    case РВвскоб:\n\t\t// длин, ()\n\t\tdebug(РегВыр) win.скажи(\"\\tРВвскоб\\n\");\n\t\tpбцел = cast(бцел *)&программа[pc + 1];\n\t\tдлин = pбцел[0];\n\t\tn = pбцел[1];\n\t\tpop = pc + 1 + бцел.sizeof * 2;\n\t\tss = истк;\n\t\tif (!пробнсвер(pop, pop + длин))\n\t\t    goto Lnomatch;\n\t\tпсовп[n + 1].рснач = ss;\n\t\tпсовп[n + 1].рскон = истк;\n\t\tpc = pop + длин;\n\t\tbreak;\n\n\t    case РВконец:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВконец\\n\");\n\t\treturn 1;\t\t// successful сверь\n\n\t    case РВгранслова:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВгранслова\\n\");\n\t\tif (истк > 0 && истк < ввод.length)\n\t\t{\n\t\t    c1 = ввод[истк - 1];\n\t\t    c2 = ввод[истк];\n\t\t    if (!(\n\t\t\t  (слово_ли(cast(рсим)c1) && !слово_ли(cast(рсим)c2)) ||\n\t\t\t  (!слово_ли(cast(рсим)c1) && слово_ли(cast(рсим)c2))\n\t\t\t )\n\t\t       )\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнегранслова:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнегранслова\\n\");\n\t\tif (истк == 0 || истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tc1 = ввод[истк - 1];\n\t\tc2 = ввод[истк];\n\t\tif (\n\t\t    (слово_ли(cast(рсим)c1) && !слово_ли(cast(рсим)c2)) ||\n\t\t    (!слово_ли(cast(рсим)c1) && слово_ли(cast(рсим)c2))\n\t\t   )\n\t\t    goto Lnomatch;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВцифра:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВцифра\\n\");\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (!std.ctype.isdigit(ввод[истк]))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнецифра:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнецифра\\n\");\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (std.ctype.isdigit(ввод[истк]))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВпространство:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВпространство\\n\");\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (!межбукв_ли(ввод[истк]))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнепространство:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнепространство\\n\");\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (межбукв_ли(ввод[истк]))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВслово:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВслово\\n\");\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (!слово_ли(ввод[истк]))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВнеслово:\n\t\tdebug(РегВыр) win.скажи(\"\\tРВнеслово\\n\");\n\t\tif (истк == ввод.length)\n\t\t    goto Lnomatch;\n\t\tif (слово_ли(ввод[истк]))\n\t\t    goto Lnomatch;\n\t\tистк++;\n\t\tpc++;\n\t\tbreak;\n\n\t    case РВобрссыл:\n\t    {\n\t\tn = программа[pc + 1];\n\t\tdebug(РегВыр) win.скажи(фм(\"\\tРВобрссыл %d\\n\", n));\n\n\t\tцел so = псовп[n + 1].рснач;\n\t\tцел eo = псовп[n + 1].рскон;\n\t\tдлин = eo - so;\n\t\tif (истк + длин > ввод.length)\n\t\t    goto Lnomatch;\n\t\telse if (атрибуты & РВА.любрег)\n\t\t{\n\t\t    if (icmp(ввод[истк .. истк + длин], ввод[so .. eo]))\n\t\t\tgoto Lnomatch;\n\t\t}\n\t\telse if (cidrus.memcmp(&ввод[истк], &ввод[so], длин * рсим.sizeof))\n\t\t    goto Lnomatch;\n\t\tистк += длин;\n\t\tpc += 2;\n\t\tbreak;\n\t    }\n\n\t    default:\n\t\tassert(0);\n\t}\n    }\n\nLnomatch:\n    debug(РегВыр) скажифнс(\"\\tnomatch pc=%d\\n\", pc);\n    истк = srcsave;\n    return 0;\n}\n\n/* =================== Compiler ================== */\n\nexport цел разборРегвыр()\n{   бцел смещение;\n    бцел переходКсмещению;\n    бцел len1;\n    бцел len2;\n\n    debug(РегВыр) скажифнс(\"разборРегвыр() '%s'\\n\", образец[p .. образец.length]);\n    смещение = буф.смещение;\n    for (;;)\n    {\n\tassert(p <= образец.length);\n\tif (p == образец.length)\n\t{   буф.пиши(РВконец);\n\t    return 1;\n\t}\n\tswitch (образец[p])\n\t{\n\t    case ')':\n\t\treturn 1;\n\n\t    case '|':\n\t\tp++;\n\t\tпереходКсмещению = буф.смещение;\n\t\tбуф.пиши(РВгоуту);\n\t\tбуф.пиши(cast(бцел)0);\n\t\tlen1 = буф.смещение - смещение;\n\t\tбуф.простели(смещение, 1 + бцел.sizeof);\n\t\tпереходКсмещению += 1 + бцел.sizeof;\n\t\tразборРегвыр();\n\t\tlen2 = буф.смещение - (переходКсмещению + 1 + бцел.sizeof);\n\t\tбуф.данные[смещение] = РВили;\n\t\t(cast(бцел *)&буф.данные[смещение + 1])[0] = len1;\n\t\t(cast(бцел *)&буф.данные[переходКсмещению + 1])[0] = len2;\n\t\tbreak;\n\n\t    default:\n\t\tразборКуска();\n\t\tbreak;\n\t}\n    }\n}\n\nexport цел разборКуска()\n{   бцел смещение;\n    бцел длин;\n    бцел n;\n    бцел m;\n    ббайт op;\n    цел plength = образец.length;\n\n    debug(РегВыр)  скажифнс(\"разборКуска() '%s'\\n\", образец[p .. образец.length]);\n    смещение = буф.смещение;\n    разборАтома();\n    if (p == plength)\n\treturn 1;\n    switch (образец[p])\n    {\n\tcase '*':\n\t    // Special optimization: замени .* with РВлюбзвезда\n\t    if (буф.смещение - смещение == 1 &&\n\t\tбуф.данные[смещение] == РВлюбсим &&\n\t\tp + 1 < plength &&\n\t\tобразец[p + 1] != '?')\n\t    {\n\t\tбуф.данные[смещение] = РВлюбзвезда;\n\t\tp++;\n\t\tbreak;\n\t    }\n\n\t    n = 0;\n\t    m = бескн;\n\t    goto Lnm;\n\n\tcase '+':\n\t    n = 1;\n\t    m = бескн;\n\t    goto Lnm;\n\n\tcase '?':\n\t    n = 0;\n\t    m = 1;\n\t    goto Lnm;\n\n\tcase '{':\t// {n} {n,} {n,m}\n\t    p++;\n\t    if (p == plength || !std.ctype.isdigit(образец[p]))\n\t\tgoto Lerr;\n\t    n = 0;\n\t    do\n\t    {\n\t\t// BUG: хэндл overflow\n\t\tn = n * 10 + образец[p] - '0';\n\t\tp++;\n\t\tif (p == plength)\n\t\t    goto Lerr;\n\t    } while (std.ctype.isdigit(образец[p]));\n\t    if (образец[p] == '}')\t\t// {n}\n\t    {\tm = n;\n\t\tgoto Lnm;\n\t    }\n\t    if (образец[p] != ',')\n\t\tgoto Lerr;\n\t    p++;\n\t    if (p == plength)\n\t\tgoto Lerr;\n\t    if (образец[p] == /*{*/ '}')\t// {n,}\n\t    {\tm = бескн;\n\t\tgoto Lnm;\n\t    }\n\t    if (!std.ctype.isdigit(образец[p]))\n\t\tgoto Lerr;\n\t    m = 0;\t\t\t// {n,m}\n\t    do\n\t    {\n\t\t// BUG: хэндл overflow\n\t\tm = m * 10 + образец[p] - '0';\n\t\tp++;\n\t\tif (p == plength)\n\t\t    goto Lerr;\n\t    } while (std.ctype.isdigit(образец[p]));\n\t    if (образец[p] != /*{*/ '}')\n\t\tgoto Lerr;\n\t    goto Lnm;\n\n\tLnm:\n\t    p++;\n\t    op = РВнм;\n\t    if (p < plength && образец[p] == '?')\n\t    {\top = РВнмкю;\t// minimal munch version\n\t\tp++;\n\t    }\n\t    длин = буф.смещение - смещение;\n\t    буф.простели(смещение, 1 + бцел.sizeof * 3);\n\t    буф.данные[смещение] = op;\n\t    бцел* pбцел = cast(бцел *)&буф.данные[смещение + 1];\n\t    pбцел[0] = длин;\n\t    pбцел[1] = n;\n\t    pбцел[2] = m;\n\t    break;\n\n\tdefault:\n\t    break;\n    }\n    return 1;\n\nLerr:\n    error(\"неверно оформленные {n,m}\");\n    assert(0);\n}\n\nexport цел разборАтома()\n{   ббайт op;\n    бцел смещение;\n    рсим c;\n\n    debug(РегВыр) скажифнс(\"разборАтома() '%s'\\n\", образец[p .. образец.length]);\n    if (p < образец.length)\n    {\n\tc = образец[p];\n\tswitch (c)\n\t{\n\t    case '*':\n\t    case '+':\n\t    case '?':\n\t\terror(\"*+? недопустимо в атоме\");\n\t\tp++;\n\t\treturn 0;\n\n\t    case '(':\n\t\tp++;\n\t\tбуф.пиши(РВвскоб);\n\t\tсмещение = буф.смещение;\n\t\tбуф.пиши(cast(бцел)0);\t\t// резервируй space for length\n\t\tбуф.пиши(члоподстр);\n\t\tчлоподстр++;\n\t\tразборРегвыр();\n\t\t*cast(бцел *)&буф.данные[смещение] =\n\t\t    буф.смещение - (смещение + бцел.sizeof * 2);\n\t\tif (p == образец.length || образец[p] != ')')\n\t\t{\n\t\t    error(\"')' ожидалось\");\n\t\t    return 0;\n\t\t}\n\t\tp++;\n\t\tbreak;\n\n\t    case '[':\n\t\tif (!parseRange())\n\t\t    return 0;\n\t\tbreak;\n\n\t    case '.':\n\t\tp++;\n\t\tбуф.пиши(РВлюбсим);\n\t\tbreak;\n\n\t    case '^':\n\t\tp++;\n\t\tбуф.пиши(РВначстр);\n\t\tbreak;\n\n\t    case '$':\n\t\tp++;\n\t\tбуф.пиши(РВконстр);\n\t\tbreak;\n\n\t    case '\\\\':\n\t\tp++;\n\t\tif (p == образец.length)\n\t\t{ \n\t\terror(\"отсутствие символов после '\\\\'\");\n\t\t    return 0;\n\t\t}\n\t\tc = образец[p];\n\t\tswitch (c)\n\t\t{\n\t\t    case 'b':    op = РВгранслова;\t goto Lop;\n\t\t    case 'B':    op = РВнегранслова; goto Lop;\n\t\t    case 'd':    op = РВцифра;\t\t goto Lop;\n\t\t    case 'D':    op = РВнецифра;\t goto Lop;\n\t\t    case 's':    op = РВпространство;\t\t goto Lop;\n\t\t    case 'S':    op = РВнепространство;\t goto Lop;\n\t\t    case 'w':    op = РВслово;\t\t goto Lop;\n\t\t    case 'W':    op = РВнеслово;\t goto Lop;\n\n\t\t    Lop:\n\t\t\tбуф.пиши(op);\n\t\t\tp++;\n\t\t\tbreak;\n\n\t\t    case 'f':\n\t\t    case 'n':\n\t\t    case 'r':\n\t\t    case 't':\n\t\t    case 'v':\n\t\t    case 'c':\n\t\t    case 'x':\n\t\t    case 'u':\n\t\t    case '0':\n\t\t\tc = cast(сим)escape();\n\t\t\tgoto Lbyte;\n\n\t\t    case '1': case '2': case '3':\n\t\t    case '4': case '5': case '6':\n\t\t    case '7': case '8': case '9':\n\t\t\tc -= '1';\n\t\t\tif (c < члоподстр)\n\t\t\t{   буф.пиши(РВобрссыл);\n\t\t\t    буф.пиши(cast(ббайт)c);\n\t\t\t}\n\t\t\telse\n\t\t\t{   error(\"нет соответствующей обратной ссылки\");\n\t\t\t    return 0;\n\t\t\t}\n\t\t\tp++;\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tp++;\n\t\t\tgoto Lbyte;\n\t\t}\n\t\tbreak;\n\n\t    default:\n\t\tp++;\n\t    Lbyte:\n\t\top = РВсим;\n\t\tif (атрибуты & РВА.любрег)\n\t\t{\n\t\t    if (буква_ли(c))\n\t\t    {\n\t\t\top = РВлсим;\n\t\t\tc = cast(сим)std.ctype.toupper(c);\n\t\t    }\n\t\t}\n\t\tif (op == РВсим && c <= 0xFF)\n\t\t{\n\t\t    // Look ahead and see if we can make this целo\n\t\t    // an РВткст\n\t\t    цел q;\n\t\t    цел длин;\n\n\t\t    for (q = p; q < образец.length; ++q)\n\t\t    {\tрсим qc = образец[q];\n\n\t\t\tswitch (qc)\n\t\t\t{\n\t\t\t    case '{':\n\t\t\t    case '*':\n\t\t\t    case '+':\n\t\t\t    case '?':\n\t\t\t\tif (q == p)\n\t\t\t\t    goto Lсим;\n\t\t\t\tq--;\n\t\t\t\tbreak;\n\n\t\t\t    case '(':\tcase ')':\n\t\t\t    case '|':\n\t\t\t    case '[':\tcase ']':\n\t\t\t    case '.':\tcase '^':\n\t\t\t    case '$':\tcase '\\\\':\n\t\t\t    case '}':\n\t\t\t\tbreak;\n\n\t\t\t    default:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t    длин = q - p;\n\t\t    if (длин > 0)\n\t\t    {\n\t\t\tdebug(РегВыр) скажифнс(\"записывается текст длин %d, c = '%c', образец[p] = '%c'\\n\", длин+1, c, образец[p]);\n\t\t\tбуф.резервируй(5 + (1 + длин) * рсим.sizeof);\n\t\t\tбуф.пиши((атрибуты & РВА.любрег) ? РВлткст : РВткст);\n\t\t\tбуф.пиши(длин + 1);\n\t\t\tбуф.пиши(c);\n\t\t\tбуф.пиши(образец[p .. p + длин]);\n\t\t\tp = q;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (c >= 0x80)\n\t\t{\n\t\t    // Convert to дим opcode\n\t\t    op = (op == РВсим) ? РВдим : РВлдим;\n\t\t    буф.пиши(op);\n\t\t    буф.пиши(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t Lсим:\n\t\t    debug(РегВыр) скажифнс(\" РВсим '%c'\\n\", c);\n\t\t    буф.пиши(op);\n\t\t    буф.пиши(cast(сим)c);\n\t\t}\n\t\tbreak;\n\t}\n    }\n    return 1;\n}\n\n\nclass Range\n{\n    бцел maxc;\n    бцел maxb;\n    БуферВывода буф;\n    ббайт* base;\n    BitArray bits;\n\n    this(БуферВывода буф)\n    {\n\tthis.буф = буф;\n\tif (буф.данные.length)\n\t    this.base = &буф.данные[буф.смещение];\n    }\n\n    проц setbitmax(бцел u)\n    {   бцел b;\n\n\t//эхо(\"setbitmax(x%x), maxc = x%x\\n\", u, maxc);\n\tif (u > maxc)\n\t{\n\t    maxc = u;\n\t    b = u / 8;\n\t    if (b >= maxb)\n\t    {\tбцел u2;\n\n\t\tu2 = base ? base - &буф.данные[0] : 0;\n\t\tбуф.занули(b - maxb + 1);\n\t\tbase = &буф.данные[u2];\n\t\tmaxb = b + 1;\n\t\t//bits = (cast(bit*)this.base)[0 .. maxc + 1];\n\t\tbits.ptr = cast(бцел*)this.base;\n\t    }\n\t    bits.длин = maxc + 1;\n\t}\n    }\n\n    проц setbit2(бцел u)\n    {\n\tsetbitmax(u + 1);\n\t//эхо(\"setbit2 [x%02x] |= x%02x\\n\", u >> 3, 1 << (u & 7));\n\tbits[u] = 1;\n    }\n\n};\n\nцел parseRange()\n{   ббайт op;\n    цел c;\n    цел c2;\n    бцел i;\n    бцел cmax;\n    бцел смещение;\n\n    cmax = 0x7F;\n    p++;\n    op = РВбит;\n    if (p == образец.length)\n\tgoto Lerr;\n    if (образец[p] == '^')\n    {   p++;\n\top = РВнебит;\n\tif (p == образец.length)\n\t    goto Lerr;\n    }\n    буф.пиши(op);\n    смещение = буф.смещение;\n    буф.пиши(cast(бцел)0);\t\t// резервируй space for length\n    буф.резервируй(128 / 8);\n    auto r = new Range(буф);\n    if (op == РВнебит)\n\tr.setbit2(0);\n    switch (образец[p])\n    {\n\tcase ']':\n\tcase '-':\n\t    c = образец[p];\n\t    p++;\n\t    r.setbit2(c);\n\t    break;\n\n\tdefault:\n\t    break;\n    }\n\n    enum RS { старт, rliteral, dash };\n    RS rs;\n\n    rs = RS.старт;\n    for (;;)\n    {\n\tif (p == образец.length)\n\t    goto Lerr;\n\tswitch (образец[p])\n\t{\n\t    case ']':\n\t\tswitch (rs)\n\t\t{   case RS.dash:\n\t\t\tr.setbit2('-');\n\t\t    case RS.rliteral:\n\t\t\tr.setbit2(c);\n\t\t\tbreak;\n\t\t    case RS.старт:\n\t\t\tbreak;\n\t\t    default:\n\t\t\tassert(0);\n\t\t}\n\t\tp++;\n\t\tbreak;\n\n\t    case '\\\\':\n\t\tp++;\n\t\tr.setbitmax(cmax);\n\t\tif (p == образец.length)\n\t\t    goto Lerr;\n\t\tswitch (образец[p])\n\t\t{\n\t\t    case 'd':\n\t\t\tfor (i = '0'; i <= '9'; i++)\n\t\t\t    r.bits[i] = 1;\n\t\t\tgoto Lrs;\n\n\t\t    case 'D':\n\t\t\tfor (i = 1; i < '0'; i++)\n\t\t\t    r.bits[i] = 1;\n\t\t\tfor (i = '9' + 1; i <= cmax; i++)\n\t\t\t    r.bits[i] = 1;\n\t\t\tgoto Lrs;\n\n\t\t    case 's':\n\t\t\tfor (i = 0; i <= cmax; i++)\n\t\t\t    if (межбукв_ли(i))\n\t\t\t\tr.bits[i] = 1;\n\t\t\tgoto Lrs;\n\n\t\t    case 'S':\n\t\t\tfor (i = 1; i <= cmax; i++)\n\t\t\t    if (!межбукв_ли(i))\n\t\t\t\tr.bits[i] = 1;\n\t\t\tgoto Lrs;\n\n\t\t    case 'w':\n\t\t\tfor (i = 0; i <= cmax; i++)\n\t\t\t    if (слово_ли(cast(рсим)i))\n\t\t\t\tr.bits[i] = 1;\n\t\t\tgoto Lrs;\n\n\t\t    case 'W':\n\t\t\tfor (i = 1; i <= cmax; i++)\n\t\t\t    if (!слово_ли(cast(рсим)i))\n\t\t\t\tr.bits[i] = 1;\n\t\t\tgoto Lrs;\n\n\t\t    Lrs:\n\t\t\tswitch (rs)\n\t\t\t{   case RS.dash:\n\t\t\t\tr.setbit2('-');\n\t\t\t    case RS.rliteral:\n\t\t\t\tr.setbit2(c);\n\t\t\t\tbreak;\n\t\t\t    default:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs = RS.старт;\n\t\t\tcontinue;\n\n\t\t    default:\n\t\t\tbreak;\n\t\t}\n\t\tc2 = escape();\n\t\tgoto Lrange;\n\n\t    case '-':\n\t\tp++;\n\t\tif (rs == RS.старт)\n\t\t    goto Lrange;\n\t\telse if (rs == RS.rliteral)\n\t\t    rs = RS.dash;\n\t\telse if (rs == RS.dash)\n\t\t{\n\t\t    r.setbit2(c);\n\t\t    r.setbit2('-');\n\t\t    rs = RS.старт;\n\t\t}\n\t\tcontinue;\n\n\t    default:\n\t\tc2 = образец[p];\n\t\tp++;\n\t    Lrange:\n\t\tswitch (rs)\n\t\t{   case RS.rliteral:\n\t\t\tr.setbit2(c);\n\t\t    case RS.старт:\n\t\t\tc = c2;\n\t\t\trs = RS.rliteral;\n\t\t\tbreak;\n\n\t\t    case RS.dash:\n\t\t\tif (c > c2)\n\t\t\t{   error(\"инвертированный диапазон в классе символов\");\n\t\t\t    return 0;\n\t\t\t}\n\t\t\tr.setbitmax(c2);\n\t\t\t//эхо(\"c = %x, c2 = %x\\n\",c,c2);\n\t\t\tfor (; c <= c2; c++)\n\t\t\t    r.bits[c] = 1;\n\t\t\trs = RS.старт;\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tassert(0);\n\t\t}\n\t\tcontinue;\n\t}\n\tbreak;\n    }\n    if (атрибуты & РВА.любрег)\n    {\n\t// BUG: what about дим?\n\tr.setbitmax(0x7F);\n\tfor (c = 'a'; c <= 'z'; c++)\n\t{\n\t    if (r.bits[c])\n\t\tr.bits[c + 'A' - 'a'] = 1;\n\t    else if (r.bits[c + 'A' - 'a'])\n\t\tr.bits[c] = 1;\n\t}\n    }\n    //эхо(\"maxc = %d, maxb = %d\\n\",r.maxc,r.maxb);\n    (cast(бкрат *)&буф.данные[смещение])[0] = cast(бкрат)r.maxc;\n    (cast(бкрат *)&буф.данные[смещение])[1] = cast(бкрат)r.maxb;\n    return 1;\n\nLerr:\n    error(\"неверный диапазон\");\n    return 0;\n}\n\nпроц error(ткст msg)\n{\n    ошибки++;\n    debug(РегВыр) скажифнс(\"ошибка: %s\\n\", msg);\n//assert(0);\n//*(сим*)0=0;\n    throw new ИсключениеРегВыр(msg);\n}\n\n// p is following the \\ сим\nцел escape()\nin\n{\n    assert(p < образец.length);\n}\nbody\n{   цел c;\n    цел i;\n    рсим tc;\n\n    c = образец[p];\t\t// none of the cases are multibyte\n    switch (c)\n    {\n\tcase 'b':    c = '\\b';\tbreak;\n\tcase 'f':    c = '\\f';\tbreak;\n\tcase 'n':    c = '\\n';\tbreak;\n\tcase 'r':    c = '\\r';\tbreak;\n\tcase 't':    c = '\\t';\tbreak;\n\tcase 'v':    c = '\\v';\tbreak;\n\n\t// BUG: Perl does \\a and \\e too, should we?\n\n\tcase 'c':\n\t    ++p;\n\t    if (p == образец.length)\n\t\tgoto Lretc;\n\t    c = образец[p];\n\t    // Note: we are deliberately not allowing дим letters\n\t    if (!(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')))\n\t    {\n\t     Lcerr:\n\t\terror(\"ожидалась буква после \\\\c\");\n\t\treturn 0;\n\t    }\n\t    c &= 0x1F;\n\t    break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\t    c -= '0';\n\t    for (i = 0; i < 2; i++)\n\t    {\n\t\tp++;\n\t\tif (p == образец.length)\n\t\t    goto Lretc;\n\t\ttc = образец[p];\n\t\tif ('0' <= tc && tc <= '7')\n\t\t{   c = c * 8 + (tc - '0');\n\t\t    // Treat overflow as if last\n\t\t    // digit was not an octal digit\n\t\t    if (c >= 0xFF)\n\t\t    {\tc >>= 3;\n\t\t\treturn c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    return c;\n\t    }\n\t    break;\n\n\tcase 'x':\n\t    c = 0;\n\t    for (i = 0; i < 2; i++)\n\t    {\n\t\tp++;\n\t\tif (p == образец.length)\n\t\t    goto Lretc;\n\t\ttc = образец[p];\n\t\tif ('0' <= tc && tc <= '9')\n\t\t    c = c * 16 + (tc - '0');\n\t\telse if ('a' <= tc && tc <= 'f')\n\t\t    c = c * 16 + (tc - 'a' + 10);\n\t\telse if ('A' <= tc && tc <= 'F')\n\t\t    c = c * 16 + (tc - 'A' + 10);\n\t\telse if (i == 0)\t// if no hex digits after \\x\n\t\t{\n\t\t    // Not a значid \\xXX sequence\n\t\t    return 'x';\n\t\t}\n\t\telse\n\t\t    return c;\n\t    }\n\t    break;\n\n\tcase 'u':\n\t    c = 0;\n\t    for (i = 0; i < 4; i++)\n\t    {\n\t\tp++;\n\t\tif (p == образец.length)\n\t\t    goto Lretc;\n\t\ttc = образец[p];\n\t\tif ('0' <= tc && tc <= '9')\n\t\t    c = c * 16 + (tc - '0');\n\t\telse if ('a' <= tc && tc <= 'f')\n\t\t    c = c * 16 + (tc - 'a' + 10);\n\t\telse if ('A' <= tc && tc <= 'F')\n\t\t    c = c * 16 + (tc - 'A' + 10);\n\t\telse\n\t\t{\n\t\t    // Not a значid \\uXXXX sequence\n\t\t    p -= i;\n\t\t    return 'u';\n\t\t}\n\t    }\n\t    break;\n\n\tdefault:\n\t    break;\n    }\n    p++;\nLretc:\n    return c;\n}\n\n/* ==================== optimizer ======================= */\n\nexport проц оптимизируй()\n{   ббайт[] прог;\n\n    debug(РегВыр) win.скажи(\"РегВыр.оптимизируй()\\n\");\n    прог = буф.вБайты();\n    for (т_мера i = 0; 1;)\n    {\n\t//эхо(\"\\tprog[%d] = %d, %d\\n\", i, прог[i], РВткст);\n\tswitch (прог[i])\n\t{\n\t    case РВконец:\n\t    case РВлюбсим:\n\t    case РВлюбзвезда:\n\t    case РВобрссыл:\n\t    case РВконстр:\n\t    case РВсим:\n\t    case РВлсим:\n\t    case РВдим:\n\t    case РВлдим:\n\t    case РВткст:\n\t    case РВлткст:\n\t    case РВтестбит:\n\t    case РВбит:\n\t    case РВнебит:\n\t    case РВдиапазон:\n\t    case РВнедиапазон:\n\t    case РВгранслова:\n\t    case РВнегранслова:\n\t    case РВцифра:\n\t    case РВнецифра:\n\t    case РВпространство:\n\t    case РВнепространство:\n\t    case РВслово:\n\t    case РВнеслово:\n\t\treturn;\n\n\t    case РВначстр:\n\t\ti++;\n\t\tcontinue;\n\n\t    case РВили:\n\t    case РВнм:\n\t    case РВнмкю:\n\t    case РВвскоб:\n\t    case РВгоуту:\n\t    {\n\t\tauto bitbuf = new БуферВывода;\n\t\tauto r = new Range(bitbuf);\n\t\tбцел смещение;\n\n\t\tсмещение = i;\n\t\tif (starrchars(r, прог[i .. прог.length]))\n\t\t{\n\t\t    debug(РегВыр) эхо(\"\\tfilter built\\n\");\n\t\t    буф.простели(смещение, 1 + 4 + r.maxb);\n\t\t    буф.данные[смещение] = РВтестбит;\n\t\t    (cast(бкрат *)&буф.данные[смещение + 1])[0] = cast(бкрат)r.maxc;\n\t\t    (cast(бкрат *)&буф.данные[смещение + 1])[1] = cast(бкрат)r.maxb;\n\t\t    i = смещение + 1 + 4;\n\t\t    буф.данные[i .. i + r.maxb] = r.base[0 .. r.maxb];\n\t\t}\n\t\treturn;\n\t    }\n\t    default:\n\t\tassert(0);\n\t}\n    }\n}\n\n/////////////////////////////////////////\n// OR the leading символ bits целo r.\n// Limit the символ range from 0..7F,\n// пробнсвер() will allow through anything over maxc.\n// Return 1 if success, 0 if we can't build a filter or\n// if there is no poцел to one.\n\nexport цел starrchars(Range r, ббайт[] прог)\n{   рсим c;\n    бцел maxc;\n    бцел maxb;\n    бцел длин;\n    бцел b;\n    бцел n;\n    бцел m;\n    ббайт* pop;\n\n  //  debug(РегВыр) скажифнс(\"РегВыр.starrchars(прог = %p, progend = %p)\\n\", прог, progend);\n    for (т_мера i = 0; i < прог.length;)\n    {\n\tswitch (прог[i])\n\t{\n\t    case РВсим:\n\t\tc = прог[i + 1];\n\t\tif (c <= 0x7F)\n\t\t    r.setbit2(c);\n\t\treturn 1;\n\n\t    case РВлсим:\n\t\tc = прог[i + 1];\n\t\tif (c <= 0x7F)\n\t\t{   r.setbit2(c);\n\t\t    r.setbit2(std.ctype.tolower(cast(рсим)c));\n\t\t}\n\t\treturn 1;\n\n\t    case РВдим:\n\t    case РВлдим:\n\t\treturn 1;\n\n\t    case РВлюбсим:\n\t\treturn 0;\t\t// no poцел\n\n\t    case РВткст:\n\t\tдлин = *cast(бцел *)&прог[i + 1];\n\t\tassert(длин);\n\t\tc = *cast(рсим *)&прог[i + 1 + бцел.sizeof];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВткст %d, '%c'\\n\", длин, c);\n\t\tif (c <= 0x7F)\n\t\t    r.setbit2(c);\n\t\treturn 1;\n\n\t    case РВлткст:\n\t\tдлин = *cast(бцел *)&прог[i + 1];\n\t\tassert(длин);\n\t\tc = *cast(рсим *)&прог[i + 1 + бцел.sizeof];\n\t\tdebug(РегВыр) скажифнс(\"\\tРВлткст %d, '%c'\\n\", длин, c);\n\t\tif (c <= 0x7F)\n\t\t{   r.setbit2(std.ctype.toupper(cast(рсим)c));\n\t\t    r.setbit2(std.ctype.tolower(cast(рсим)c));\n\t\t}\n\t\treturn 1;\n\n\t    case РВтестбит:\n\t    case РВбит:\n\t\tmaxc = (cast(бкрат *)&прог[i + 1])[0];\n\t\tmaxb = (cast(бкрат *)&прог[i + 1])[1];\n\t\tif (maxc <= 0x7F)\n\t\t    r.setbitmax(maxc);\n\t\telse\n\t\t    maxb = r.maxb;\n\t\tfor (b = 0; b < maxb; b++)\n\t\t    r.base[b] |= прог[i + 1 + 4 + b];\n\t\treturn 1;\n\n\t    case РВнебит:\n\t\tmaxc = (cast(бкрат *)&прог[i + 1])[0];\n\t\tmaxb = (cast(бкрат *)&прог[i + 1])[1];\n\t\tif (maxc <= 0x7F)\n\t\t    r.setbitmax(maxc);\n\t\telse\n\t\t    maxb = r.maxb;\n\t\tfor (b = 0; b < maxb; b++)\n\t\t    r.base[b] |= ~прог[i + 1 + 4 + b];\n\t\treturn 1;\n\n\t    case РВначстр:\n\t    case РВконстр:\n\t\treturn 0;\n\n\t    case РВили:\n\t\tдлин = (cast(бцел *)&прог[i + 1])[0];\n\t\treturn starrchars(r, прог[i + 1 + бцел.sizeof .. прог.length]) &&\n\t\t       starrchars(r, прог[i + 1 + бцел.sizeof + длин .. прог.length]);\n\n\t    case РВгоуту:\n\t\tдлин = (cast(бцел *)&прог[i + 1])[0];\n\t\ti += 1 + бцел.sizeof + длин;\n\t\tbreak;\n\n\t    case РВлюбзвезда:\n\t\treturn 0;\n\n\t    case РВнм:\n\t    case РВнмкю:\n\t\t// длин, n, m, ()\n\t\tдлин = (cast(бцел *)&прог[i + 1])[0];\n\t\tn   = (cast(бцел *)&прог[i + 1])[1];\n\t\tm   = (cast(бцел *)&прог[i + 1])[2];\n\t\tpop = &прог[i + 1 + бцел.sizeof * 3];\n\t\tif (!starrchars(r, pop[0 .. длин]))\n\t\t    return 0;\n\t\tif (n)\n\t\t    return 1;\n\t\ti += 1 + бцел.sizeof * 3 + длин;\n\t\tbreak;\n\n\t    case РВвскоб:\n\t\t// длин, ()\n\t\tдлин = (cast(бцел *)&прог[i + 1])[0];\n\t\tn   = (cast(бцел *)&прог[i + 1])[1];\n\t\tpop = &прог[0] + i + 1 + бцел.sizeof * 2;\n\t\treturn starrchars(r, pop[0 .. длин]);\n\n\t    case РВконец:\n\t\treturn 0;\n\n\t    case РВгранслова:\n\t    case РВнегранслова:\n\t\treturn 0;\n\n\t    case РВцифра:\n\t\tr.setbitmax('9');\n\t\tfor (c = '0'; c <= '9'; c++)\n\t\t    r.bits[c] = 1;\n\t\treturn 1;\n\n\t    case РВнецифра:\n\t\tr.setbitmax(0x7F);\n\t\tfor (c = 0; c <= '0'; c++)\n\t\t    r.bits[c] = 1;\n\t\tfor (c = '9' + 1; c <= r.maxc; c++)\n\t\t    r.bits[c] = 1;\n\t\treturn 1;\n\n\t    case РВпространство:\n\t\tr.setbitmax(0x7F);\n\t\tfor (c = 0; c <= r.maxc; c++)\n\t\t    if (межбукв_ли(c))\n\t\t\tr.bits[c] = 1;\n\t\treturn 1;\n\n\t    case РВнепространство:\n\t\tr.setbitmax(0x7F);\n\t\tfor (c = 0; c <= r.maxc; c++)\n\t\t    if (!межбукв_ли(c))\n\t\t\tr.bits[c] = 1;\n\t\treturn 1;\n\n\t    case РВслово:\n\t\tr.setbitmax(0x7F);\n\t\tfor (c = 0; c <= r.maxc; c++)\n\t\t    if (слово_ли(cast(рсим)c))\n\t\t\tr.bits[c] = 1;\n\t\treturn 1;\n\n\t    case РВнеслово:\n\t\tr.setbitmax(0x7F);\n\t\tfor (c = 0; c <= r.maxc; c++)\n\t\t    if (!слово_ли(cast(рсим)c))\n\t\t\tr.bits[c] = 1;\n\t\treturn 1;\n\n\t    case РВобрссыл:\n\t\treturn 0;\n\n\t    default:\n\t\tassert(0);\n\t}\n    }\n    return 1;\n}\n\n\n export рсим[] замени(рсим[] формат)\n{\n    return замени3(формат, ввод, псовп[0 .. члоподстр + 1]);\n}\n\n// Static version that doesn't require a РегВыр объект to be created\n\n export static рсим[] замени3(рсим[] формат, рсим[] ввод, т_регсвер[] псовп)\n{\n    рсим[] результат;\n    бцел c2;\n    цел рснач;\n    цел рскон;\n    цел i;\n   debug(РегВыр) скажифнс(\"замени3(формат = '%s', ввод = '%s')\\n\", формат, ввод);\n    результат.length = формат.length;\n    результат.length = 0;\n    for (т_мера f = 0; f < формат.length; f++)\n    {\n\tauto c = формат[f];\n      L1:\n\tif (c != '$')\n\t{\n\t    результат ~= c;\n\t    continue;\n\t}\n\t++f;\n\tif (f == формат.length)\n\t{\n\t    результат ~= '$';\n\t    break;\n\t}\n\tc = формат[f];\n\tswitch (c)\n\t{\n\t    case '&':\n\t\tрснач = псовп[0].рснач;\n\t\tрскон = псовп[0].рскон;\n\t\tgoto Lstring;\n\n\t    case '`':\n\t\tрснач = 0;\n\t\tрскон = псовп[0].рснач;\n\t\tgoto Lstring;\n\n\t    case '\\'':\n\t\tрснач = псовп[0].рскон;\n\t\tрскон = ввод.length;\n\t\tgoto Lstring;\n\n\t    case '0': case '1': case '2': case '3': case '4':\n\t    case '5': case '6': case '7': case '8': case '9':\n\t\ti = c - '0';\n\t\tif (f + 1 == формат.length)\n\t\t{\n\t\t    if (i == 0)\n\t\t    {\n\t\t\tрезультат ~= '$';\n\t\t\tрезультат ~= c;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    c2 = формат[f + 1];\n\t\t    if (c2 >= '0' && c2 <= '9')\n\t\t    {   i = (c - '0') * 10 + (c2 - '0');\n\t\t\tf++;\n\t\t    }\n\t\t    if (i == 0)\n\t\t    {\n\t\t\tрезультат ~= '$';\n\t\t\tрезультат ~= c;\n\t\t\tc = cast(сим)c2;\n\t\t\tgoto L1;\n\t\t    }\n\t\t}\n\n\t\tif (i < псовп.length)\n\t\t{   рснач = псовп[i].рснач;\n\t\t    рскон = псовп[i].рскон;\n\t\t    goto Lstring;\n\t\t}\n\t\tbreak;\n\n\t    Lstring:\n\t\tif (рснач != рскон)\n\t\t    результат ~= ввод[рснач .. рскон];\n\t\tbreak;\n\n\t    default:\n\t\tрезультат ~= '$';\n\t\tрезультат ~= c;\n\t\tbreak;\n\t}\n    }\n    return результат;\n}\n\n export рсим[] замениСтарый(рсим[] формат)\n{\n    рсим[] результат;\n\n//debug(РегВыр)  скажифнс(\"замени: this = %p so = %d, eo = %d\\n\", this, псовп[0].рснач, псовп[0].рскон);\n//эхо(\"3input = '%.*т'\\n\", ввод);\n    результат.length = формат.length;\n    результат.length = 0;\n    for (т_мера i; i < формат.length; i++)\n    {\n\tauto c = формат[i];\n\tswitch (c)\n\t{\n\t    case '&':\n//эхо(\"сверь = '%.*т'\\n\", ввод[псовп[0].рснач .. псовп[0].рскон]);\n\t\tрезультат ~= ввод[псовп[0].рснач .. псовп[0].рскон];\n\t\tbreak;\n\n\t    case '\\\\':\n\t\tif (i + 1 < формат.length)\n\t\t{\n\t\t    c = формат[++i];\n\t\t    if (c >= '1' && c <= '9')\n\t\t    {   бцел j;\n\n\t\t\tj = c - '0';\n\t\t\tif (j <= члоподстр && псовп[j].рснач != псовп[j].рскон)\n\t\t\t    результат ~= ввод[псовп[j].рснач .. псовп[j].рскон];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tрезультат ~= c;\n\t\tbreak;\n\n\t    default:\n\t\tрезультат ~= c;\n\t\tbreak;\n\t}\n    }\n    return результат;\n}\n\n}\n\nexport extern(D)\n{\n\n\timport std.process;\n\n\tцел система (ткст команда)\n\t{\n\treturn cast(цел) std.process.system(cast(ткст) команда);\n\t}\n\n\tцел пауза(){система(\"pause\"); return 0;}\n\t\n\tцел пускпрог(цел режим, ткст путь, ткст[] арги)\n\t{\n\treturn cast(цел) std.process.spawnvp(cast(цел) режим, cast(ткст) путь, cast(ткст[]) арги);\n\t}\n\n\tцел выппрог(ткст путь, ткст[] арги)\n\t{\n\treturn cast(цел)  std.process.execv(cast(ткст) путь, cast(ткст[]) арги);\n\t}\n\n\tцел выппрог(ткст путь, ткст[] арги, ткст[] перемср)\n\t{\n\treturn cast(цел) std.process.execve(cast(ткст) путь, cast(ткст[]) арги, cast(ткст[]) перемср);\n\t}\n\n\tцел выппрогcp(ткст путь, ткст[] арги)\n\t{\n\treturn cast(цел) std.process.execvp(cast(ткст) путь, cast(ткст[]) арги);\n\t}\n\n\tцел выппрогср(ткст путь, ткст[] арги, ткст[] перемср)\n\t{\n\treturn cast(цел) std.process.execve(cast(ткст) путь, cast(ткст[]) арги, cast(ткст[]) перемср);\n\t}\n}\n/////////////////////////////////////\n\n/// Этот подкласс предназначен для небуферированных системных файловых потоков.\n\nexport extern (D) class Файл: Поток {\n\nук файлУк;\nexport:\n\n  this() {\n    //super();\n     // win.скажинс(\"Вход в конструктор Файла\");\n    файлУк = null;    \n    открытый(нет);\n\t // win.скажинс(\"Выход из конструктора Файла\");\n\t\n  }\n\n  // opens existing хэндл; use with care!\n  this(ук флУк, ПРежимФайла режим) {\n    //super();\n\t//win.скажинс(\"установил супер\");\n    this.файлУк = адаптВхоУкз(флУк);\n    читаемый(cast(бул)(режим & ПРежимФайла.Ввод));\t\n    записываемый(cast(бул)(режим & ПРежимФайла.Вывод));\t\n    сканируемый(ДайТипФайла(файлУк) == 1); // FILE_TYPE_DISK   \n\t\n  }\n   \n  this(ткст имяф, ПРежимФайла режим = cast(ПФРежим) 1)\n  {\n      this();\n      открой(имяф, режим);\n  }\n  \n    private проц выяснитьРежим(ПРежимФайла режим,\n\t\t\t out ППраваДоступа доступ,\n\t\t\t out ПСовмИспФайла шара,\n\t\t\t out ПРежСоздФайла режСозд) {    \n      шара |= ПСовмИспФайла.Чтение |  ПСовмИспФайла.Запись;\n      if (режим & ПРежимФайла.Ввод) {\n\tдоступ |= ППраваДоступа.ГенерноеЧтение; \n\t//win.скажинс(фм(\"ГЕНЕРНОЕ_ЧТЕНИЕ = 0x%x\",ППраваДоступа.ГенерноеЧтение));\n\tрежСозд = ПРежСоздФайла.ОткрытьСущ;\n      }\n      if (режим & ПРежимФайла.Вывод) {\n\tдоступ |= ППраваДоступа.ГенернаяЗапись ;\n\t//win.скажинс(фм(\"ППраваДоступа.ГенернаяЗапись = 0x%x\", доступ));\n\tрежСозд = ПРежСоздФайла.ОткрытьВсегда; \n      }\n      if ((режим & ПРежимФайла.ВыводНов) == ПРежимФайла.ВыводНов) {\n\tрежСозд = ПРежСоздФайла.СоздатьВсегда; \n      }\n    } \n\n  проц открой(ткст имяф, ПРежимФайла режим = cast(ПФРежим) 1) {\n \n     закрой();\n    ППраваДоступа доступ;\n\tПСовмИспФайла шара;\n\tПРежСоздФайла режСозд;\t\n    выяснитьРежим(режим, доступ, шара, режСозд);\t\n    сканируемый(да);\n    читаемый(cast(бул)(режим & ПРежимФайла.Ввод));\n\tзаписываемый(cast(бул)(режим & ПРежимФайла.Вывод));\t\n\t//читаемый(); записываемый();\t\n\t//win.скажинс(\"Процедура открытия файла...\");\n\t//win.скажинс(фм(\"доступ = 0x%x шара = 0x%x режим = 0x%x\",доступ, шара, режСозд));\n\tфайлУк = СоздайФайл(вЮ16(имяф), доступ, шара,  null, режСозд, ПФайл.Нормальный, null);\n    \n    открытый(файлУк != cast(ук) НЕВЕРНХЭНДЛ);\n\t\n    if (!открытый())\n      throw new Исключение(\"stdrus.Файл.открой:Не удалось открыть или создать файл '\" ~ имяф ~ \"'\");\n    else if ((режим & ПРежимФайла.Добавка) == ПРежимФайла.Добавка)\n      измпозКон(0);\t\n  }\n\n  \n    проц создай(ткст имяф, ПРежимФайла режим) {\t\n\tзакрой();\n\tоткрой(имяф, режим | ПРежимФайла.ВыводНов);\n\t\n\t  }\n\n  проц создай(ткст имяф) {\n      закрой();\n\t открой(имяф, ПРежимФайла.ВыводНов);\t\n  }\n  \n  override проц закрой() {\n\n    if (открытый())\n\t{ \n      super.закрой();\n      if (файлУк)\n\t  {\n\t  ЗакройДескр(файлУк);\n\t  файлУк = null;\t  \t\n      }\n    }\n  }\n  ~this() { закрой(); }\n\n     бдол размер() {\n      проверьСканируемость(this.toString(),__FILE__,__LINE__);\n      бцел sizehi;\n      бцел sizelow = ДайРазмерФайла(файлУк,&sizehi);\n      return (cast(бдол)sizehi << 32) + sizelow;\n    }\n\n  override т_мера читайБлок(ук буфер, т_мера размер) {\n\t  auto разм = размер;\n\t      проверьЧитаемость();\n          ЧитайФайл(файлУк, адаптВхоУкз(буфер), разм, &разм, cast(АСИНХРОН*) null);\n\t\t  читатьдоКФ(размер == 0);\n    return разм;\n  }\n   override т_мера пишиБлок(ук буфер, т_мера размер) {\n    проверьЗаписываемость(this.toString());   \n      ПишиФайл( файлУк, адаптВхоУкз(буфер), размер, &размер, null);   \n    return размер;\n  }\n  override бдол сместись(дол смещение, ППозКурсора rel) {\n    проверьСканируемость(this.toString(),__FILE__,__LINE__);\n      цел hi = cast(цел)(смещение>>32);\n      бцел low = УстановиУказательФайла(файлУк, cast(цел) смещение, &hi, rel);\n      if ((low == cast(бцел)-1) && (ДайПоследнююОшибку() != 0))\n\tthrow new Исключение(\"stdrus.Файл.сместись: не удаётся переместить файловый указатель\",__FILE__, __LINE__);\n      бдол результат = (cast(бдол)hi << 32) + low;\n      читатьдоКФ(нет);\n    return результат;\n  }\n  override т_мера доступно() {\n    if (сканируемый()) {\n      бдол lavail = размер - позиция;\n      if (lavail > т_мера.max) lavail = т_мера.max;\n      return cast(т_мера)lavail;\n    }\n    return 0;\n  }\n  \n  ук  хэндл() { return адаптВыхУкз(файлУк); }\n\n }\n/////////////////////////////////////////\n\nexport extern (D) class ФильтрПоток : Поток\n {\n \n \n\textern(C) extern\n\t{\n\t  Поток п;              // source stream\n\tбул закрытьГнездо;\n\t}\n\t  \n\texport:\n\n\t бул закрытьИсток(){return закрытьГнездо;}\n\t  проц закрытьИсток(бул б){закрытьГнездо = б;}\n\t  \n\t  \t  /***\n\t   * Indicates the исток stream changed состояние and that this stream should reset\n\t   * any читаем, записываем, сканируем, открыт_ли and buffering флаги.\n\t   */\n\t  проц сбросьИсток() {\n\t\tif (п !is null) {\n\t\t  читаемый(п.читаемый());\n\t\t  записываемый(п.записываемый());\n\t\t  сканируемый(п.сканируемый());\n\t\t  открытый(п.открыт_ли());\n\t\t} else {\n\t\t  читаемый(нет);записываемый(нет);сканируемый(нет);\n\t\t  открытый(нет);\n\t\t}\n\t\tчитатьдоКФ(нет); возвратКаретки(нет);\n\t  }\n\t  \n\t  /// Construct a ФильтрПоток for the given source.\n\t\tthis(Поток исток) {\n\t\tthis.п = исток;\n\t\tзакрытьИсток(да);\n\t\tif (п !is null) {\n\t\t  читаемый(п.читаемый());\n\t\t  записываемый(п.записываемый());\n\t\t  сканируемый(п.сканируемый());\n\t\t  открытый(п.открыт_ли());\n\t\t} else {\n\t\t  читаемый(нет);записываемый(нет);сканируемый(нет);\n\t\t  открытый(нет);\n\t\t}\n\t\tчитатьдоКФ(нет); возвратКаретки(нет);\n\t  }\n\t  \n\t  ~this(){}\n\n\t  // исток getter/setter\n\n\t  /***\n\t   * Get the current исток stream.\n\t   */\n\t   Поток исток(){return this.п;}\n\n\t  /***\n\t   * Уст the current исток stream.\n\t   *\n\t   * Setting the исток stream закройs this stream before attaching the new\n\t   * исток. Attaching an open stream reopens this stream and resets the stream\n\t   * состояние. \n\t   */\n\t  проц исток(Поток п) {\n\t\tзакрой();\n\t\tthis.п = п;\n\t\tсбросьИсток();\n\t  }\n\n\n\n\t  // читай from исток\n\t  т_мера читайБлок(ук буфер, т_мера размер) {\n\t\tт_мера рез = п.читайБлок(адаптВхоУкз(буфер),размер);\n\t\tчитатьдоКФ(рез == 0);\n\t\treturn рез;\n\t  }\n\n\t  // пиши to исток\n\t  override т_мера пишиБлок(ук буфер, т_мера размер) {\n\t\treturn п.пишиБлок(адаптВхоУкз(буфер),размер);\n\t  }\n\n\t  // закрой stream\n\t  override проц закрой() { \n\t\tif (открытый()) {\n\t\t  super.закрой();\n\t\t  if (закрытьГнездо)\n\t\tп.закрой();\n\t\t}\n\t  }\n\n\t  // сместись on исток\n\t  override бдол сместись(дол смещение, ППозКурсора откуда) {\n\t\tчитатьдоКФ(нет);\n\t\treturn п.сместись(смещение,откуда);\n\t  }\n\n\t  т_мера доступно () { return п.доступно(); }\n\t  override проц слей() { super.слей(); п.слей(); }\n}\n\nexport extern (D) class БуфПоток : ФильтрПоток {\n\nextern(C) extern\n{\n      ббайт[] буфер; \n\t  бцел текБуфПоз;  \n\t бцел длинаБуф; \n\t  бул черновойБуф;\n\t   бцел позИстокаБуф;  \n\t  бдол позПотока; \n }\n \nexport:\n\t\n\t  проц устБуфер(ббайт[] буф){буфер = буф;}\n\t  ббайт[] дайБуфер(){return буфер;}\n  \n\t  проц устТекБуфПоз(бцел тбп){текБуфПоз = тбп;}\n\t  бцел дайТекБуфПоз(){return текБуфПоз;}\n  \n  \n\t  проц устДлинуБуф(бцел дб){длинаБуф = дб;}\n\t  бцел дайДлинуБуф(){return длинаБуф;}\n  \n\n\t  проц устЧерновой(бул чб){черновойБуф = чб;}\n\t  бул дайЧерновойБуф(){return черновойБуф;}\n\t  \n  \n\t  проц устПозИстокаБуф(бцел пиб){позИстокаБуф = пиб;}\n\t  бцел дайПозИстокаБуф(){return позИстокаБуф;}\n\t  \n\t\n\t  проц устПозПотока(бдол пп){позПотока = пп;}\n\t  бдол дайПозПотока(){return позПотока;}\n\n  invariant() {\n    assert(длинаБуф <= буфер.length,вЮ8(cast(ткст)\"Несоблюдение первого требования инварианта класса БУфПоток\"));\n    assert(текБуфПоз <= длинаБуф, вЮ8(cast(ткст)\"Несоблюдение второго требования инварианта класса БУфПоток\"));\n     assert(позИстокаБуф <= длинаБуф, вЮ8(cast(ткст)\"Несоблюдение третьего требования инварианта класса БУфПоток\"));\n  }\n\n  const бцел дефРазмБуфера = 8192;\n\n  /***\n   * Create a buffered stream for the stream исток with the буфер размер\n   * bufferSize.\n   */\n  this(Поток исток, бцел размБуф = дефРазмБуфера) {\n  \n   super(исток);\n   assert(super.п == исток);\n\t\t  this.п = super.п;\n\t\t  читаемый(super.читаемый());\n\t\t  записываемый(super.записываемый());\n\t\t  сканируемый(super.сканируемый());\n\t\t  открытый(super.открыт_ли());\n \n   if (размБуф)\n    буфер = new ббайт[размБуф];\t \n\tчерновойБуф = нет;\t  \n  }\n  \n  ~this(){}\n\n  override проц сбросьИсток() {\n    super.сбросьИсток();\n    позПотока = 0;\n    длинаБуф = позИстокаБуф = текБуфПоз = 0;\n    черновойБуф = нет;\n  }\n\n  // reads block of данные of specified размер using any buffered данные\n  // returns actual number of bytes читай\n  override т_мера читайБлок(ук результат, т_мера длин) {\n    if (длин == 0) return 0;\n\n    проверьЧитаемость(this.toString());\n\n    ббайт* outbuf = cast(ббайт*)адаптВхоУкз(результат);\n    т_мера readsize = 0;\n\n    if (текБуфПоз + длин < длинаБуф) {\n      // буфер has all the данные so copy it\n      outbuf[0 .. длин] = буфер[текБуфПоз .. текБуфПоз+длин];\n      текБуфПоз += длин;\n      readsize = длин;\n      goto ExitRead;\n    }\n\n    readsize = длинаБуф - текБуфПоз;\n    if (readsize > 0) {\n      // буфер has some данные so copy what is left\n      outbuf[0 .. readsize] = буфер[текБуфПоз .. длинаБуф];\n      outbuf += readsize;\n      текБуфПоз += readsize;\n      длин -= readsize;\n    }\n\n    слей();\n\n    if (длин >= буфер.length) {\n      // буфер can't hold the данные so fill output буфер directly\n      т_мера siz = super.читайБлок(outbuf, длин);\n      readsize += siz;\n      позПотока += siz;\n    } else {\n      // читай a new block целo буфер\n      длинаБуф = super.читайБлок(буфер.ptr, буфер.length);\n      if (длинаБуф < длин) длин = длинаБуф;\n      outbuf[0 .. длин] = буфер[0 .. длин];\n      позИстокаБуф = длинаБуф;\n      позПотока += длинаБуф;\n      текБуфПоз = длин;\n      readsize += длин;\n    }\n\n  ExitRead:\n    return readsize;\n  }\n\n  // пиши block of данные of specified размер\n  // returns actual number of bytes written\n  override т_мера пишиБлок(ук результат, т_мера длин) {\n    проверьЗаписываемость(this.toString());\n\n    ббайт* буф = cast(ббайт*)адаптВхоУкз(результат);\n    т_мера writesize = 0;\n\n    if (длинаБуф == 0) {\n      // буфер is empty so fill it if possible\n      if ((длин < буфер.length) && (читаемый())) {\n\t// читай in данные if the буфер is currently empty\n\tдлинаБуф = п.читайБлок(буфер.ptr, буфер.length);\n\tпозИстокаБуф = длинаБуф;\n\tпозПотока += длинаБуф;\n\t  \n      } else if (длин >= буфер.length) {\n\t// буфер can't hold the данные so пиши it directly and exit\n\twritesize = п.пишиБлок(буф, длин);\n\tпозПотока += writesize;\n\tgoto ExitWrite;\n      }\n    }\n\n    if (текБуфПоз + длин <= буфер.length) {\n      // буфер has space for all the данные so copy it and exit\n      буфер[текБуфПоз .. текБуфПоз+длин] = буф[0 .. длин];\n      текБуфПоз += длин;\n      длинаБуф = текБуфПоз > длинаБуф ? текБуфПоз : длинаБуф;\n      writesize = длин;\n      черновойБуф = да;\n      goto ExitWrite;\n    }\n\n    writesize = буфер.length - текБуфПоз;\n    if (writesize > 0) { \n      // буфер can take some данные\n      буфер[текБуфПоз .. буфер.length] = буф[0 .. writesize];\n      текБуфПоз = длинаБуф = буфер.length;\n      буф += writesize;\n      длин -= writesize;\n      черновойБуф = да;\n    }\n\n    assert(текБуфПоз == буфер.length);\n    assert(длинаБуф == буфер.length);\n\n    слей();\n\n    writesize += пишиБлок(буф,длин);\n\n  ExitWrite:\n    return writesize;\n  }\n\n  override бдол сместись(дол смещение, ППозКурсора откуда) {\n    проверьСканируемость(this.toString(),__FILE__,__LINE__);\n\n    if ((откуда != ППозКурсора.Тек) ||\n\t(смещение + текБуфПоз < 0) ||\n\t(смещение + текБуфПоз >= длинаБуф)) {\n      слей();\n      позПотока = п.сместись(смещение,откуда);\n    } else {\n      текБуфПоз += смещение;\n    }\n    читатьдоКФ(нет);\n    return позПотока-позИстокаБуф+текБуфПоз;\n  }\n\n  // Buffered читайСтр - Dave Fladebo\n  // reads a строка, terminated by either CR, LF, CR/LF, or EOF\n  // reusing the memory in буфер if результат will fit, otherwise\n  // will reallocate (using concatenation)\n  template TreadLine(T) {\n    T[] читайСтр(T[] вхБуфер)\n      {\n\tт_мера    размерСтрок = 0;\n\tбул    haveCR = нет;\n\tT       c = '\\0';\n\tт_мера    инд = 0;\n\tббайт*  pc = cast(ббайт*)&c;\n\n      L0:\n\tfor(;;) {\n\t  бцел старт = текБуфПоз;\n\tL1:\n\t  foreach(ббайт b; буфер[старт .. длинаБуф]) {\n\t    текБуфПоз++;\n\t    pc[инд] = b;\n\t    if(инд < T.sizeof - 1) {\n\t      инд++;\n\t      continue L1;\n\t    } else {\n\t      инд = 0;\n\t    }\n\t    if(c == '\\n' || haveCR) {\n\t      if(haveCR && c != '\\n') текБуфПоз--;\n\t      break L0;\n\t    } else {\n\t      if(c == '\\r') {\n\t\thaveCR = да;\n\t      } else {\n\t\tif(размерСтрок < вхБуфер.length) {\n\t\t  вхБуфер[размерСтрок] = c;\n\t\t} else {\n\t\t  вхБуфер ~= c;\n\t\t}\n\t\tразмерСтрок++;\n\t      }\n\t    }\n\t  }\n\t  слей();\n\t  т_мера рез = super.читайБлок(буфер.ptr, буфер.length);\n\t  if(!рез) break L0; // EOF\n\t  позИстокаБуф = длинаБуф = рез;\n\t  позПотока += рез;\n\t}\n\n\treturn вхБуфер[0 .. размерСтрок];\n      }\n  } // template TreadLine(T)\n\n  override ткст читайСтр(ткст вхБуфер) {\n    if (верниЧтоЕсть())\n      return super.читайСтр(вхБуфер);\n    else\n      return TreadLine!(сим).читайСтр(вхБуфер);\n  }\n  \n\n  override шим[] читайСтрШ(шим[] вхБуфер) {\n    if (верниЧтоЕсть())\n      return super.читайСтрШ(вхБуфер);\n    else\n      return TreadLine!(шим).читайСтр(вхБуфер);\n  }\n \n\n  override проц слей()\n  out {\n    assert(текБуфПоз == 0);\n    assert(позИстокаБуф == 0);\n    assert(длинаБуф == 0);\n  }\n  body {\n    if (записываемый() && черновойБуф) {\n      if (позИстокаБуф != 0 && сканируемый()) {\n\t// move actual файл poцелer to front of буфер\n\tпозПотока = п.сместись(-позИстокаБуф, ППозКурсора.Тек);\n      }\n      // пиши буфер out\n      позИстокаБуф = п.пишиБлок(буфер.ptr, длинаБуф);\n      if (позИстокаБуф != длинаБуф) {\n\tthrow new Исключение(\"stdrus.БуфПоток.слей: Не удаётся запись в поток\", __FILE__, __LINE__);\n      }\n    }\n    super.слей();\n    дол diff = cast(дол)текБуфПоз-позИстокаБуф;\n    if (diff != 0 && сканируемый()) {\n      // move actual файл poцелer to current позиция\n      позПотока = п.сместись(diff, ППозКурсора.Тек);\n    }\n    // reset буфер данные to be empty\n    позИстокаБуф = текБуфПоз = длинаБуф = 0;\n    черновойБуф = нет;\n  }\n\n  // returns да if end of stream is reached, нет otherwise\n  override бул кф() {\n    if ((буфер.length == 0) || !читаемый()) {\n      return super.кф();\n    }\n    // some simple tests to avoid flushing\n    if (верниЧтоЕсть() || текБуфПоз != длинаБуф)\n      return нет;\n    if (длинаБуф == буфер.length)\n      слей();\n    т_мера рез = super.читайБлок(&буфер[длинаБуф],буфер.length-длинаБуф);\n    позИстокаБуф +=  рез;\n    длинаБуф += рез;\n    позПотока += рез;\n    return читатьдоКФ;\n  }\n\n  // returns размер of stream\n  override бдол размер() {\n    if (черновойБуф) слей();\n    return п.размер();\n  }\n\n  // returns estimated number of bytes доступно for immediate reading\n  override т_мера доступно() {\n    return длинаБуф - текБуфПоз;\n  }\n  \n  override проц закрой(){слей(); super.закрой();}\n}\n\n///////////////////// \nexport extern (D) class БуфФайл: БуфПоток {\n\nalias ФильтрПоток.п п;\nexport:\n\n  /// opens файл for reading\n  this() {\n//  win.скажинс(\"Вход в конструктор БуфФайла\");\n\t super(new Файл); \n   // win.скажинс(\"Выход из конструктора БуфФайла\");\n // this.п = super.п;\n  }\n  \n  ~this(){}\n\n  /// opens файл in requested режим and буфер размер\n  this(ткст имяф, ПРежимФайла режим = cast(ПРежимФайла) 1,\n       бцел размБуф = дефРазмБуфера) {\n    super(new Файл(имяф,режим),размБуф);\n\t//this.п = super.п;\n  }\n\n  /// opens файл for reading with requested буфер размер\n  this(Файл файл, бцел размБуф = дефРазмБуфера) {\n    super(файл,размБуф);\n\t//this.п = super.п;\n  }\n\n  /// opens existing хэндл; use with care!\n  this(ук  файлУк, ПРежимФайла режим, бцел размбуфа) {\n    super(new Файл(адаптВхоУкз(файлУк),режим),размбуфа);\n\t//this.п = super.п;\n  }\n\n  /// opens файл in requested режим\n  проц открой(ткст имяф, ПРежимФайла режим = cast(ПРежимФайла) 1) {\n    Файл sf = cast(Файл)п;\n\tthis.записываемый(п.записываемый());\n    сканируемый(да);\n    читаемый(cast(бул)(режим & ПРежимФайла.Ввод));\n\tзаписываемый(cast(бул)(режим & ПРежимФайла.Вывод));\t\n    sf.открой(имяф,режим);\n    сбросьИсток();\n  }\n\n  /// creates файл in requested режим\n  проц создай(ткст имяф, ПРежимФайла режим = cast(ПРежимФайла) 6) {\n  //скажифнс(\"Режим создания $i\", режим);\n    Файл sf = cast(Файл) п;\n\t сканируемый(да);\n    читаемый(cast(бул)(режим & ПРежимФайла.Ввод));\n\tзаписываемый(cast(бул)(режим & ПРежимФайла.Вывод));\t\n    sf.создай(имяф,режим);\n    сбросьИсток();\n  }\n  \n  проц удали(ткст фимя)\n  {\n  Поток п = п;\n  delete п;\n  super.удали(фимя);\n  }\n  \n  \n   override проц закрой() {\n\t\tsuper.закрой();\n\t\tчитатьдоКФ(нет); возвратКаретки(нет);открытый(нет);читаемый(нет);\n\t\tзаписываемый(нет);сканируемый(нет);\n\t  }\n  \n}\n\nexport extern(D) БуфФайл объБуфФайл(){return new БуфФайл;}\n\nexport extern (D) class ПотокЭндианец : ФильтрПоток {\n\nexport:\n\n  Эндиан эндиан;        /// Endianness property of the исток stream.\n\n  this(Поток исток, Эндиан end) {\n    super(исток);\n    эндиан = end;\n  }\n\n  ~this(){}\n\n  проц устЭндиан(Эндиан э){this.эндиан = э;}\n  проц выведиЭндиан()\n  { \n  ткст эн;\n  if(эндиан == 1) эн = \"ЛитлЭндиан\";\n   else if(эндиан == 2)эн = \"БигЭндиан\";  \n  win.скажинс(фм(\"Установленная эндианность потока: \"~эн));   \n  }\n   \n  цел читайМПБ(цел размВозврСим) {\n    ббайт[4] BOM_buffer;\n    цел n = 0;       // the number of читай bytes\n    цел результат = -1; // the last match or -1\n    for (цел i=0; i < 5/*ЧМПБ*/; ++i) {\n      цел j;\n      ббайт[] bom = МеткиПорядкаБайтов[i];\n      for (j=0; j < bom.length; ++j) {\n\tif (n <= j) { // have to читай more\n\t  if (кф())\n\t    break;\n\t  читайРовно(&BOM_buffer[n++],1);\n\t}\n\tif (BOM_buffer[j] != bom[j])\n\t  break;\n      }\n      if (j == bom.length) // found a match\n\tрезультат = i;\n    }\n    цел m = 0;\n    if (результат != -1) {\n      эндиан = МПБЭндиан[результат]; // установи stream endianness\n      m = МеткиПорядкаБайтов[результат].length;\n    }\n    if ((размВозврСим == 1 && результат == -1) || (результат == МПБ.Ю8)) {\n      while (n-- > m)\n\tотдайс(BOM_buffer[n]);\n    } else { // should eventually support возврат for дим as well\n      if (n & 1) // make sure we have an even number of bytes\n\tчитайРовно(&BOM_buffer[n++],1);\n      while (n > m) {\n\tn -= 2;\n\tшим cw = *(cast(шим*)&BOM_buffer[n]);\n\tфиксируйПБ(&cw,2);\n\tотдайш(cw);\n      }\n    }\n\t//win.скажи(\"читайМПБ!\");\n    return результат;\n  }\n\n  /***\n   * Correct the байт order of буфер to match native endianness.\n   * размер must be even.\n   */\n   проц фиксируйПБ(ук буфер, бцел размер) {\n    if (эндиан != _эндиан) {\n      ббайт* startb = cast(ббайт*)адаптВхоУкз(буфер);\n      бцел* старт = cast(бцел*)адаптВхоУкз(буфер);\n      switch (размер) {\n      case 0: break;\n      case 2: {\n\tббайт x = *startb;\n\t*startb = *(startb+1);\n\t*(startb+1) = x;\n\tbreak;\n      }\n      case 4: {\n\t*старт = развербит(*старт);\n\tbreak;\n      }\n      default: {\n\tбцел* end = cast(бцел*)(буфер + размер - бцел.sizeof);\n\twhile (старт < end) {\n\t  бцел x = развербит(*старт);\n\t  *старт = развербит(*end);\n\t  *end = x;\n\t  ++старт;\n\t  --end;\n\t}\n\tstartb = cast(ббайт*)старт;\n\tббайт* endb = cast(ббайт*)end;\n\tцел длин = бцел.sizeof - (startb - endb);\n\tif (длин > 0)\n\t  фиксируйПБ(startb,длин);\n      }\n      }\n    }\n  }\n\n  /***\n   * Correct the байт order of the given буфер in blocks of the given размер and\n   * repeated the given number of times.\n   * размер must be even.\n   */\n   проц фиксируйБлокПБ(ук буфер, бцел размер, т_мера повтор) {\n    while (повтор--) {\n      фиксируйПБ(адаптВхоУкз(буфер),размер);\n      буфер += размер;\n    }\n  }\n\n  override проц читай(out байт x) { читайРовно(&x, x.sizeof); }\n  override проц читай(out ббайт x) { читайРовно(&x, x.sizeof); }\n  проц читай(out крат x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out бкрат x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out цел x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out бцел x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out дол x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out бдол x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out плав x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out дво x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out реал x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out вплав x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out вдво x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out вреал x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out кплав x) { читайРовно(&x, x.sizeof); фиксируйБлокПБ(&x,плав.sizeof,2); }\n  проц читай(out кдво x) { читайРовно(&x, x.sizeof); фиксируйБлокПБ(&x,дво.sizeof,2); }\n  проц читай(out креал x) { читайРовно(&x, x.sizeof); фиксируйБлокПБ(&x,реал.sizeof,2); }\n  проц читай(out шим x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n  проц читай(out дим x) { читайРовно(&x, x.sizeof); фиксируйПБ(&x,x.sizeof); }\n\n  шим бериш() {\n    шим c;\n    if (возвратКаретки) {\n      возвратКаретки(нет);\n      c = бериш();\n      if (c != '\\n') \n\treturn c;\n    }\n\tшим[] возвр = возврат();\n    if (возвр.length > 1) {\n\t\n      c = возвр[возвр.length - 1];\n      возвр.length = возвр.length - 1;\n\t  возврат(возвр);\n    } else {\n      ук буф = &c;\n      т_мера n = читайБлок(буф,2);\n      if (n == 1 && читайБлок(буф+1,1) == 0)\n          throw new Исключение(\"stdrus.ПотокЭндианец.бериш: Недостаточно данных в потоке\",__FILE__, __LINE__);\n      фиксируйПБ(&c,c.sizeof);\n    }\n    return c;\n  }\n\n  шим[] читайТкстШ(т_мера length) {\n    шим[] результат = new шим[length];\n    читайРовно(результат.ptr, результат.length * шим.sizeof);\n    фиксируйБлокПБ(&результат,2,length);\n    return результат;\n  }\n\n  /// Write the specified МПБ b to the исток stream.\n  проц пишиМПБ(МПБ b) {\n    ббайт[] bom = МеткиПорядкаБайтов[b];\n    пишиБлок(bom.ptr, bom.length);\n  }\n\n  override проц пиши(байт x) { пишиРовно(&x, x.sizeof); }\n  override проц пиши(ббайт x) { пишиРовно(&x, x.sizeof); }\n  проц пиши(крат x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(бкрат x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(цел x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(бцел x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(дол x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(бдол x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(плав x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(дво x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(реал x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(вплав x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(вдво x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(вреал x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(кплав x) { фиксируйБлокПБ(&x,плав.sizeof,2); пишиРовно(&x, x.sizeof); }\n  проц пиши(кдво x) { фиксируйБлокПБ(&x,дво.sizeof,2); пишиРовно(&x, x.sizeof); }\n  проц пиши(креал x) { фиксируйБлокПБ(&x,реал.sizeof,2); пишиРовно(&x, x.sizeof);  }\n  проц пиши(шим x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n  проц пиши(дим x) { фиксируйПБ(&x,x.sizeof); пишиРовно(&x, x.sizeof); }\n\n  проц пишиТкстШ(шим[] str) {\n    foreach(шим cw;str) {\n      фиксируйПБ(&cw,2);\n      п.пишиРовно(&cw, 2);\n    }\n  }\n\n  override бул кф() { return п.кф() && !верниЧтоЕсть();  }\n  override бдол размер() { return п.размер();  }\n\n}\n\nexport class ПотокПамяти: ТПотокМассив!(ббайт[])\n {\nexport:\n\n\n  ~this(){}\n\n  this(ббайт[] буф = null) {super (буф);  }\n  this(байт[] буф) { this(cast(ббайт[]) буф);}\t/// ditto\n  this(ткст буф) {this(cast(ббайт[]) буф); } /// ditto\n\n  /// Ensure the stream can hold count bytes.\n  проц резервируй(т_мера count) {\n    if (тек + count > буф.length)\n      буф.length = cast(бцел)((тек + count) * 2);\n  }\n\n  override т_мера пишиБлок(ук буфер, т_мера размер) {\n    резервируй(размер);\n    return super.пишиБлок(адаптВхоУкз(буфер),размер);\n  }\n \n override т_мера читайБлок(ук буфер, т_мера размер) {  return super.читайБлок(адаптВхоУкз(буфер), размер); }\n\n override бдол сместись(дол смещение, ППозКурсора rel) {  return super.сместись(смещение, rel); }\n\n override т_мера доступно () { return super.доступно(); }\n\n override ббайт[] данные() {  return super.данные(); }\n\n override ткст вТкст() {  return super.вТкст ();  }\n\n\n}\n\nexport extern (D) class РПФайлПоток : ТПотокМассив!(РПФайл) {\nexport:\n\n  /// Create stream wrapper for файл.\n  this(РПФайл файл) {\n    super (файл);\n    РПФайл.Режим режим = файл.режим;\n    записываемый(режим > РПФайл.Режим.Чтение);\n  }\n  \n  ~this(){}\n\n  override проц слей() {\n    if (открытый()) {\n      super.слей();\n      буф.слей();\n    }\n  }\n\n  override проц закрой() {\n    if (открытый()) {\n      super.закрой();\n      delete буф;\n      буф = null;\n    }\n  }\n  \noverride  т_мера читайБлок(ук буфер, т_мера размер) {  return super.читайБлок(адаптВхоУкз(буфер), размер); }\n\n override т_мера пишиБлок(ук буфер, т_мера размер) { return super.пишиБлок(адаптВхоУкз(буфер), размер);  }\n\n override бдол сместись(дол смещение, ППозКурсора rel) {  return super.сместись(смещение, rel); }\n\n override т_мера доступно () { return super.доступно(); }\n\n override ббайт[] данные() {  return super.данные(); }\n\n override ткст вТкст() {  return super.вТкст ();  }\n \n  override проц удали(ткст фимя)\n  {\n  delete буф;\n  super.удали(фимя);\n  }\n}\n \nexport extern (D) class ПотокСрез : ФильтрПоток {\n\nexport extern (C) extern\n{\n     бдол поз;  // our позиция relative to low\n    бдол низ; // низ stream смещение.\n    бдол верх; // верх stream смещение.\n    бул ограничен; // upper-ограничен by верх.\n\tПоток п;\n}\n\n  export:\n  this (Поток п, бдол нз)\n  in {\n    assert (нз <= п.размер ());\n  }\n  body {\n\tsuper(п);\n\tthis.п =  super.исток();\n    this.низ = нз; \n    this.верх = 0;\n    this.ограничен = нет;\t \n\t }\n\n  ~this(){delete п;}\n  \n  this (Поток п, бдол нз, бдол вх)\n  in {\n    assert (нз <= вх);\n    assert (вх <= п.размер ());\n  }\n  body {  \n\tsuper(п);\n\tthis.п =  super.исток();\n\tthis.позиция(п.позиция());\n    this.низ = нз; \n    this.верх = вх; \n    this.ограничен = да; \n\t   }\n\n  invariant() {\n    if (ограничен)\n      assert (поз <= верх - низ, вЮ8(cast(ткст)\"Несоблюдение требования инварианта\\n\\tкласса ПотокСрез (ограничен)\"));\n    else\n      assert (поз <= п.размер - низ, вЮ8(cast(ткст)\"Несоблюдение требования инварианта\\n\\tкласса ПотокСрез (неограничен)\"));\n  }\n\n  override т_мера читайБлок (ук буфер, т_мера размер) {\n    проверьЧитаемость();\n    if (ограничен && размер > верх - низ - поз)\n\tразмер = cast(т_мера)(верх - низ - поз);\n    бдол bp = п.позиция;\n    if (сканируемый)\n      п.позиция = низ + поз;\n    т_мера возвр = super.читайБлок(адаптВхоУкз(буфер), размер);\n    if (сканируемый) {\n      поз = п.позиция - низ;\n      п.позиция = bp;\n    }\n    return возвр;\n  }\n\n  override т_мера пишиБлок (ук буфер, т_мера размер) {\n    проверьЗаписываемость(this.toString());\n    if (ограничен && размер > верх - низ - поз)\n\tразмер = cast(т_мера)(верх - низ - поз);\n    бдол bp = п.позиция;\n    if (сканируемый)\n      п.позиция = низ + поз;\n    т_мера возвр = п.пишиБлок(адаптВхоУкз(буфер), размер);\n    if (сканируемый) {\n      поз = п.позиция - низ;\n      п.позиция = bp;\n    }\n    return возвр;\n  }\n\n  override бдол сместись(дол смещение, ППозКурсора rel) {\n    проверьСканируемость(\"ПотокСрез\",__FILE__,__LINE__);\n    дол spos;\n\n    switch (rel) {\n      case ППозКурсора.Уст:\n\tspos = смещение;\n\tbreak;\n      case ППозКурсора.Тек:\n\tspos = cast(дол)(поз + смещение);\n\tbreak;\n      case ППозКурсора.Кон:\n\tif (ограничен)\n\t  spos = cast(дол)(верх - низ + смещение);\n\telse\n\t  spos = cast(дол)(п.размер - низ + смещение);\n\tbreak;\n      default:\n\tassert(0);\n    }\n\n    if (spos < 0)\n      поз = 0;\n    else if (ограничен && spos > верх - низ)\n      поз = верх - низ;\n    else if (!ограничен && spos > п.размер - низ)\n      поз = п.размер - низ;\n    else\n      поз = cast(бдол)spos;\n\n    читатьдоКФ(нет);\n    return поз;\n  }\n\n  override т_мера доступно () {\n    т_мера рез = п.доступно;\n    бдол bp = п.позиция;\n    if (bp <= поз+низ && поз+низ <= bp+рез) {\n      if (!ограничен || bp+рез <= верх)\n\treturn cast(т_мера)(bp + рез - поз - низ);\n      else if (верх <= bp+рез)\n\treturn cast(т_мера)(верх - поз - низ);\n    }\n    return 0;\n  }\n\n\n}\n\n/////////////////////////\n\n\nexport extern(D) class РПФайл\n{\nexport:\n\nalias длина length;\n\n    enum Режим\n    {\n\tЧтение,\t\t/// read existing file\n\tЧтенЗапНов,\t/// delete existing file, write new file\n\tЧтенЗап,\t/// read/write existing file, создай if not existing\n\tЧтенКопирПриЗап, /// read/write existing file, copy on write\n\t\n    }\n\t\n    this(ткст имяф)\n    {\n\t\tthis(имяф, Режим.Чтение, 0, null);\n    }\n    \n\t\n    this(ткст имяф, Режим режим, бдол размер, ук адрес,\n\t\t\tт_мера окно = 0)\n    {\n\t\tthis.имяф = имяф;\n\t\tthis.м_режим = режим;\n\t\tthis.окно = окно;\n\t\tthis.адрес = адаптВхоУкз(адрес);\n\t\n\t\tversion (Win32)\n\t\t{\n\t\t\tук p;\n\t\t    ППраваДоступа dwDesiredAccess2;\n\t\t\tПСовмИспФайла dwShareMode;\n\t\t\tПРежСоздФайла dwCreationDisposition;\n\t\t\tППамять flProtect;\n\t    \n\t\t\tif (винВерсия & 0x80000000 && (винВерсия & 0xFF) == 3)\n\t\t\t{\n\t\t\t    throw new ФайлИскл(имяф,\n\t\t\t\t\"Win32s не реализует рпфайлы\");\n\t\t\t}\n\t    \n\t\t\tswitch (режим)\n\t\t\t{\n\t\t\t    case Режим.Чтение:\n\t\t\t\tdwDesiredAccess2 =ППраваДоступа.ГенерноеЧтение;\n\t\t\t\tdwShareMode = ПСовмИспФайла.Чтение;\n\t\t\t\tdwCreationDisposition = ПРежСоздФайла.ОткрытьСущ;\n\t\t\t\tflProtect = ППамять.СтрТолькоЧтен ;\n\t\t\t\tdwDesiredAccess = ППамять.Чтение ;\n\t\t\t\tbreak;\n\n\t\t\t    case Режим.ЧтенЗапНов:\n\t\t\t\tassert(размер != 0);\n\t\t\t\tdwDesiredAccess2 =ППраваДоступа.ГенерноеЧтение | ППраваДоступа.ГенернаяЗапись;\n\t\t\t\tdwShareMode = ПСовмИспФайла.Чтение |  ПСовмИспФайла.Запись;\n\t\t\t\tdwCreationDisposition = ПРежСоздФайла.СоздатьВсегда;\n\t\t\t\tflProtect = ППамять.СтрЗапЧтен;\n\t\t\t\tdwDesiredAccess = ППамять.Запись;\n\t\t\t\tbreak;\n\n\t\t\t    case Режим.ЧтенЗап:\n\t\t\t\tdwDesiredAccess2 =ППраваДоступа.ГенерноеЧтение | ППраваДоступа.ГенернаяЗапись;\n\t\t\t\tdwShareMode = ПСовмИспФайла.Чтение |  ПСовмИспФайла.Запись;\n\t\t\t\tdwCreationDisposition = ПРежСоздФайла.ОткрытьВсегда;\n\t\t\t\tflProtect = ППамять.СтрЗапЧтен;\n\t\t\t\tdwDesiredAccess = ППамять.Запись;\n\t\t\t\tbreak;\n\n\t\t\t    case Режим.ЧтенКопирПриЗап:\n\t\t\t\tif (винВерсия & 0x80000000)\n\t\t\t\t{\n\t\t\t\t    throw new ФайлИскл(имяф,\n\t\t\t\t\t\"Win9x не реализует копирование при записи\");\n\t\t\t\t}\n\t\t\t\tdwDesiredAccess2 =ППраваДоступа.ГенерноеЧтение | ППраваДоступа.ГенернаяЗапись;\n\t\t\t\tdwShareMode = ПСовмИспФайла.Чтение |  ПСовмИспФайла.Запись;\n\t\t\t\tdwCreationDisposition = ПРежСоздФайла.ОткрытьСущ;\n\t\t\t\tflProtect = ППамять.СтрЗапКоп;\n\t\t\t\tdwDesiredAccess = ППамять.Копия;\n\t\t\t\tbreak;\n\n\t\t\t    default:\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t\n\t\t\tif (имяф)\n\t\t\t{\n\t\t\t\tif (useWfuncs)\n\t\t\t\t{\n\t\t\t\t\tauto namez = std.utf.toUTF16(имяф);\n\t\t\t\t\thFile = СоздайФайл(namez,\n\t\t\t\t\t\t\tdwDesiredAccess2,\n\t\t\t\t\t\t\tdwShareMode,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tdwCreationDisposition,\n\t\t\t\t\t\t\tПФайл.Нормальный,\n\t\t\t\t\t\t\tcast(ук) null);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tauto namez = имяф;\n\t\t\t\t\thFile =cast(ук) СоздайФайлА(namez,\n\t\t\t\t\t\t\tdwDesiredAccess2,\n\t\t\t\t\t\t\tdwShareMode,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tdwCreationDisposition,\n\t\t\t\t\t\t\tПФайл.Нормальный,\n\t\t\t\t\t\t\tcast(ук)null);\n\t\t\t\t}\n\t\t\t\tif (hFile == cast(ук) НЕВЕРНХЭНДЛ)\n\t\t\t\t\tgoto err1;\n\t\t\t}\n\t\t\telse\n\t\t\t\thFile = null;\n\t\t\n\t\t\tцел hi = cast(цел)(размер>>32);\n\t\t\thFileMap = СоздайМаппингФайлаА(hFile, null, flProtect, hi, cast(бцел)размер, null);\n\t\t\tif (hFileMap == null)               // mapping failed\n\t\t\t\tgoto err1;\n\t\t\n\t\t\tif (размер == 0)\n\t\t\t{\n\t\t\t\tбцел sizehi;\n\t\t\t\tбцел sizelow = ДайРазмерФайла(hFile,&sizehi);\n\t\t\t\tразмер = (cast(бдол)sizehi << 32) + sizelow;\n\t\t\t}\n\t\t\tthis.размер = размер;\n\t\t\n\t\t\tт_мера initial_map = (окно && 2*окно<размер)? 2*окно : cast(т_мера)размер;\n\t\t\tp = ВидФайлаВКартуДоп(hFileMap, dwDesiredAccess, 0, 0, initial_map, адрес);\n\t\t\tif (!p) goto err1;\n\t\t\tdata = p[0 .. initial_map];\n\t\t\n\t\t\tdebug (РПФайл) скажифнс(\"РПФайл.this(): p = %p, размер = %d\\n\", p, размер);\n\t\t\treturn;\n\t\t\n\t\t\terr1:\n\t\t\tif (hFileMap != null)\n\t\t\t\tЗакройДескр(hFileMap);\n\t\t\thFileMap = null;\n\t\t\n\t\t\tif (hFile !=cast(ук) НЕВЕРНХЭНДЛ)\n\t\t\t\tЗакройДескр(hFile);\n\t\t\thFile = cast(ук) НЕВЕРНХЭНДЛ;\n\t\t\n\t\t\terrNo();\n\t\t}\n\t\telse version (Posix)\n\t\t{\n\t\t\tauto namez = вТкст0(имяф);\n\t\t\tук p;\n\t\t\tцел oflag;\n\t\t\tцел fрежим;\n\t\n\t\t\tswitch (режим)\n\t\t\t{\n\t\t\t\tcase Режим.Чтение:\n\t\t\t\t\tфлаги = MAP_SHARED;\n\t\t\t\t\tprot = PROT_READ;\n\t\t\t\t\toflag = O_RDONLY;\n\t\t\t\t\tfрежим = 0;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase Режим.ЧтенЗапНов:\n\t\t\t\t\tassert(размер != 0);\n\t\t\t\t\tфлаги = MAP_SHARED;\n\t\t\t\t\tprot = PROT_READ | PROT_WRITE;\n\t\t\t\t\toflag = O_CREAT | O_RDWR | O_TRUNC;\n\t\t\t\t\tfрежим = 0660;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase Режим.ЧтенЗап:\n\t\t\t\t\tфлаги = MAP_SHARED;\n\t\t\t\t\tprot = PROT_READ | PROT_WRITE;\n\t\t\t\t\toflag = O_CREAT | O_RDWR;\n\t\t\t\t\tfрежим = 0660;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase Режим.ЧтенКопирПриЗап:\n\t\t\t\t\tфлаги = MAP_PRIVATE;\n\t\t\t\t\tprot = PROT_READ | PROT_WRITE;\n\t\t\t\t\toflag = O_RDWR;\n\t\t\t\t\tfрежим = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);\n\t\t\t}\n\t\n\t\t\tif (имяф.length)\n\t\t\t{\t\n\t\t\t\tstruct_stat statbuf;\n\t\n\t\t\t\tfd = os.posix.open(namez, oflag, fрежим);\n\t\t\t\tif (fd == -1)\n\t\t\t\t{\n\t\t\t\t\t// эхо(\"\\topen error, errno = %d\\n\",getErrno());\n\t\t\t\t\terrNo();\n\t\t\t\t}\n\t\n\t\t\t\tif (os.posix.fstat(fd, &statbuf))\n\t\t\t\t{\n\t\t\t\t\t//эхо(\"\\tfstat error, errno = %d\\n\",getErrno());\n\t\t\t\t\tos.posix.close(fd);\n\t\t\t\t\terrNo();\n\t\t\t\t}\n\t\n\t\t\t\tif (prot & PROT_WRITE && размер > statbuf.st_size)\n\t\t\t\t{\n\t\t\t\t\t// Need to make the file размер bytes big\n\t\t\t\t\tos.posix.lseek(fd, cast(цел)(размер - 1), SEEK_SET);\n\t\t\t\t\tсим c = 0;\n\t\t\t\t\tos.posix.write(fd, &c, 1);\n\t\t\t\t}\n\t\t\t\telse if (prot & PROT_READ && размер == 0)\n\t\t\t\t\tразмер = cast(бдол)statbuf.st_size;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfd = -1;\nversion (linux)\t\t\tфлаги |= MAP_ANONYMOUS;\nelse version (OSX)\t\tфлаги |= MAP_ANON;\nelse version (FreeBSD)\t\tфлаги |= MAP_ANON;\nelse version (Solaris)\t\tфлаги |= MAP_ANON;\nelse\t\t\t\tstatic assert(0);\n\t\t\t}\n\t\t\tthis.размер = размер;\n\t\t\tт_мера initial_map = (окно && 2*окно<размер)? 2*окно : cast(т_мера)размер;\n\t\t\tp = mmap(адрес, initial_map, prot, флаги, fd, 0);\n\t\t\tif (p == MAP_FAILED) {\n\t\t\t  if (fd != -1)\n\t\t\t    os.posix.close(fd);\n\t\t\t  errNo();\n\t\t\t}\n\n\t\t\tdata = p[0 .. initial_map];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic assert(0);\n\t\t}\n\t}\n\n\t/**\n\t * Flushes pending output and closes the memory mapped file.\n\t */\n\t~this()\n\t{\n\t\tdebug (РПФайл) win.скажи(\"РПФайл.~this()\\n\");\n\t\tunmap();\n\t\tversion (Win32)\n\t\t{\n\t\t\tif (hFileMap != null && ЗакройДескр(hFileMap) != да)\n\t\t\t\terrNo();\n\t\t\thFileMap = null;\n\n\t\t\tif (hFile && hFile != cast(ук) НЕВЕРНХЭНДЛ&& ЗакройДескр(hFile) != да)\n\t\t\t\terrNo();\n\t\t\thFile = cast(ук) НЕВЕРНХЭНДЛ;\n\t\t}\n\t\telse version (Posix)\n\t\t{\n\t\t\tif (fd != НЕВЕРНХЭНДЛ&& os.posix.close(fd) == cast(ук) НЕВЕРНХЭНДЛ)\n\t\t\t\terrNo();\n\t\t\tfd = cast(ук) НЕВЕРНХЭНДЛ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic assert(0);\n\t\t}\n\t\tdata = null;\n\t}\n\n\t/* Flush any pending output.\n\t*/\n\tпроц слей()\n\t{\n\t\tdebug (РПФайл) win.скажи(\"РПФайл.слей()\\n\");\n\t\tversion (Win32)\n\t\t{\n\t\t\tСлейВидФайла(data.ptr, data.length);\n\t\t}\n\t\telse version (Posix)\n\t\t{\n\t\t\tцел i;\n\n\t\t\ti = msync(cast(проц*)data, data.length, MS_SYNC);\t// sys/mman.h\n\t\t\tif (i != 0)\n\t\t\t\terrNo();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic assert(0);\n\t\t}\n\t}\n\n\t/**\n\t * Gives размер in bytes of the memory mapped file.\n\t */\n\tбдол длина()\n\t{\n\t\tdebug (РПФайл) win.скажи(\"РПФайл.длина()\\n\");\n\t\treturn размер;\n\t}\n\n\t/**\n\t * Чтение-only property returning the file режим.\n\t */\n\tРежим режим()\n\t{\n\t\tdebug (РПФайл) win.скажи(\"РПФайл.режим()\\n\");\n\t\treturn м_режим;\n\t}\n\n\t/**\n\t * Returns entire file contents as an array.\n\t */\n\tпроц[] opSlice()\n\t{\n\t\tdebug (РПФайл) win.скажи(\"РПФайл.opSlice()\\n\");\n\t\treturn opSlice(0,размер);\n\t}\n\n\t/**\n\t * Returns срез of file contents as an array.\n\t */\n\tпроц[] opSlice(бдол i1, бдол i2)\n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.opSlice(%lld, %lld)\\n\", i1, i2);\n\t\tensureMapped(i1,i2);\n\t\tт_мера off1 = cast(т_мера)(i1-старт);\n\t\tт_мера off2 = cast(т_мера)(i2-старт);\n\t\treturn data[off1 .. off2];\n\t}\n\n\t/**\n\t * Returns byte at index i in file.\n\t */\n\tббайт opIndex(бдол i)\n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.opIndex(%lld)\\n\", i);\n\t\tensureMapped(i);\n\t\tт_мера off = cast(т_мера)(i-старт);\n\t\treturn (cast(ббайт[])data)[off];\n\t}\n\n\t/**\n\t * Sets and returns byte at index i in file to значение.\n\t */\n\tббайт opIndexAssign(ббайт значение, бдол i)\n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.opIndex(%lld, %d)\\n\", i, значение);\n\t\tensureMapped(i);\n\t\tт_мера off = cast(т_мера)(i-старт);\n\t\treturn (cast(ббайт[])data)[off] = значение;\n\t}\n\n\n\t// return да if the given position is currently mapped\n\tprivate цел mapped(бдол i) \n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.mapped(%lld, %lld, %d)\\n\", i,старт, \n\t\t\t\tdata.length);\n\t\treturn i >= старт && i < старт+data.length;\n\t}\n\n\t// unmap the current range\n\tprivate проц unmap() \n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.unmap()\\n\");\n\t\tversion(Windows) {\n\t\t\t/* Note that under Windows 95, UnmapViewOfFile() seems to return\n\t\t\t* random значues, not да or нет.\n\t\t\t*/\n\t\t\tif (data && ВидФайлаИзКарты(data.ptr) == нет &&\n\t\t\t\t(винВерсия & 0x80000000) == 0)\n\t\t\t\terrNo();\n\t\t} else {\n\t\t\tif (data && munmap(cast(проц*)data, data.length) != 0)\n\t\t\t\terrNo();\n\t\t}\n\t\tdata = null;\n\t}\n\n\t// map range\n\tprivate проц map(бдол старт, т_мера len) \n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.map(%lld, %d)\\n\", старт, len);\n\t\tук p;\n\t\tif (старт+len > размер)\n\t\t\tlen = cast(т_мера)(размер-старт);\n\t\tversion(Windows) {\n\t\t\tбцел hi = cast(бцел)(старт>>32);\n\t\t\tp = ВидФайлаВКартуДоп(hFileMap, dwDesiredAccess, hi, cast(бцел)старт, len, адрес);\n\t\t\tif (!p) errNo();\n\t\t} else {\n\t\t\tp = mmap(адрес, len, prot, флаги, fd, cast(цел)старт);\n\t\t\tif (p == MAP_FAILED) errNo();\n\t\t}\n\t\tdata = p[0 .. len];\n\t\tthis.старт = старт;\n\t}\n\n\t// ensure a given position is mapped\n\tprivate проц ensureMapped(бдол i) \n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.ensureMapped(%lld)\\n\", i);\n\t\tif (!mapped(i)) {\n\t\t\tunmap();\n\t\t\tif (окно == 0) {\n\t\t\t\tmap(0,cast(т_мера)размер);\n\t\t\t} else {\n\t\t\t\tбдол block = i/окно;\n\t\t\t\tif (block == 0)\n\t\t\t\t\tmap(0,2*окно);\n\t\t\t\telse \n\t\t\t\t\tmap(окно*(block-1),3*окно);\n\t\t\t}\n\t\t}\n\t}\n\n\t// ensure a given range is mapped\n\tprivate проц ensureMapped(бдол i, бдол j) \n\t{\n\t\tdebug (РПФайл) скажифнс(\"РПФайл.ensureMapped(%lld, %lld)\\n\", i, j);\n\t\tif (!mapped(i) || !mapped(j-1)) {\n\t\t\tunmap();\n\t\t\tif (окно == 0) {\n\t\t\t\tmap(0,cast(т_мера)размер);\n\t\t\t} else {\n\t\t\t\tбдол iblock = i/окно;\n\t\t\t\tбдол jblock = (j-1)/окно;\n\t\t\t\tif (iblock == 0) {\n\t\t\t\t\tmap(0,cast(т_мера)(окно*(jblock+2)));\n\t\t\t\t} else {\n\t\t\t\t\tmap(окно*(iblock-1),cast(т_мера)(окно*(jblock-iblock+3)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate:\n\tткст имяф;\n\tпроц[] data;\n\tбдол  старт;\n\tт_мера окно;\n\tбдол  размер;\n\tРежим   м_режим;\n\tук  адрес;\n\n\tversion (Win32)\n\t{\n\t\tук hFile = cast(ук)НЕВЕРНХЭНДЛ;\n\t\tук hFileMap = null;\n\t\tППамять dwDesiredAccess;\n\t}\n\telse version (Posix)\n\t{\n\t\tцел fd;\n\t\tцел prot;\n\t\tцел флаги;\n\t\tцел fрежим;\n\t}\n\telse\n\t{\n\t\tstatic assert(0);\n\t}\n\n\t// Report error, where errno gives the error number\n\tпроц errNo()\n\t{\n\t\tversion (Win32)\n\t\t{\n\t\t\tthrow new ФайлИскл(имяф, ДайПоследнююОшибку());\n\t\t}\n\t\telse version (Posix)\n\t\t{\n\t\t\tthrow new ФайлИскл(имяф, getErrno());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic assert(0);\n\t\t}\n\t}\n}\n////////////////////////////\n\nexport class СФайл : Поток {\nexport:\n\n extern  (C) extern фук файлси;\n\n  this(фук файлси, ПРежимФайла режим, бул сканируем = false) {\n\t//win.скажинс(\"акт супер\");\n     // super();\n    this.файлси = файлси;\n    читаемый(cast(бул)(режим & ПРежимФайла.Ввод));\n    записываемый(cast(бул)(режим & ПРежимФайла.Вывод));\n    сканируемый(сканируем);\n\t//win.скажинс(\"выход из констр\");\n  }\n\n  ~this() { закрой(); }\n\n  фук файл() { return файлси; }\n\n  проц файл(фук файлси) {\n    this.файлси = файлси; \n    открытый(да);\n  }\n\n  override проц слей() { слейфл(файлси); }\n\n  override проц закрой() { \n    if (открыт_ли)\n      закройфл(файлси); \n    открытый(нет); читаемый(нет); записываемый(нет); сканируемый(нет); \n  }\n\n \n  override бул кф() { \n    return cast(бул)(читатьдоКФ() || конфл(файлси)); \n  }\n\n  override сим берис() { \n    return cast(сим) берисфл(файлси); \n  }\n\n \n  override сим отдайс(сим c) { \n    return cast(сим) cidrus.отдайс(c,файлси); \n  }\n\n \n  override т_мера читайБлок(ук буфер, т_мера размер) {\n    т_мера n = читайфл(адаптВхоУкз(буфер),1,размер,файлси);\n    читатьдоКФ(cast(бул)(n == 0));\n    return n;\n  }\n\n  override т_мера пишиБлок(ук буфер, т_мера размер) {\n    return пишифл(адаптВхоУкз(буфер),1,размер,файлси);\n  }\n\n \n  override бдол сместись(дол смещение, ППозКурсора rel) {\n    читатьдоКФ(нет);\n    if (сместисьфл(файлси,cast(цел)смещение,rel) != 0)\n      throw new Исключение(\"Не удаётся переместить файловый указатель\",__FILE__, __LINE__);\n    return скажифл(файлси);\n  }\n\n\n  override проц пишиСтр(сим[] т) {\n    пишиТкст(т);\n    пишиТкст(\"\\n\");\n  }\n\n  override проц пишиСтрШ(шим[] т) {\n    пишиТкстШ(т);\n    пишиТкстШ(\"\\n\");\n  }\n}\n\nimport std.zip;\n\nexport extern (D) struct ЧленАрхиваЗИП //ArchiveMember\n{\nexport:\n    бкрат версияСборки = 20;\t\n    бкрат версияИзвлечения = 20;\t\n    бкрат флаги;\t\t\n    бкрат методСжатия;\t\n    ФВремяДос время;\t\n    бцел цпи32;\t\t\t\n    бцел сжатыйРазмер;\t\n    бцел расжатыйРазмер;\t\t\n    бкрат номерДиска;\t\t\n    бкрат внутренниеАтрибуты;\t\n    бцел внешниеАтрибуты;\t\n    private бцел смещение;\n    ткст имя;\n    ббайт[] экстра;\t\t\n    ткст комментарий;\t\t\n    ббайт[] сжатыеДанные;\t\n    ббайт[] расжатыеДанные;\t\n\n    проц выведи()\n    {\n\twin.скажи(фм(\"имя = '%s'\\n\", имя));\n\twin.скажи(фм(\"\\tкомментарий = '%s'\\n\", комментарий));\n\twin.скажи(фм(\"\\tверсияСборки = %d\\n\", версияСборки));\n\twin.скажи(фм(\"\\tверсияИзвлечения = %d\\n\", версияИзвлечения));\n\twin.скажи(фм(\"\\tфлаги = %d\\n\", флаги));\n\twin.скажи(фм(\"\\tметодСжатия = %d\\n\", методСжатия));\n\twin.скажи(фм(\"\\tвремя = %d\\n\", время));\n\twin.скажи(фм(\"\\tцпи32 = %d\\n\", цпи32));\n\twin.скажи(фм(\"\\tрасжатыйРазмер = %d\\n\", расжатыйРазмер));\n\twin.скажи(фм(\"\\tсжатыйРазмер = %d\\n\", сжатыйРазмер));\n\twin.скажи(фм(\"\\tвнутренниеАрибуты = %d\\n\", внутренниеАтрибуты));\n\twin.скажи(фм(\"\\tвнешниеАтрибуты = %d\\n\", внешниеАтрибуты));\n    }\n    \n}\n\nexport extern (D) class АрхивЗИП\n{\nexport:\n\n extern  (C) extern\n {\n    ббайт[] данные;\t\n    бцел смещКПоследнЗаписи;\n\n    бцел номерДиска;\t\n    бцел стартПапкаДиска;\t\n    бцел члоЗаписей;\t\n    бцел всегоЗаписей;\t\n    ткст комментарий; \n   ЧленАрхиваЗИП[ткст] папка; \n}\n   \n    проц выведи()\n    {\n\twin.скажи(фм(\"\\tномерДиска = %u\\n\", номерДиска));\n\twin.скажи(фм(\"\\tстартПапкаДиска = %u\\n\", стартПапкаДиска));\n\twin.скажи(фм(\"\\tчлоЗаписей = %u\\n\", члоЗаписей));\n\twin.скажи(фм(\"\\tвсегоЗаписей = %u\\n\", всегоЗаписей));\n\twin.скажи(фм(\"\\tкомментарий = '%.*т'\\n\", комментарий));    \n    }\n\n     this()\n    {\n    }\n\n   \n    проц добавьЧлен(ЧленАрхиваЗИП de)\n    {\n\tпапка[de.имя] = de;\n    }\n   \n    проц удалиЧлен(ЧленАрхиваЗИП de)\n    {\n\tпапка.remove(de.имя);\n    }\n\n     проц[] строй()\n    {\tбцел i;\n\tбцел папкаOffset;\n\n\tif (комментарий.length > 0xFFFF)\n\t    throw new ZipException(\"комментарий архива длиннее 65535\");\n\n\t\n\tбцел размАрхива = 0;\n\tбцел размПапки = 0;\n\tforeach (ЧленАрхиваЗИП de; папка)\n\t{\n\t    de.расжатыйРазмер = de.расжатыеДанные.length;\n\t    switch (de.методСжатия)\n\t    {\n\t\tcase 0:\n\t\t    de.сжатыеДанные = de.расжатыеДанные;\n\t\t    break;\n\n\t\tcase 8:\n\t\t    de.сжатыеДанные = cast(ббайт[])std.zlib.compress(cast(проц[])de.расжатыеДанные);\n\t\t    de.сжатыеДанные = de.сжатыеДанные[2 .. de.сжатыеДанные.length - 4];\n\t\t    break;\n\n\t\tdefault:\n\t\t    throw new ZipException(\"неподдерживаемый метод сжатия\");\n\t    }\n\t    de.сжатыйРазмер = de.сжатыеДанные.length;\n\t    de.цпи32 = цпи32(0, cast(проц[])de.расжатыеДанные);\n\n\t    размАрхива += 30 + de.имя.length +\n\t\t\t\tde.экстра.length +\n\t\t\t\tde.сжатыйРазмер;\n\t    размПапки += 46 + de.имя.length +\n\t\t\t\tde.экстра.length +\n\t\t\t\tde.комментарий.length;\n\t}\n\n\tданные = new ббайт[размАрхива + размПапки + 22 + комментарий.length];\n\n\t\n\n\t\n\ti = 0;\n\tforeach (ЧленАрхиваЗИП de; папка)\n\t{\n\t    de.смещение = i;\n\t    данные[i .. i + 4] = cast(ббайт[])\"PK\\x03\\x04\";\n\t    putUshort(i + 4,  de.версияИзвлечения);\n\t    putUshort(i + 6,  de.флаги);\n\t    putUshort(i + 8,  de.методСжатия);\n\t    putUint  (i + 10, cast(бцел)de.время);\n\t    putUint  (i + 14, de.цпи32);\n\t    putUint  (i + 18, de.сжатыйРазмер);\n\t    putUint  (i + 22, de.расжатыеДанные.length);\n\t    putUshort(i + 26, cast(бкрат)de.имя.length);\n\t    putUshort(i + 28, cast(бкрат)de.экстра.length);\n\t    i += 30;\n\n\t    данные[i .. i + de.имя.length] = cast(ббайт[])de.имя[];\n\t    i += de.имя.length;\n\t    данные[i .. i + de.экстра.length] = cast(ббайт[])de.экстра[];\n\t    i += de.экстра.length;\n\t    данные[i .. i + de.сжатыйРазмер] = de.сжатыеДанные[];\n\t    i += de.сжатыйРазмер;\n\t}\n\n\t\n\tпапкаOffset = i;\n\tчлоЗаписей = 0;\n\tforeach (ЧленАрхиваЗИП de; папка)\n\t{\n\t    данные[i .. i + 4] = cast(ббайт[])\"PK\\x01\\x02\";\n\t    putUshort(i + 4,  de.версияСборки);\n\t    putUshort(i + 6,  de.версияИзвлечения);\n\t    putUshort(i + 8,  de.флаги);\n\t    putUshort(i + 10, de.методСжатия);\n\t    putUint  (i + 12, cast(бцел)de.время);\n\t    putUint  (i + 16, de.цпи32);\n\t    putUint  (i + 20, de.сжатыйРазмер);\n\t    putUint  (i + 24, de.расжатыйРазмер);\n\t    putUshort(i + 28, cast(бкрат)de.имя.length);\n\t    putUshort(i + 30, cast(бкрат)de.экстра.length);\n\t    putUshort(i + 32, cast(бкрат)de.комментарий.length);\n\t    putUshort(i + 34, de.номерДиска);\n\t    putUshort(i + 36, de.внутренниеАтрибуты);\n\t    putUint  (i + 38, de.внешниеАтрибуты);\n\t    putUint  (i + 42, de.смещение);\n\t    i += 46;\n\n\t    данные[i .. i + de.имя.length] = cast(ббайт[])de.имя[];\n\t    i += de.имя.length;\n\t    данные[i .. i + de.экстра.length] = cast(ббайт[])de.экстра[];\n\t    i += de.экстра.length;\n\t    данные[i .. i + de.комментарий.length] = cast(ббайт[])de.комментарий[];\n\t    i += de.комментарий.length;\n\t    члоЗаписей++;\n\t}\n\tвсегоЗаписей = члоЗаписей;\n\n\t\n\tсмещКПоследнЗаписи = i;\n\tданные[i .. i + 4] = cast(ббайт[])\"PK\\x05\\x06\";\n\tputUshort(i + 4,  cast(бкрат)номерДиска);\n\tputUshort(i + 6,  cast(бкрат)стартПапкаДиска);\n\tputUshort(i + 8,  cast(бкрат)члоЗаписей);\n\tputUshort(i + 10, cast(бкрат)всегоЗаписей);\n\tputUint  (i + 12, размПапки);\n\tputUint  (i + 16, папкаOffset);\n\tputUshort(i + 20, cast(бкрат)комментарий.length);\n\ti += 22;\n\n\t\n\tassert(i + комментарий.length == данные.length);\n\tданные[i .. данные.length] = cast(ббайт[])комментарий[];\n\n\treturn cast(проц[])данные;\n    }\n\n\n    this(проц[] буфер)\n    {\tцел iend;\n\tцел i;\n\tцел endкомментарийlength;\n\tбцел размПапки;\n\tбцел папкаOffset;\n\n\tthis.данные = cast(ббайт[]) буфер;\n\n\t\n\tiend = данные.length - 66000;\n\tif (iend < 0)\n\t    iend = 0;\n\tfor (i = данные.length - 22; 1; i--)\n\t{\n\t    if (i < iend)\n\t\tthrow new ZipException(\"нет записи о конце\");\n\n\t    if (данные[i .. i + 4] == cast(ббайт[])\"PK\\x05\\x06\")\n\t    {\n\t\tendкомментарийlength = getUshort(i + 20);\n\t\tif (i + 22 + endкомментарийlength > данные.length)\n\t\t    continue;\n\t\tкомментарий = cast(ткст)(данные[i + 22 .. i + 22 + endкомментарийlength]);\n\t\tсмещКПоследнЗаписи = i;\n\t\tbreak;\n\t    }\n\t}\n\n\t\n\tномерДиска = getUshort(i + 4);\n\tстартПапкаДиска = getUshort(i + 6);\n\n\tчлоЗаписей = getUshort(i + 8);\n\tвсегоЗаписей = getUshort(i + 10);\n\n\tif (члоЗаписей != всегоЗаписей)\n\t    throw new ZipException(\"зип на несколько дисков не поддерживается\");\n\n\tразмПапки = getUint(i + 12);\n\tпапкаOffset = getUint(i + 16);\n\n\tif (папкаOffset + размПапки > i)\n\t    throw new ZipException(\"повреждённая папка\");\n\n\ti = папкаOffset;\n\tfor (цел n = 0; n < члоЗаписей; n++)\n\t{\n\t    \n\t    бцел смещение;\n\t    бцел длинаим;\n\t    бцел экстрадлин;\n\t    бцел комментарийlen;\n\n\t    if (данные[i .. i + 4] != cast(ббайт[])\"PK\\x01\\x02\")\n\t\tthrow new ZipException(\"неверная запись папки 1\");\n\t    ЧленАрхиваЗИП de;\n\t    de.версияСборки = getUshort(i + 4);\n\t    de.версияИзвлечения = getUshort(i + 6);\n\t    de.флаги = getUshort(i + 8);\n\t    de.методСжатия = getUshort(i + 10);\n\t    de.время = cast(ФВремяДос)getUint(i + 12);\n\t    de.цпи32 = getUint(i + 16);\n\t    de.сжатыйРазмер = getUint(i + 20);\n\t    de.расжатыйРазмер = getUint(i + 24);\n\t    длинаим = getUshort(i + 28);\n\t    экстрадлин = getUshort(i + 30);\n\t    комментарийlen = getUshort(i + 32);\n\t    de.номерДиска = getUshort(i + 34);\n\t    de.внутренниеАтрибуты = getUshort(i + 36);\n\t    de.внешниеАтрибуты = getUint(i + 38);\n\t    de.смещение = getUint(i + 42);\n\t    i += 46;\n\n\t    if (i + длинаим + экстрадлин + комментарийlen > папкаOffset + размПапки)\n\t\tthrow new ZipException(\"неверная запись папки 2\");\n\n\t    de.имя = cast(ткст)(данные[i .. i + длинаим]);\n\t    i += длинаим;\n\t    de.экстра = данные[i .. i + экстрадлин];\n\t    i += экстрадлин;\n\t    de.комментарий = cast(ткст)(данные[i .. i + комментарийlen]);\n\t    i += комментарийlen;\n\n\t    папка[de.имя] = de;\n\t}\n\tif (i != папкаOffset + размПапки)\n\t    throw new ZipException(\"неверная запись папки 3\");\n    }\n\n   \n    ббайт[]расжать(ЧленАрхиваЗИП de)\n    {\tбцел длинаим;\n\tбцел экстрадлин;\n\n\tif (данные[de.смещение .. de.смещение + 4] != cast(ббайт[])\"PK\\x03\\x04\")\n\t    throw new ZipException(\"неверная запись папки 4\");\n\n\t\n\tde.версияИзвлечения = getUshort(de.смещение + 4);\n\tde.флаги = getUshort(de.смещение + 6);\n\tde.методСжатия = getUshort(de.смещение + 8);\n\tde.время = cast(ФВремяДос)getUint(de.смещение + 10);\n\tde.цпи32 = getUint(de.смещение + 14);\n\tde.сжатыйРазмер = getUint(de.смещение + 18);\n\tde.расжатыйРазмер = getUint(de.смещение + 22);\n\tдлинаим = getUshort(de.смещение + 26);\n\tэкстрадлин = getUshort(de.смещение + 28);\n\n\t    win.скажи(фм(\"\\t\\tрасжатыйРазмер = %d\\n\", de.расжатыйРазмер));\n\t    win.скажи(фм(\"\\t\\tсжатыйРазмер = %d\\n\", de.сжатыйРазмер));\n\t    win.скажи(фм(\"\\t\\tдлинаим = %d\\n\", длинаим));\n\t    win.скажи(фм(\"\\t\\tэкстрадлин = %d\\n\", экстрадлин));\n\t\n\tif (de.флаги & 1)\n\t    throw new ZipException(\"кодирование не поддерживается\");\n\n\tцел i;\n\ti = de.смещение + 30 + длинаим + экстрадлин;\n\tif (i + de.сжатыйРазмер > смещКПоследнЗаписи)\n\t    throw new ZipException(\"неверная запись папки 5\");\n\n\tde.сжатыеДанные = данные[i .. i + de.сжатыйРазмер];\n\tdebug(print) arrayPrint(de.сжатыеДанные);\n\n\tswitch (de.методСжатия)\n\t\t{\n\t\t\tcase 0:\n\t\t\tde.расжатыеДанные = de.сжатыеДанные;\n\t\t\treturn de.расжатыеДанные;\n\n\t\t\tcase 8:\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tde.расжатыеДанные = cast(ббайт[])std.zlib.uncompress(cast(проц[])de.сжатыеДанные, de.расжатыйРазмер, -15);\n\t\t\treturn de.расжатыеДанные;\n\n\t\t\tdefault:\n\t\t\tthrow new ZipException(\"неподдерживаемый метод сжатия\");\n\t\t}\n    }    \n\n    бкрат getUshort(цел i)\n    {\n\tversion (LittleEndian)\n\t{\n\t    return *cast(бкрат *)&данные[i];\n\t}\n\telse\n\t{\n\t    ббайт b0 = данные[i];\n\t    ббайт b1 = данные[i + 1];\n\t    return (b1 << 8) | b0;\n\t}\n    }\n\n    бцел getUint(цел i)\n    {\n\tversion (LittleEndian)\n\t{\n\t    return *cast(бцел *)&данные[i];\n\t}\n\telse\n\t{\n\t    return bswap(*cast(бцел *)&данные[i]);\n\t}\n    }\n\n    проц putUshort(цел i, бкрат us)\n    {\n\tversion (LittleEndian)\n\t{\n\t    *cast(бкрат *)&данные[i] = us;\n\t}\n\telse\n\t{\n\t    данные[i] = cast(ббайт)us;\n\t    данные[i + 1] = cast(ббайт)(us >> 8);\n\t}\n    }\n\n    проц putUint(цел i, бцел ui)\n    {\n\tversion (BigEndian)\n\t{\n\t    ui = bswap(ui);\n\t}\n\t*cast(бцел *)&данные[i] = ui;\n    }\n}\n\nstruct MCI_OPEN_PARMSA {\n\tбцел dwCallback;\n\tбцел wDeviceID;\n\tсим* lpstrDeviceType;\n\tсим* lpstrElementName;\n    сим* lpstrAlias;\n}\nalias MCI_OPEN_PARMSA* PMCI_OPEN_PARMSA, LPMCI_OPEN_PARMSA;\n\nexport extern(D) бул откройДисковод(ткст drive)\n\t\t{\n\n\t\t  бцел Res; // MciError;\n\t\t  MCI_OPEN_PARMSA OpenParm;\n\t\t  бцел флаги;\n\t\t  ткст S;\n\t\t  бцел DeviceID;\n\t\t\n\t\t  бул результат = нет;\n\t\t  S = drive;\n\t\t  флаги = 0x2000 | 512;\n\t\t  with (OpenParm)\n\t\t\t{\t\t\t  \n\t\t\t\tdwCallback = 0;\n\t\t\t\tlpstrDeviceType = \"CDAudio\";\n\t\t\t\tlpstrElementName = cast(ткст0) S;\n\t\t\t}\n\t\t\t  Res = mciSendCommandA(0, 0x803, флаги, cast(бцел) &OpenParm);\n\t\t\t  if (Res<>0)\n\t\t\t  {\n\t\t\t\tdebug win.скажинс(\"\\nДисковод \"~drive~\" не обнаружен\"); результат= нет; return результат;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t  DeviceID = OpenParm.wDeviceID;\n\t\t\t  try{\n\t\t\t\t\tRes = mciSendCommandA(DeviceID, 0x80D, 256, cast(бцел)0);\n\t\t\t\t\tif (Res == 0)\n\t\t\t\t\t debug инфо(\"Дисковод \"~drive~\" открыт\");\n\t\t\t\t\tрезультат = да;\n\t\t\t\t\t}\n\t\t\t  finally\n\t\t\t  {\n\t\t\t\tmciSendCommandA(DeviceID, 0x804, флаги, cast(бцел) &OpenParm);\n\t\t\t  }\n\t\t\t  return результат;\n\t\t\t  }\n\t\t}\n\t\t\nexport extern(D) бул закройДисковод(ткст drive)\n\t\t{\n\n\t\t  бцел Res; // MciError;\n\t\t  MCI_OPEN_PARMSA OpenParm;\n\t\t  бцел флаги;\n\t\t  ткст S;\n\t\t  бцел DeviceID;\n\t\t\n\t\t  бул  результат = нет;\n\t\t  S = drive;\n\t\t  флаги = 0x2000 | 512;\n\t\t  with (OpenParm)\n\t\t\t{\t\t\t  \n\t\t\t\tdwCallback = 0;\n\t\t\t\tlpstrDeviceType = \"CDAudio\";\n\t\t\t\tlpstrElementName = cast(ткст0) S;\n\t\t\t}\n\t\t\t  Res = mciSendCommandA(0, 0x803, флаги, cast(бцел) &OpenParm);\n\t\t\t  if (Res<>0)\n\t\t\t  {\n\t\t\t\tdebug win.скажинс(\"\\nДисковод \"~drive~\" не обнаружен\"); результат= нет; return результат;\n\t\t\t\t}\n\t\t\t   else\n\t\t\t   {\t\t\t   \n\t\t\t  DeviceID = OpenParm.wDeviceID;\n\t\t\t  try{\n\t\t\t\t\tRes = mciSendCommandA(DeviceID, 0x80D, 512, cast(бцел)0);\n\t\t\t\t\tif (Res == 0)\n\t\t\t\t\t  debug инфо(\"Дисковод \"~drive~\" закрыт\");\n\t\t\t\t\tрезультат = да;\n\t\t\t\t\t}\n\t\t\t  finally\n\t\t\t  {\n\t\t\t\tmciSendCommandA(DeviceID, 0x804, флаги, cast(бцел) &OpenParm);\n\t\t\t  }\n\t\t\t  return результат;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n//Загрузчик от Derelict'а\t........................................\t\n\nchar* toCString(char[] str)\n{\n    return std.string.toStringz(str);\n}\n\nchar[] toDString(char* cstr)\n{\n        return std.string.toString(cstr);    \n}\n\nint findStr(char[] str, char[] match)\n{\n        return std.string.find(str, match);    \n}\n\nchar[][] splitStr(char[] str, char[] delim)\n{\n    return std.string.split(str, delim);\n}\n\nchar[] stripWhiteSpace(char[] str)\n{    \n        return std.string.strip(str);    \n}\n\n\nclass ИсключениеЗагрузкиБиблиотеки\n{\n\n    ткст м_назвСовмБиб;\n\t\n  static проц выведи(in ткст[] назвыБиб, in ткст[] причины)\n    {\n        ткст сооб = \"Не удалось загрузить одну (или более) ДЛЛ:\";\n        foreach(i, n; назвыБиб)\n        {\n            сооб ~= \"\\n\\t\" ~ n ~ \" - \";\n            if(i < причины.length)\n                сооб ~= причины[i];\n            else\n                сооб ~= \"Неизвестно\";\n        }\n        throw new Исключение(сооб);\n    }\n\n    this(ткст сооб)\n    {\n\tм_назвСовмБиб = \"\";\n        throw new Исключение(сооб,__FILE__, __LINE__);\n        \n    }\n\n    this(ткст сооб, ткст назвСовмБиб)\n    {\n\tм_назвСовмБиб = назвСовмБиб;\n        throw new Исключение(сооб,__FILE__, __LINE__);\n        \n    }\n\n    ткст имяБиб()\n    {\n        return м_назвСовмБиб;\n    }\n\n\n}\n\nclass ИсключениеНеверногоУкНаБиб\n{\npublic:\n\n    this(ткст назвСовмБиб)\n    {\n        throw new Исключение(\"Попытка применить указатель на незагруженную ДЛЛ \" ~ назвСовмБиб,__FILE__, __LINE__);\n        м_назвСовмБиб = назвСовмБиб;\n    }\n\n    ткст имяБиб()\n    {\n        return м_назвСовмБиб;\n    }\n\nprivate:\n    ткст м_назвСовмБиб;\n}\n\nexport ткст дайТкстОшибки()\n    {\n        // adapted from Tango\n\n        бцел ошкод = ДайПоследнююОшибку();\n\n        ткст буфСооб;\n        бцел i = ФорматируйСообА(\n            ПФорматСооб.РазмБуф | ПФорматСооб.ИзСист | ПФорматСооб.ИгнорВставки,\n            null,\n            ошкод,\n            СДЕЛАЙИДЪЯЗ(ПЯзык.НЕЙТРАЛЬНЫЙ, ППодъяз.ДЕФОЛТ),\n            буфСооб,\n            0,\n            null);\n\n        ткст text = буфСооб;\n        ОсвободиЛок(cast(лук) буфСооб);\n\n        if(i >= 2)\n            i -= 2;\n        return text[0 .. i];\n    }\n\t\nexport extern(D) class Биб\n{\nprivate{\n    ук _укз;\n    ткст _имя;\n\t}\nexport:\n    ткст имя()\n    {\n        return _имя;\n    }\n\n  this(ук укз, ткст имя)\n    {\n        _укз = адаптВхоУкз(укз);\n        _имя = имя;\n    }\n}\n\nexport extern(D) Биб загрузиБиб(ткст имяб)\nin\n{\n    assert(имяб !is null);\n}\nbody\n{\n    ук хэндл = ЗагрузиБиблиотекуА(имяб);\n    if(хэндл is null)\n        throw new Исключение(\"Не удалось загрузить библиотеку \" ~ имяб ~ \": \" ~ дайТкстОшибки(),__FILE__, __LINE__);\n    return new Биб(хэндл, имяб);\n}\n\nexport extern(D) Биб загрузиБиб(ткст[] именаб)\nin\n{\n   try\t{\n   assert(именаб !is null);\n   }\n   catch(Исключение пи){инфо(\"Не заданы имена для загрузки в функции загрузиБиб\"); выход(0);}\n}\nbody\n{\n    char[][] незагрБибы;\n    char[][] причины;\n\n    foreach(ткст имяб; именаб)\n    {\n        ук хэндл = ЗагрузиБиблиотекуА(имяб);\n        if(хэндл !is null)\n        {\n            return new Биб(хэндл, имяб);\n        }\n        else\n        {\n            незагрБибы ~= имяб;\n            причины ~= дайТкстОшибки();\n        }\n\n    }\n    ИсключениеЗагрузкиБиблиотеки.выведи(незагрБибы, причины);\n    return null; // to shut the compiler up\n}\n\nexport extern(D) проц выгрузиБиб(Биб биб)\n{\n    if(биб !is null && биб._укз !is null)\n        ОсвободиБиблиотеку(биб._укз);\n        биб._укз = null;\n}\n\nexport extern(D) ук дайПроцИзБиб(Биб биб, ткст имяПроц)\nin\n{\n    assert(биб !is null);\n    assert(имяПроц !is null);\n}\nbody\n{\n    if(биб._укз is null)\n        new ИсключениеНеверногоУкНаБиб(биб._имя);\n\t\tук proc = ДайАдресПроц(биб._укз, имяПроц);\n        if(null is proc)\n            ОбработайНедостачуПроц(биб._имя, имяПроц);\n\n        return proc;\n}\n\nalias бул function(ткст имяБиб, ткст имяПроц) ОбрвызНедостСимвола;\nalias ОбрвызНедостСимвола ОбрвызНедостПроц;\n\nprivate ОбрвызНедостСимвола обрвызНедостПроц;\n\nпроц ОбработайНедостачуПроц(ткст имяБиб, ткст имяСимвола)\n{\n    бул результат = нет;\n    if(обрвызНедостПроц !is null)\n        результат = обрвызНедостПроц(имяБиб, имяСимвола);\n    if(!результат)\n        new ИсключениеЗагрузкиБиблиотеки(имяБиб, имяСимвола);\n}\n\nexport extern(D) struct ЖанБибгр {\nexport:\n\n   проц заряжай(ткст винБибы, проц function(Биб) пользовательскийЗагр, ткст текстВерсии = \"\") {\n        assert (пользовательскийЗагр !is null);\n        this.винБибы = винБибы;\n        this.пользовательскийЗагр = пользовательскийЗагр;\n        this.текстВерсии = текстВерсии;\n    }\n\n    проц загружай(ткст текстНазвБиб = null)\n    {\n        if (мояБиб !is null) return;        \n        зарегестрированныеЗагрузчики ~= this;\n        if (текстНазвБиб is null) текстНазвБиб = винБибы;\n\n            if(текстНазвБиб is null || текстНазвБиб == \"\")\n            {\n                throw new Исключение(\"stdrus.ЖанБибгр.загружай: Название несуществующей библиотеки!\");\n            }\n        \n        ткст[] назвыБиб = текстНазвБиб.splitStr(\",\");\n        foreach (б; назвыБиб)\n\t\t\t{\n\t\t\t\tб = б.stripWhiteSpace();\n\t\t\t}\n\n        загружай(назвыБиб);\n    }\n\n    проц загружай(ткст[] назвыБиб)\n    {\n        мояБиб = загрузиБиб(назвыБиб);\n\n        if(пользовательскийЗагр is null)\n        {\n            // this should never, ever, happen\n            throw new Исключение(\"stdrus.ЖанБибгр.загружай: Кошмар! Внутренняя функция загрузки сконфигурирована с ошибками...\",__FILE__, __LINE__);\n        }\n\t\t\n        пользовательскийЗагр(мояБиб);\n\t\t\n    }\n\n    ткст строкаВерсии()\n    {\n        return текстВерсии;\n    }\n\n    проц выгружай()\n    {\n        if (мояБиб !is null) {\n            выгрузиБиб(мояБиб);\n            мояБиб = null;\n        }\n    }\n\n    бул загружено()\n    {\n        return (мояБиб !is null);\n    }\n\n    ткст имяБиб()\n    {\n        return загружено ? мояБиб.имя : null;\n    }\n\n    static ~this()\n    {\n        foreach (x; зарегестрированныеЗагрузчики) {\n            x.выгружай();\n        }\n    }\n\n    private {\n        static ЖанБибгр*[] зарегестрированныеЗагрузчики;\n\n        Биб мояБиб;\n        ткст винБибы;\n        ткст текстВерсии = \"\";\n\n        проц function(Биб) пользовательскийЗагр;\n    }\n}\n\nexport extern(D) struct ЗавЖанБибгр {\nexport:\n\n    проц заряжай(ЖанБибгр* dependence,  проц function(Биб) пользовательскийЗагр) {\n        assert (dependence !is null);\n        assert (пользовательскийЗагр !is null);\n\n        this.dependence = dependence;\n        this.пользовательскийЗагр = пользовательскийЗагр;\n    }\n\n    проц загружай()\n    {\n        assert (dependence.загружено);\n        пользовательскийЗагр(dependence.мояБиб);\n    }\n\n    ткст строкаВерсии()\n    {\n        return dependence.строкаВерсии;\n    }\n\n    проц выгружай()\n    {\n    }\n\n    бул загружено()\n    {\n        return dependence.загружено;\n    }\n\n    ткст имяБиб()\n    {\n        return dependence.имяБиб;\n    }\n\n    private {\n        ЖанБибгр*              dependence;\n        проц function(Биб)    пользовательскийЗагр;\n    }\n}\n\nstruct Вяз(T) {\n    проц opCall(ткст n, Биб lib) {\n        *fptr = дайПроцИзБиб(lib, n);\n    }\n        ук* fptr;  \n}\n\n\ntemplate вяжи(T) {\n    Вяз!(T) вяжи(inout T a) {\n        Вяз!(T) рез;\n        рез.fptr = cast(ук*)&a;\n        return рез;\n    }\n}\n\nexport extern(D) бул создайБибИзДлл(ткст имяБ, ткст имяД = null, ткст путь = null, ткст расшД = \"dll\")\n{\n\nif(имяД == null) имяД = имяБ;\nсис(фм(\"implib/system %s.lib %s%s.%s\", имяБ, путь, имяД, расшД));\nreturn да;\n}\n\nexport extern(D) бул создайЛистинг(ткст имяБ)\n{\nсис(фм(\"d:\\\\dinrus\\\\bin\\\\lib -l %s.lib\", имяБ));\nif(естьФайл(имяБ~\".lst\"))удалиФайл(имяБ~\".lib\");\n\telse throw new Исключение(\"Неудачная генерация листинга\",имяБ, __LINE__);\nreturn  да;\n}\n\nexport extern(D) цел генМакетИмпорта(ткст имяМ, ткст[] список)\n{\n\tСИСТВРЕМЯ систВремя;\n\tцел счёт = 1;\n\t\n\tДайМестнВремя(&систВремя);\n\tткст дата = вТкст(систВремя.день)~\".\"~вТкст(систВремя.месяц)~\".\"~вТкст(систВремя.год);\n\tткст время = вТкст(систВремя.час)~\" ч. \"~вТкст(систВремя.минута)~\" мин.\";\n\n\tткст заг = фм(\"\n\t/*******************************************************************************\n\t*  Файл генерирован автоматически с помощью либпроцессора Динрус               *\n\t*  Дата:%s                                           Время: %s\\n\n\t*******************************************************************************/\n\n\", дата, время);\n\n\tткст имп = фм(\"\n\tmodule lib.%s;\n\n\timport stdrus;\n\n\tпроц грузи(Биб биб)\n\t{\n\n\t\", имяМ);\n\n\tткст связка(ткст[] список)\n\t{\n\tткст вяз;\n\n\t\tforeach(выр; список)\n\t\t\t{\n\t\t\tauto рез = убери(выр);\n\t\t\tвяз ~= фм(\"\n\t\t//вяжи(функция_%s)(%s биб);\\r\\n\", счёт, рез);\n\t\t\tсчёт++;\n\t\t\t}\n\t\treturn вяз;\n\t}\t\n\n\tткст вяз = связка(список);\n\n\tткст имя = stdrus.взаг(имяМ);\t\n\n\tткст закр =\"\n\t}\\r\\n\\r\\n\";\n\n\t\t\n\tткст жб = фм(\"ЖанБибгр %s;\\r\\n\", имя);\n\n\tткст гр = фм(\"\n\t\tstatic this()\n\t\t{\n\t\t\t%s.заряжай(\\\"%s.dll\\\", &грузи );\n\t\t}\\r\\n\",имя, имяМ);\n\t\t\n\tткст гн = \"\n\textern(C)\n\t{\\r\\n\\r\\n\";\n\n\tткст функ()\n\t{\n\tткст ф;\n\t\tfor(цел ц = 1; ц < счёт; ц++ )\n\t\t{\n\t\t  ф ~= фм(\"\n\t\t//проц function() функция_%s; \\r\\n\", ц);\n\t\t}\n\t\treturn  ф;\n\t}\n\t\t\n\tткст ф = функ();\n\n\tткст итог = заг~имп~вяз~закр~жб~гр~гн~ф~закр;\n\n\tпишиФайл(имяМ~\".d\", итог);\n\tинфо(фм(\"Сгенерирован макет импорта динамической библиотеки %s,\n\t\t\tрезультирующий текст которого был записан в файл %s\",stdrus.взаг(имяМ), имяМ~\".d\"));\n\treturn 0;\t\n}\n\nткст удалитьДубликатыИзТМас(ткст текст)\n{\n    ткст строка_итог;\n    ткст[] список;\n\tсписок = разбейнастр(текст);\t\n\tцел и;\n\tint[ткст] предшстр;\n\tткст следщстр = \"\";\n\tцел проходка = 0;\n\tцел взято = -1;\n\tбул взят = нет;\n\t\n\tfor( ; и < список.length ; )\n\t{\n\t//if(auto т = _сравни(строка, предшстр) == 0) delete список[и]; предшстр = \"\";\n\t\t  \n\t\tforeach(строка; список)\n\t\t{\t\t\n\t\t\twhile(проходка == 0){ goto старт;}\n\t\t\t\t\n\t\t\t\n\t\tif(строка in предшстр) {delete строка; //_скажинс(\"удалена предшествующая\"); \n\t\t}\t\n\t\t\n\t\tстарт:\t\n\t\t\t\n\t\t\tif(строка == следщстр || строка != пусто)\n\t\t\t{\t\t\n\t\t\t\twhile(!взят)\n\t\t\t\t{\n\t\t\t\tif(строка  in предшстр)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//_скажинс(\"А я  тоже грю, конца не будет! \");\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    следщстр = пусто;\n\t\t\t\t\t\t\t\tвзят = да;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t//if(строка in предшстр){ _скажинс(\"бряк!\"); break;}\n\t\t\t\t\tif(auto т = сравни(строка, список[и]) == 0  )\n\t\t\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\t\t//_скажинс(фм(\"да: %s = %s ; и она будет взята из списка в результат\\n\", строка, список[и])) ;\n\t\t\t\t\tстрока_итог ~= строка~\"\\r\\n\"; \n\t\t\t\t\tвзято++;\t\t\t\t\t\n\t\t\t\t\tпредшстр[строка] = взято;\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t    \tforeach(стр; список)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(!(стр  in предшстр))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//_скажинс(\"Я нужен! А он? \");\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tследщстр = стр;\n\t\t\t\t\t\t\t\t\tвзят = да;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t//_скажинс(\"Бастилия взята!\");\n\t\t\t\t\tвзят = да;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tвзят = нет;\n\t\t\tif(!(строка in предшстр) && строка != следщстр && строка != пусто)\n\t\t\t{\n\t\t\tследщстр = строка;\n\t\t\t//_скажинс(\"Я нужен!\");\n\t\t\t}\n\t\t\telse {\n\t\t\t     foreach(стрк; список)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(стрк  in предшстр)\n\t\t\t\t\t\t\t\t//_скажинс(\"Типа конец, что ли? \");\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    следщстр = пусто;\n\t\t\t\t\t\t\t\tвзят = да;\n\t\t\t\t\t\t\t\tbreak;\n                        }\n\t\t\t\t\t}\n\t\t\tпроходка++;\n\t\t\tи++;\n\t\t\t//_скажинс(фм(\"проходка %s\\n, следщстр = %s\", проходка, следщстр)) ;\n\t\t}\n\t \n\t}\nreturn строка_итог;\n}\n\nткст[] обработатьЛистинг(ткст имяЛ)\n{\n ткст буф = cast(ткст) читайФайл(имяЛ~\".lst\");\n  win.скажинс(буф);\n  ткст[] список = разбейнастр(буф);\n  ткст строка_итог;\n \n    \n  foreach(строка; список)\n\t{\n\tauto рез = убери(строка);\t\t\n\tif(рез == \"Publics by name\t\tmodule\"||рез == \"Publics by module\"||рез == \"\") {рез = пусто;}\n\tif(рез != пусто) строка_итог ~= рез~\"\\n\";\t\n\t\t\n\t}\t\t\n\t\t\n\tсписок = пусто;\n\tсписок = разбей(строка_итог);\n\tстрока_итог = пусто;\n\t\t\n\tforeach(строка; список)\n\t{\n\tauto рез = убери(строка);\t\t\n\tif(рез != пусто) строка_итог ~= \"\\\"\"~рез~\"\\\",\\r\\n\"; \n\t\n\t}\t\t\n\tauto итог = удалитьДубликатыИзТМас(строка_итог);\t\n\t удалиФайл(имяЛ~\".lst\");\n\tсписок = пусто;\n\tсписок = разбей(итог);\n return список;\n}\n\nexport extern(D) проц обработай(ткст имяБ,ткст расшД = \"dll\", ткст путь = пусто, ткст имяД = пусто )\n{\nткст[] список;\nif(естьФайл(имяБ~\".d\")) удалиФайл(имяБ~\".d\");\nif(создайБибИзДлл(имяБ, имяД, путь,расшД))\n{\n   if(естьФайл(имяБ~\".lib\"))создайЛистинг(имяБ);\n   else exception.ошибка(\"Листинг файла не найден\");\n   \n     if(естьФайл(имяБ~\".lst\"))список = обработатьЛистинг(имяБ);\n\t else exception.ошибка(\"Листинг файла не обработан\");\t\n }\n else exception.ошибка(\"Не удалось создать библиотеку импорта\");\nif(список != пусто) генМакетИмпорта(имяБ, список); \n//_удалиФайл(имяБ~\".lst\"); \n}\t\n///////////////////////////////////////////////////////\nscope class PerformanceCounterScope(T)\n{\n    public:\n\tthis(T счётчик)\n\tin\n\t{\n\t    assert(null !is счётчик);\n\t}\n\tbody\n\t{\n\t    м_счётчик = счётчик;\n\n\t    м_счётчик.старт();\n\t}\n\t~this()\t{\t    м_счётчик.стоп();\t}\n\tпроц стоп()\t{ м_счётчик.стоп();}\n\tT счётчик()\t{\t    return м_счётчик;\t}\n    private:\n\tT   м_счётчик;\n\n    private:\n\tthis(PerformanceCounterScope rhs);\n}\n\n\n export extern (D) class СчётчикВысокойПроизводительности\n {\n  \n    private:\n\talias   дол    epoch_type;\n    public:\n\n\talias   дол    т_интервал;\n\talias PerformanceCounterScope!(СчётчикВысокойПроизводительности)  scope_type;\n\n    export:\n\tstatic this()\n\t{\n\t    if(!ОпросиЧастотуПроизводительности(&sm_freq))\n\t    {\n\t\tsm_freq = 0x7fffffffffffffffL;\n\t    }\n\t}\n    \n\tпроц старт()\t{\t    ОпросиСчётчикПроизводительности(&m_start);\t}\n\tпроц стоп()\t{\t    ОпросиСчётчикПроизводительности(&m_end);\t}\n   \n\tт_интервал счётПериодов(){ return m_end - m_start;\t}\n\n\tт_интервал секунды()\t{\t    return счётПериодов() / sm_freq;\t}\n\n\tт_интервал миллисекунды()\n\t{\n\t    т_интервал   результат;\n\t    т_интервал   count   =   счётПериодов();\n\n\t    if(count < 0x20C49BA5E353F7L)\n\t    {\n\t\tрезультат = (count * 1000) / sm_freq;\n\t    }\n\t    else\n\t    {\n\t\tрезультат = (count / sm_freq) * 1000;\n\t    }\n\n\t    return результат;\n\t}\n\n\tт_интервал микросекунды()\n\t{\n\t    т_интервал   результат;\n\t    т_интервал   count   =   счётПериодов();\n\n\t    if(count < 0x8637BD05AF6L)\n\t    {\n\t\tрезультат = (count * 1000000) / sm_freq;\n\t    }\n\t    else\n\t    {\n\t\tрезультат = (count / sm_freq) * 1000000;\n\t    }\n\n\t    return результат;\n\t}\n \n    private:\n\tepoch_type              m_start;    // старт of measurement период\n\tepoch_type              m_end;      // End of measurement период\n\tstatic т_интервал    sm_freq;    // Frequency\n\n }\n \n export extern (D) class СчётчикТиков\n    {\n  \n    private:\n\talias   дол    epoch_type;\n    export:\n\n\talias   дол    т_интервал;\n\n\talias PerformanceCounterScope!(СчётчикТиков) scope_type;\n    export:\n\n    export:\n\n\tпроц старт()\t{\t    m_start = win.ДайСчётТиков();\t}\n\tпроц стоп()\t{\t    m_end = win.ДайСчётТиков();\t}\n  \n    export:\n\n\tт_интервал счётПериодов()\t{\t    return m_end - m_start;\t}\n\n\tт_интервал секунды()\t{\t    return счётПериодов() / 1000;\t}\n\n\tт_интервал миллисекунды()\t{\t    return счётПериодов();\t}\n\n\tт_интервал микросекунды()\t{\t    return счётПериодов() * 1000;\t}\n\n    private:\n\tбцел    m_start;    // старт of measurement период\n\tбцел    m_end;      // End of measurement период\n    /// @}\n    }\n\nexport extern (D) class СчётчикВремениНити\n    {\n   \n    private:\n\talias   дол    epoch_type;\n    export:\n\t\n\talias   дол    т_интервал;\n\talias PerformanceCounterScope!(СчётчикВремениНити)  scope_type;\n  \n    export:\n\n\tthis(){\t    m_thread = ДайТекущуюНить();\t}\n\n   \n\tпроц старт()\n\t{\n\t    ФВРЕМЯ    creationTime;\n\t    ФВРЕМЯ    exitTime;\n\n\t    ДайВременаНити(m_thread, &creationTime, &exitTime, cast(ФВРЕМЯ*)&m_kernelStart, cast(ФВРЕМЯ*)&m_userStart);\n\t}\n\n\tпроц стоп()\n\t{\n\t    ФВРЕМЯ    creationTime;\n\t    ФВРЕМЯ    exitTime;\n\n\t    ДайВременаНити(m_thread, &creationTime, &exitTime, cast(ФВРЕМЯ*)&m_kernelEnd, cast(ФВРЕМЯ*)&m_userEnd);\n\t}\n  \n    export:\n\n\tт_интервал счётПериодаЯдра()\t{\t    return m_kernelEnd - m_kernelStart;\t}\n\n\tт_интервал секундыЯдра()\t{\t    return счётПериодаЯдра() / 10000000;\t}\n\n\tт_интервал миллисекундыЯдра()\t{\t    return счётПериодаЯдра() / 10000;\t}\n\t\n\tт_интервал микросекундыЯдра()\t{\t    return счётПериодаЯдра() / 10;\t}\n\n\tт_интервал счётПользовательскогоПериода()\t{\t    return m_userEnd - m_userStart;\t}\n\n\tт_интервал секундыПользователя()\t{\t    return счётПользовательскогоПериода() / 10000000;\t}\n\n\tт_интервал миллисекундыПользователя()\t{\t    return счётПользовательскогоПериода() / 10000;\t}\n\n\tт_интервал микросекундыПользователя()\t{\t    return счётПользовательскогоПериода() / 10;\t}\n\t\n\tт_интервал счётПериодов()\t{\t    return счётПериодаЯдра() + счётПользовательскогоПериода();\t}\n\n\tт_интервал секунды()\t{\t    return счётПериодов() / 10000000;\t}\n\n\tт_интервал миллисекунды()\t{\t    return счётПериодов() / 10000;\t}\n\n\tт_интервал микросекунды()\t{\t    return счётПериодов() / 10;\t}\n\n    private:\n\tepoch_type  m_kernelStart;\n\tepoch_type  m_kernelEnd;\n\tepoch_type  m_userStart;\n\tepoch_type  m_userEnd;\n\tук      m_thread;\n   \n    }\n\t\n\t\nexport extern (D) class СчётчикВремениПроцесса\n    {\n    private:\n\talias   дол    epoch_type;\n    export:\n\talias   дол    т_интервал;\n\talias PerformanceCounterScope!(СчётчикВремениПроцесса) scope_type;\n   \n\tstatic this()\n\t{\n\t    sm_process = ДайТекущийПроцесс();\n\t}\n\n    export:\n\n\tпроц старт()\n\t{\n\t    ФВРЕМЯ    creationTime;\n\t    ФВРЕМЯ    exitTime;\n\n\t    ДайВременаПроцесса(sm_process, &creationTime, &exitTime, cast(ФВРЕМЯ*)&m_kernelStart, cast(ФВРЕМЯ*)&m_userStart);\n\t}\n\n\tпроц стоп()\n\t{\n\t    ФВРЕМЯ    creationTime;\n\t    ФВРЕМЯ    exitTime;\n\n\t    ДайВременаПроцесса(sm_process, &creationTime, &exitTime, cast(ФВРЕМЯ*)&m_kernelEnd, cast(ФВРЕМЯ*)&m_userEnd);\n\t}\n  \n    export:\n\n\tт_интервал счётПериодаЯдра()\t{\t    return m_kernelEnd - m_kernelStart;\t}\n\t\n\tт_интервал секундыЯдра()\t{\t    return счётПериодаЯдра() / 10000000;\t}\n\n\tт_интервал миллисекундыЯдра()\t{\t    return счётПериодаЯдра() / 10000;\t}\n\n\tт_интервал микросекундыЯдра()\t{\t    return счётПериодаЯдра() / 10;\t}\n\n\tт_интервал счётПользовательскогоПериода()\t{\t    return m_userEnd - m_userStart;\t}\n\n\tт_интервал секундыПользователя()\t{\t    return счётПользовательскогоПериода() / 10000000;\t}\n\n\tт_интервал миллисекундыПользователя()\t{\t    return счётПользовательскогоПериода() / 10000;\t}\n\n\tт_интервал микросекундыПользователя()\t{\t    return счётПользовательскогоПериода() / 10;\t}\n\t\n\tт_интервал счётПериодов()\t{\t    return счётПериодаЯдра() + счётПользовательскогоПериода();\t}\n\n\tт_интервал секунды()\t{\t    return счётПериодов() / 10000000;\t}\n\n\tт_интервал миллисекунды()\t{\t    return счётПериодов() / 10000;\t}\n\n\tт_интервал микросекунды()\t{\t    return счётПериодов() / 10;\t}\n\n    private:\n\tepoch_type      m_kernelStart;\n\tepoch_type      m_kernelEnd;\n\tepoch_type      m_userStart;\n\tepoch_type      m_userEnd;\n\tstatic ук   sm_process;\n    }\n\t\n//////////////////////////////////////////\n\t\n\n\nabstract class Адрес\n{\n\tprotected адрессок* имя();\n\tprotected цел длинаИм();\n\tПСемействоАдресов семействоАдресов();\t/// Family of this address.\n\tткст вТкст();\t\t/// Human readable ткст representing this address.\n}\n\nexport extern (D)  class Протокол\n{\n\t\nexport: \n\n\tППротокол тип;\n\tткст имя;\n\tткст[] алиасы;\n\n\tпроц заполни(win.протзап* прото)\n\t{\n\tтип = cast(ППротокол)прото.прот;\n\t\tимя = std.string.toString(прото.имя).dup;\n\n\t\tint i;\n\t\tfor(i = 0;; i++)\n\t\t{\n\t\t\tif(!прото.алиасы[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(i)\n\t\t{\n\t\t\tалиасы = new ткст[i];\n\t\t\tfor(i = 0; i != алиасы.length; i++)\n\t\t\t{\n\t\t\t    алиасы[i] =\n\t\t\t\tstd.string.toString(прото.алиасы[i]).dup;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tалиасы = null;\n\t\t}\n\t\n\t}\n\tбул дайПротоколПоИмени(ткст имя)\n\t{\n\t\n\twin.протзап* прото;\n\t\tпрото = cast(протзап*) дайпротпоимени(имя);\n\t\tif(!прото)\n\t\t\treturn нет;\n\t\tзаполни(прото);\n\t\treturn да;\n\t}\n\t\n\tбул дайПротоколПоТипу(ППротокол тип)\n\t{\n\tпротзап* прото;\n\t\tпрото =cast(протзап*) дайпротпономеру(тип);\n\t\tif(!прото)\n\t\t\treturn нет;\n\t\tзаполни(прото);\n\t\treturn да;\n\t}\n}\n\nexport extern (D)  class Служба\n{\nexport:\n\n\tткст имя;\n\tткст[] алиасы;\n\tбкрат порт;\n\tткст имяПротокола;\n\n\tпроц заполни(служзап* служба)\n\t{\n\t\tимя = std.string.toString(служба.имя).dup;\n\t\tпорт = с8хбк(cast(бкрат)служба.порт);\n\t\tимяПротокола = std.string.toString(служба.прот).dup;\n\n\t\tint i;\n\t\tfor(i = 0;; i++)\n\t\t{\n\t\t\tif(!служба.алиасы[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(i)\n\t\t{\n\t\t\tалиасы = new ткст[i];\n\t\t\tfor(i = 0; i != алиасы.length; i++)\n\t\t\t{\n                            алиасы[i] =\n                                std.string.toString(служба.алиасы[i]).dup;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tалиасы = null;\n\t\t}\n\t}\n\tбул дайСлужбуПоИмени(ткст имя, ткст имяПротокола)\n\t{\n\tслужзап* serv;\n\t\tserv =cast(служзап*) дайслужбупоимени(имя, имяПротокола);\n\t\tif(!serv)\n\t\t\treturn нет;\n\t\tзаполни(serv);\n\t\treturn да;\n\t}\n\t\n\tбул дайСлужбуПоИмени(ткст имя)\n\t{\n\tслужзап* serv;\n\t\tserv =cast(служзап*) дайслужбупоимени(имя , null);\n\t\tif(!serv)\n\t\t\treturn нет;\n\t\tзаполни(serv);\n\t\treturn да;\n\t}\n\t\n\tбул дайСлужбуПоПорту(бкрат порт, ткст имяПротокола)\n\t{\n\tслужзап* serv;\n\t\tserv =cast(служзап*) дайслужбупопорту(порт, имяПротокола);\n\t\tif(!serv)\n\t\t\treturn нет;\n\t\tзаполни(serv);\n\t\treturn да;\n\t}\n\tбул дайСлужбуПоПорту(бкрат порт)\n\t{\n\tслужзап* serv;\n\t\tserv =cast(служзап*) дайслужбупопорту(порт, null);\n\t\tif(!serv)\n\t\t\treturn нет;\n\t\tзаполни(serv);\n\t\treturn да;\n\t}\n}\n\nexport extern (D)  class ИнтернетХост\n{\nexport:\n\n\tткст имя;\n\tткст[] алиасы;\n\tбцел[] списокАдр;\n\n\tпроц реальнаяХостзап(хостзап* хз)\n\t{\n\tif(хз.типадр != cast(int)ПСемействоАдресов.ИНЕТ || хз.длина != 4)\n\t\t\tthrow new ХостИскл(\"Несовпадение семейства адресов\", _lasterr());\n\t}\n\t\n\tпроц заполни(хостзап* хз)\n\t{\n\tint i;\n\t\tchar* p;\n\n\t\tимя = std.string.toString(хз.имя).dup;\n\n\t\tfor(i = 0;; i++)\n\t\t{\n\t\t\tp = хз.алиасы[i];\n\t\t\tif(!p)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(i)\n\t\t{\n\t\t\tалиасы = new ткст[i];\n\t\t\tfor(i = 0; i != алиасы.length; i++)\n\t\t\t{\n                            алиасы[i] =\n                                std.string.toString(хз.алиасы[i]).dup;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tалиасы = null;\n\t\t}\n\n\t\tfor(i = 0;; i++)\n\t\t{\n\t\t\tp = хз.списадр[i];\n\t\t\tif(!p)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(i)\n\t\t{\n\t\t\tсписокАдр = new бцел[i];\n\t\t\tfor(i = 0; i != списокАдр.length; i++)\n\t\t\t{\n\t\t\t\tсписокАдр[i] = с8хбц(*(cast(бцел*)хз.списадр[i]));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tсписокАдр = null;\n\t\t}\n\t}\n\t\n\tбул дайХостПоИмени(ткст имя)\n\t{\n\tхостзап* he;\n                synchronized(this.classinfo) he = cast(хостзап*)дайхостпоимени(имя);\n\t\tif(!he)\n\t\t\treturn нет;\n\t\t реальнаяХостзап(he);\n\t\tзаполни(he);\n\t\treturn да;\n\t}\n\tбул дайХостПоАдр(бцел адр)\n\t{\n\tбцел x = х8сбц(адр);\n\t\tхостзап* he;\n                synchronized(this.classinfo) he = cast(хостзап*) дайхостпоадресу(&x, 4, cast(int)ПСемействоАдресов.ИНЕТ);\n\t\tif(!he)\n\t\t\treturn нет;\n\t\tреальнаяХостзап(he);\n\t\tзаполни(he);\n\t\treturn да;\n\t}\n\tбул дайХостПоАдр(ткст адр)\n\t{\n\tбцел x = адр_инет(адр);\n\t\tхостзап* he;\n                synchronized(this.classinfo) he = cast(хостзап*) дайхостпоадресу(&x, 4, cast(int)ПСемействоАдресов.ИНЕТ);\n\t\tif(!he)\n\t\t\treturn нет;\n\t\tреальнаяХостзап(he);\n\t\tзаполни(he);\n\t\treturn да;\n\t}\n}\n\n\nexport extern (D)  class НеизвестныйАдрес: Адрес\n{\nexport:\n\tадрессок ас;\n\n\n\toverride адрессок* имя()\n\t{\n\t\treturn &ас;\n\t}\n\n\n\toverride цел длинаИм()\n\t{\n\t\treturn ас.sizeof;\n\t}\n\n\n\toverride ПСемействоАдресов семействоАдресов()\n\t{\n\t\treturn cast(ПСемействоАдресов) ас.семейство;\n\t}\n\n\n\toverride ткст вТкст()\n\t{\n\t\treturn std.string.toString(\"Неизвестно\");\n\t}\n}\n\nexport extern (D)  class ИнтернетАдрес: Адрес\n{\n\texport:\n\tадрессок_ин иас;\n\n\n\toverride адрессок* имя()\n\t{\n\t\treturn cast(адрессок*)&иас;\n\t}\n\n\n\toverride цел длинаИм()\n\t{\n\t\treturn иас.sizeof;\n\t}\n\n\n\tthis()\n\t{\n\t}\n\t\n\tconst бцел АДР_ЛЮБОЙ = ПИнАдр.Любой;\t/// Любое адресное число IPv4.\n\tconst бцел АДР_НЕУК = ПИнАдр.Неук;\t/// Любое неверное адресное число IPv4.\n\tconst бкрат ПОРТ_ЛЮБОЙ = 0;\t/// Любое число порта IPv4.\n\t\n\toverride ПСемействоАдресов семействоАдресов()\n\t{\n\treturn cast(ПСемействоАдресов) ПСемействоАдресов.ИНЕТ;\n\t}\n\t\n\tбкрат порт(){return с8хбк(cast(uint16_t) иас.порт);}\n\t\n\tбцел адр(){return с8хбц(cast(бцел) иас.адр.с_адр);}\n\t\n\tthis(ткст адр, бкрат порт)\n\t{\n\t\tбцел uiaddr = разбор(адр);\n\t\tif(АДР_НЕУК == uiaddr)\n\t\t{\n\t\t    ИнтернетХост ih = new ИнтернетХост;\n\t\t\tif(!ih.дайХостПоИмени(адр))\n\t\t\t\t               throw new СокетИскл(\n                                 \"Неразборчивый хост '\" ~ адр ~ \"'\");\n\t\t\tuiaddr = ih.списокАдр[0];\n\t\t}\n\t\tиас.адр.с_адр = х8сбц(cast(бцел) uiaddr);\n\t\tиас.порт = х8сбк(cast(uint16_t) порт);\n\t}\n\t\n\tthis(бцел адр, бкрат порт)\n\t{\n\t\tиас.адр.с_адр = х8сбц(адр);\n\t\tиас.порт = х8сбк(порт);\n\t}\n\n\tthis(бкрат порт)\n\t{\n\t\tиас.адр.с_адр = 0; //любой, \"0.0.0.0\"\n\t\tиас.порт = х8сбк(порт);\n\t}\n\t\n\tткст вАдрТкст()\n\t{\n\t\treturn инетс8а(cast(адрес_ин) иас.адр).dup;\n\t}\n\t\n\tткст вПортТкст()\n\t{\n\t\treturn std.string.toString(порт());\n\t}\n\t\n\toverride ткст вТкст(){return вАдрТкст()~\":\"~вПортТкст();}\n\t\n\tstatic бцел разбор(ткст адр)\n\t{\n\t\treturn с8хбц(адр_инет(адр));\n\t}\n}\n\n\nexport extern (D)  class НаборСокетов\n{\nprivate\tбцел наибсок; \nprivate\tнабор_уд набор;\n\t\nprivate\tбцел счёт(){return  набор.счёт_уд;}\n\t\n\texport:\n\n\tthis(бцел макс)\n\t{\n\t\tнаибсок = макс;\n\t\tпереуст();\n\t}\n\n\tthis()\n\t{\n\t\tthis(РАЗМНАБ_УД);\n\t}\n\t\n\tпроц переуст()\n\t{\n\t\tУД_ОБНУЛИ(cast(набор_уд*) &набор);\n\t}\n\t\n\tпроц прибавь(т_сокет с)\n\tin\n\t{\n\t\tassert(счёт < наибсок);\t\t\n\t}\n\tbody\n\t{\n\t\tУД_УСТАНОВИ(с, cast(набор_уд*) &набор);\n\t}\n\t\n\tпроц прибавь(Сокет с)\n\t{\n\t\tприбавь(с.сок);\n\t}\n\t\n\tпроц удали(т_сокет с)\n\t{\n\t\tУД_УДАЛИ(с, cast(набор_уд*) &набор);\n\t\t\n\t}\n\n\tпроц удали(Сокет с)\n\t{\n\t\tудали(с.сок);\n\t}\n\n\tцел вНаборе(т_сокет с)\n\t{\n\t\treturn УД_УСТАНОВЛЕН(с, cast(набор_уд*) &набор);\n\t}\n\n\tцел вНаборе(Сокет с)\n\t{\n\t\treturn вНаборе(с.сок);\n\t}\n\n\tбцел макс()\n\t{\n\t\treturn наибсок;\n\t}\n\n\tнабор_уд* вНабор_уд()\n\t{\n\t\treturn cast(набор_уд*) &набор;\n\t}\n\n\tцел выберич()\n\t{\t\t\n\t\t\treturn счёт;\t\t\n\t}\n\t\n}\n\n\nprivate цел _lasterr()\n\t{\n\t\treturn ВСАДайПоследнююОшибку();\n\t}\n\t\nexport extern (D)  class Сокет\n{\nprivate\n{\nт_сокет сок;\nПСемействоАдресов _семейство;\nбул _блокируемый = нет;\n}\n\nexport:\n\nthis(ПСемействоАдресов са, ПТипСок тип, ППротокол протокол)\n\t{\n\t\tсок = cast(т_сокет)сокет(са, тип, протокол);\n\t\tif(сок == т_сокет.init)\n\t\t\tthrow new СокетИскл(\"Не удаётся создать сокет\", _lasterr());\n\t\t_семейство = са;\n\t}\n\nthis(ПСемействоАдресов са, ПТипСок тип)\n\t{\n\t\tthis(са, тип, cast(ППротокол)0); // Pseudo protocol number.\n\t}\n\t\nthis(ПСемействоАдресов са, ПТипСок тип, ткст имяПротокола)\n\t{\n\t\tпротзап* прото;\n\t\tпрото = дайпротпоимени(имяПротокола);\n\t\tif(!прото)\n\t\t\tthrow new СокетИскл(\"Не удаётся найти протокол\", _lasterr());\n\t\tthis(са, тип, cast(ППротокол) прото.прот);\n\t}\n\t\n\t~this()\n\t{\n\t\tзакрой();\n\t}\n\t\nprotected this(){}\n\t\nт_сокет Ук()\n\t{\n\t\treturn сок;\n\t}\n\t\nбул блокируемый()\n\t{\n\t\treturn _блокируемый;\t\t\n\t}\n\t\nпроц блокируемый(бул б)\n\t{\n\t\t\tбцел num = !б;\n\t\t\tif(-1 == ввктлсок(сок, ВВФСБВВ, &num))\n\t\t\t\tgoto err;\n\t\t\t_блокируемый = б;\n\t\treturn; // Success.\n\n\t\terr:\n\t\tthrow new СокетИскл(\"Не удаётся установить сокет блокируемым\", _lasterr());\n\t}\n\nПСемействоАдресов семействоАдресов() // getter\n\t{\n\t\treturn _семейство;\n\t}\n\t\nбул жив_ли() // getter\n\t{\n\t\tцел тип, размтипа = тип.sizeof;\n\t\treturn !дайопцсок(cast(СОКЕТ) сок, ППротокол.СОКЕТ, ПОпцияСокета.Тип, cast(char*)&тип, &размтипа);\n\t}\n\nпроц свяжи(Адрес адр)\n\t{\n\t\tif(-1 == свяжисок(cast(СОКЕТ) сок, cast(адрессок*) адр.имя(), адр.длинаИм()))\n\t\t\tthrow new СокетИскл(\"Не удаётся связать сокет\", _lasterr());\n\t}\n\nпроц подключись(Адрес к)\n\t{\n\t\tif(-1 == подключи(cast(СОКЕТ) сок, cast(адрессок*) к.имя(), к.длинаИм()))\n\t\t{\n\t\t\tцел err;\n\t\t\terr = _lasterr();\n\n\t\t\tif(!блокируемый)\n\t\t\t{\n\t\t\t\tif(ПВинСокОш.Блокировано == err)\n\t\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t}\n\t\t\tthrow new СокетИскл(\"Не удаётся подключить сокет\", err);\n\t\t}\n\t}\n\nпроц слушай(цел backlog)\n\t{\n\t\tif(-1 == win.слушай(cast(СОКЕТ) сок, backlog))\n\t\t\tthrow new СокетИскл(\"Не удаётся прослушивание сокета\", _lasterr());\n\t}\n\t\nСокет принимающий()\n\t{\n\t\treturn new Сокет;\n\t}\n\nСокет прими()\n\t{\n\t\tт_сокет newsock;\n\t\t//newsock = cast(socket_t).accept(sock, null, null); // DMD 0.101 error: found '(' when expecting ';' following 'statement\n\t\talias win.пусти topaccept;\n\t\tnewsock = cast(т_сокет)topaccept(cast(СОКЕТ) сок, null, null);\n\t\tif(т_сокет.init == newsock)\n\t\t\tthrow new СокетИскл(\"Не удаётся принят подключение через сокет\", _lasterr());\n\n\t\tСокет newSocket;\n\t\ttry\n\t\t{\n\t\t\tnewSocket = принимающий();\n\t\t\tassert(newSocket.сок == т_сокет.init);\n\n\t\t\tnewSocket.сок = newsock;\n\t\t\tversion(Win32)\n\t\t\t\tnewSocket._блокируемый = _блокируемый; //inherits blocking mode\n\t\t\tnewSocket._семейство = _семейство; //same семейство\n\t\t}\n\t\tcatch(Объект o)\n\t\t{\n\t\t\t_close(newsock);\n\t\t\tthrow o;\n\t\t}\n\n\t\treturn newSocket;\n\t}\n\n\t/// Disables sends and/or receives.\n\tпроц экстрзак(ПЭкстрЗакрытиеСокета how)\n\t{\n\t\twin.экстрзак(cast(СОКЕТ) сок,  how);\n\t}\n\n\n\tprivate static проц _close(т_сокет сок)\n\t{\n\t\tзакройсок(cast(СОКЕТ) сок);\n\t}\n\n\tпроц закрой()\n\t{\n\t\t_close(сок);\n\t\tсок = т_сокет.init;\n\t}\n\n\n\tprivate Адрес новОбъектСемейства()\n\t{\n\t\tАдрес результат;\n\t\tswitch(_семейство)\n\t\t{\n\t\t\tcase cast(ПСемействоАдресов) ПСемействоАдресов.ИНЕТ:\n\t\t\t\tрезультат = new stdrus.ИнтернетАдрес;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tрезультат = new stdrus.НеизвестныйАдрес;\n\t\t}\n\t\treturn результат;\n\t}\n\n\nstatic ткст имяХоста() // getter\n\t{\n\t\tchar[256] результат; // Host names are limited to 255 chars.\n\t\tif(-1 == дайимяхоста(результат, результат.length))\n\t\t\tthrow new СокетИскл(\"Не удаётся получить имя хоста\", _lasterr());\n\t\treturn std.string.toString(cast(char*)результат).dup;\n\t}\n\nАдрес удалённыйАдрес()\n\t{\n\t\tАдрес адр = новОбъектСемейства();\n\t\tцел длинаИм = адр.длинаИм();\n\t\tif(-1 == дайимяпира(cast(СОКЕТ)сок, cast(адрессок*) адр.имя(), &длинаИм))\n\t\t\tthrow new СокетИскл(\"Не удаётся получить адрес удалённого сокета\", _lasterr());\n\t\tassert(адр.семействоАдресов() == _семейство);\n\t\treturn адр;\n\t}\n\nАдрес локальныйАдрес()\n\t{\n\t\tАдрес адр = новОбъектСемейства();\n\t\tцел длинаИм = адр.длинаИм();\n\t\tif(-1 == дайимясок(cast(СОКЕТ) сок, cast(адрессок*) адр.имя(), &длинаИм))\n\t\t\tthrow new СокетИскл(\"Не удаётся получить адрес локального сокета\", _lasterr());\n\t\tassert(адр.семействоАдресов() == _семейство);\n\t\treturn адр;\n\t}\n\n\tconst цел ОШИБКА = -1;\n\n\tцел шли(проц[] буф, ПФлагиСокета флаги)\n\t{\n                флаги |= ПФлагиСокета.БезСигнала;\n\t\tцел sent = win.шли(сок, буф.ptr, буф.length, флаги);\n\t\treturn sent;\n\t}\n\n\tцел шли(проц[] буф)\n\t{\n\t\treturn шли(буф, ПФлагиСокета.БезСигнала);\n\t}\n\n\tцел шли_на(проц[] буф, ПФлагиСокета флаги, Адрес to)\n\t{\n                флаги |= ПФлагиСокета.БезСигнала;\n\t\tцел sent = win.шли_на(cast(СОКЕТ) сок, буф.ptr, буф.length, флаги,cast(адрессок*) to.имя(), to.длинаИм());\n\t\treturn sent;\n\t}\n\n\tцел шли_на(проц[] буф, Адрес to)\n\t{\n\t\treturn шли_на(буф, ПФлагиСокета.Неук, to);\n\t}\n\n\tцел шли_на(проц[] буф, ПФлагиСокета флаги)\n\t{\n                флаги |= ПФлагиСокета.БезСигнала;\n\t\tцел sent = win.шли_на(cast(СОКЕТ) сок, буф.ptr, буф.length, флаги, null, нет);\n\t\treturn sent;\n\t}\n\n\tцел шли_на(проц[] буф)\n\t{\n\t\treturn шли_на(буф, ПФлагиСокета.Неук);\n\t}\n\n\tцел получи(проц[] буф, ПФлагиСокета флаги)\n\t{\n\t\tif(!буф.length) //return 0 and don't think the connection closed\n\t\t\treturn 0;\n\t\tцел read = win.прими(cast(СОКЕТ) сок, буф.ptr, буф.length, флаги);\n\t\t// if(!read) //connection closed\n\t\treturn read;\n\t}\n\n\tцел получи(проц[] буф)\n\t{\n\t\treturn получи(буф, ПФлагиСокета.Неук);\n\t}\n\n\tцел получи_от(проц[] буф, ПФлагиСокета флаги, out Адрес от)\n\t{\n\t\tif(!буф.length) //return 0 and don't think the connection closed\n\t\t\treturn 0;\n\t\tот = новОбъектСемейства();\n\t\tцел длинаИм = от.длинаИм();\n\t\tцел read = win.прими_от(cast(СОКЕТ) сок, буф.ptr, буф.length, флаги, cast(адрессок*) от.имя(), &длинаИм);\n\t\tassert(от.семействоАдресов() == _семейство);\n\t\t// if(!read) //connection closed\n\t\treturn read;\n\t}\n\n\tцел получи_от(проц[] буф, out Адрес от)\n\t{\n\t\treturn получи_от(буф, ПФлагиСокета.Неук, от);\n\t}\n\n\tцел получи_от(проц[] буф, ПФлагиСокета флаги)\n\t{\n\t\tif(!буф.length) //return 0 and don't think the connection closed\n\t\t\treturn 0;\n\t\tцел read = прими_от(cast(СОКЕТ) сок, буф.ptr, буф.length, флаги, null, null);\n\t\t// if(!read) //connection closed\n\t\treturn read;\n\t}\n\nцел получи_от(проц[] буф)\n\t{\n\t\treturn получи_от(буф, ПФлагиСокета.Неук);\n\t}\n\nцел дайОпцию(ППротокол уровень, ПОпцияСокета опция, проц[] результат)\n\t{\n\t\tцел len = результат.length;\n\t\tif(-1 == дайопцсок(cast(СОКЕТ) сок, уровень, опция, результат.ptr, &len))\n\t\t\tthrow new СокетИскл(\"Не удаётся получить опцию сокета\", _lasterr());\n\t\treturn len;\n\t}\n\nцел дайОпцию(ППротокол уровень, ПОпцияСокета опция, out цел результат)\n\t{\n\t\treturn дайОпцию(уровень, опция, (&результат)[0 .. 1]);\n\t}\n\nцел дайОпцию(ППротокол уровень, ПОпцияСокета опция, out заминка результат)\n\t{\n\t\treturn дайОпцию(уровень, опция, (&результат)[0 .. 1]);\n\t}\n\nпроц установиОпцию(ППротокол уровень, ПОпцияСокета опция, проц[] значение)\n\t{\n\t\tif(-1 == установиопцсок(сок, уровень, опция, значение.ptr, значение.length))\n\t\t\tthrow new СокетИскл(\"Не удаётся  установить опцию сокета\", _lasterr());\n\t}\n\nпроц установиОпцию(ППротокол уровень, ПОпцияСокета опция, цел значение)\n\t{\n\t\tустановиОпцию(уровень, опция, (&значение)[0 .. 1]);\n\t}\n\nпроц установиОпцию(ППротокол уровень, ПОпцияСокета опция, заминка значение)\n\t{\n\tустановиОпцию(уровень, опция, (&значение)[0 .. 1]);\n\t}\n\nstatic цел выбери(НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError, win.значврем* tv)\n\tin\n\t{\n\t\t//make sure none of the НаборСокетов'т are the same object\n\t\tif(checkRead)\n\t\t{\n\t\t\tassert(checkRead !is checkWrite);\n\t\t\tassert(checkRead !is checkError);\n\t\t}\n\t\tif(checkWrite)\n\t\t{\n\t\t\tassert(checkWrite !is checkError);\n\t\t}\n\t}\n\tbody\n\t{\n\t\tнабор_уд* fr, fw, fe;\n\t\tцел n = 0;\n\n\t\tversion(Win32)\n\t\t{\n\t\t\t// Windows has a problem with empty набор_уд`т that aren't null.\n\t\t\tfr = (checkRead && checkRead.счёт()) ? checkRead.вНабор_уд() : null;\n\t\t\tfw = (checkWrite && checkWrite.счёт()) ? checkWrite.вНабор_уд() : null;\n\t\t\tfe = (checkError && checkError.счёт()) ? checkError.вНабор_уд() : null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(checkRead)\n\t\t\t{\n\t\t\t\tfr = checkRead.вНабор_уд();\n\t\t\t\tn = checkRead.выберич();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfr = null;\n\t\t\t}\n\n\t\t\tif(checkWrite)\n\t\t\t{\n\t\t\t\tfw = checkWrite.вНабор_уд();\n\t\t\t\tцел _n;\n\t\t\t\t_n = checkWrite.выберич();\n\t\t\t\tif(_n > n)\n\t\t\t\t\tn = _n;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfw = null;\n\t\t\t}\n\n\t\t\tif(checkError)\n\t\t\t{\n\t\t\t\tfe = checkError.вНабор_уд();\n\t\t\t\tцел _n;\n\t\t\t\t_n = checkError.выберич();\n\t\t\t\tif(_n > n)\n\t\t\t\t\tn = _n;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfe = null;\n\t\t\t}\n\t\t}\n\n\t\tцел результат = win.выбери(n, cast(набор_уд*) fr, cast(набор_уд*) fw, cast(набор_уд*) fe, cast(win.значврем*)tv);\n\n\t\tversion(Win32)\n\t\t{\n\t\t\tif(-1 == результат && ВСАДайПоследнююОшибку() == ПВинСокОш.Прервано)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse version(Posix)\n\t\t{\n\t\t\tif(-1 == результат && дайНомош() == EINTR)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic assert(0);\n\t\t}\n\n\t\tif(-1 == результат)\n\t\t\tthrow new СокетИскл(\"Ошибка выбора сокета\", _lasterr());\n\n\t\treturn результат;\n\t}\n\nstatic цел выбери(НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError, цел микросекунды)\n\t{\n\t    win.значврем tv;\n\t    tv.секунды = микросекунды / 1_000_000;\n\t    tv.микросекунды = микросекунды % 1_000_000;\n\t    return выбери(checkRead, checkWrite, checkError, &tv);\n\t}\n\nstatic цел выбери(НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError)\n\t{\n\t\treturn выбери(checkRead, checkWrite, checkError, null);\n\t}\n\n}\n\n\nexport extern (D) class ПутСокет: Сокет\n{\nexport:\n\n\tthis(ПСемействоАдресов семейство)\n\t{\n\t\tsuper(семейство, ПТипСок.Поток, ППротокол.ПУТ);\n\t}\n\n\tthis()\n\t{\n\t\tthis(ПСемействоАдресов.ИНЕТ);\n\t}\n\n\tthis(Адрес подкл_к)\n\t{\n\t\tthis(подкл_к.семействоАдресов());\n\t\tподключись(подкл_к);\n\t}\n}\n\nexport extern (D) class ПпдСокет: Сокет\n{\nexport:\n\n\tthis(ПСемействоАдресов семейство)\n\t{\n\t\tsuper(семейство, ПТипСок.ДГрамма, ППротокол.ППД);\n\t}\n\n\tthis()\n\t{\n\t\tthis(ПСемействоАдресов.ИНЕТ);\n\t}\n}\n\nexport extern (D) class СокетПоток: Поток\n{\n    private:\n\tСокет сок;\n\t\n    export:\n\n\tthis(Сокет сок, ПРежимФайла режим)\n\t{\n\t\tif(режим & ПРежимФайла.Ввод)\n\t\t\tчитаемый(да);\n\t\tif(режим & ПРежимФайла.Вывод)\n\t\t\tзаписываемый(да);\n\t\t\n\t\tthis.сок = сок;\n\t}\n\t\n\tthis(Сокет сок)\n\t{\n\t\tзаписываемый(да); читаемый(да);\n\t\tthis.сок = сок;\n\t}\n\t\n\tСокет сокет()\n\t{\n\t\treturn сок;\n\t}\n\t\n\toverride т_мера читайБлок(ук _буфер, т_мера размер)\n\t{\n\t  ббайт* буфер = cast(ббайт*)адаптВхоУкз(_буфер);\n\t  проверьЧитаемость();\n\t  \n\t  if (размер == 0)\n\t    return размер;\n\t  \n\t  auto len = сок.получи(буфер[0 .. размер]);\n\t  читатьдоКФ(cast(бул)(len == 0));\n\t  if (len == сок.ОШИБКА)\n\t    len = 0;\n\t  return len;\n\t}\n\t\n\t\toverride т_мера пишиБлок(ук _буфер, т_мера размер)\n\t{\n\t  ббайт* буфер = cast(ббайт*)адаптВхоУкз(_буфер);\n\t  проверьЗаписываемость(this.toString());\n\n\t  if (размер == 0)\n\t    return размер;\n\t  \n\t  auto len = сок.шли(буфер[0 .. размер]);\n\t  читатьдоКФ(cast(бул)(len == 0));\n\t  if (len == сок.ОШИБКА) \n\t    len = 0;\n\t  return len;\n\t}\n\t\n\toverride бдол сместись(дол смещение, ППозКурсора куда)\n\t{\n\t\tthrow new Исключение(\"Перемещение по сокету невозможно.\");\n\t\t//return 0;\n\t}\n\t\n\toverride ткст вТкст()\n\t{\n\t\treturn сок.вТкст();\n\t}\n\t\n\toverride проц закрой()\n\t{\n\t\tсок.закрой();\n\t}\n}\n\n/* ================================ Win32 ================================= */\n\nextern (Windows) alias бцел (*stdfp)(ук);\nalias ук thread_hdl;\nalias бцел thread_id;\nalias ук нук;\nalias бцел нид;\n\nextern (C)    thread_hdl _beginthreadex(ук security, бцел stack_size,\n\tstdfp start_addr, ук arglist, бцел initflag,\n\tthread_id* thrdaddr);\n\n\n\nexport extern (D) нук начниНитьДоп(ук безоп, бцел размстека, stdfp стартадр, ук списаргов, бцел иницфлаг, нид* адрнити)\n{\nreturn cast(нук) _beginthreadex(безоп, размстека, стартадр, списаргов, иницфлаг, cast(thread_id*) адрнити);\n}\n\nprivate const бцел  ВЫХОД_ИЗ_ОЖИДАНИЯ = 258;\n\n\n\n/**\n * Выводится при ошибках.\n */\n \n\nclass ОшибкаНити : Исключение\n{\n\n    this(ткст т)\n    {\n\tsuper(\"Ошибка в классе Нить: \" ~ т);\n    }\n}\n\n/**\n * Для каждой нити создаётся один экземпляр этого класса. \n */\n\n\nexport  extern (D) class Нить\n{\nexport:\n    /**\n     * Конструктор, используемый производными от Нить, переписывающий main(). \n     * Необязательный параметр размстека имеет по умолчанию значение 0. С\n     * этим значением нить создаётся с размером по умолчанию для исполнимых файлов.\n     */\n    this(т_мера размстека = 0)\n    {\t\n\tthis.размстека = размстека;\t\n\t\n    }\n\n    /**\n     * Конструктор для производных от Нить, переписывающий пуск().\n     */\n    this(цел (*fp)(ук), ук арг, т_мера размстека = 0)\n    {\n\tthis.fp = fp;\n\tthis.арг = арг;\n\tthis.размстека = размстека;\n\t}\n\n    /**\n     * Constructor used by classes derived from Нить that override пуск().\n     */\n    this(цел delegate() дг, т_мера размстека = 0)\n    {\n\tthis.дг = дг;\n\tthis.размстека = размстека;\t\n    }\n\n    /**\n     * Destructor\n     *\n     * If the thread hasn't been joined yet, detach it.\n     */\n    ~this()\n    {\n        if (состояние != СН.ЗАВЕРШЕНА)\n            ЗакройДескр(hdl);\n    }\n\n    /**\n     * The хэндл to this thread assigned by the operating system. This is set\n     * to нид.init if the thread hasn't been started yet.\n     */\n    ук hdl;\n\n    ук низСтэка;\n\n    /**\n     * Create a new thread and старт it running. The new thread initializes\n     * itself and then calls пуск(). старт() can only be called once.\n     */\n   проц старт()\n    {\n\tsynchronized (Нить.classinfo)\n\t{\n\t    if (состояние != СН.НАЧАЛЬНОЕ)\n\t\t{\n\t\tпуск(); return;\n\t\t}//error(\"уже пущена\");\n\n\t    for (цел i = 0; 1; i++)\n\t    {\n\t\tif (i == allThreads.length)\n\t\t    error(\"слишком много нитей\");\n\t\tif (!allThreads[i])\n\t\t{   allThreads[i] = this;\n\t\t    инд = i;\n\t\t    if (i >= allThreadsDim)\n\t\t\tallThreadsDim = i + 1;\n\t\t    break;\n\t\t}\n\t    }\n\t    члонн++;\n\t\t\n\n\t    состояние = СН.ПУЩЕНА;\n\t    hdl = начниНитьДоп(null, cast(бцел) размстека, &стартнити, cast(ук) this, 0, &id);\n\t    if (hdl == cast(ук) 0)\n\t    {\n\t\tallThreads[инд] = null;\n\t\tчлонн--;\n\t\t\n\t\tсостояние = СН.ЗАВЕРШЕНА;\n\t\tинд = -1;\n\t\terror(\"не удался старт\");\n\t    }\n\t}\n    }\n\n    /**\n     * Точка входа в нить. Если не переписан, то вызывает\n     * указатель на функцию fp и аргумент арг пререданный конструктору, или делегат\n     * дг.\n     * Возвращает: код выхода нити, обычно 0.\n     */\n\t\t\n    цел пуск()\n    {\n\tif (fp)\n\t    return fp(арг);\n\telse if (дг)\n\t    return дг();\n\tassert(0);\n    }\n\n    /*****************************\n     * Wait for this thread to terminate.\n     * Simply returns if thread has already terminated.\n     * Выводит исключение: $(B ОшибкаНити) if the thread hasn't begun yet or\n     * is called on itself.\n     */\n    проц жди()\n    {\n\tif (сама_ли)\n\t    error(\"ожидание самой себя\");\n\tif (состояние != СН.ЗАВЕРШЕНА)\n\t{   бцел dw;\n\n\t    dw = ЖдиОдинОбъект(hdl, 0xFFFFFFFF);\n            состояние = СН.ЗАВЕРШЕНА;\n            ЗакройДескр(hdl);\n            hdl = null;\n\t}\n    }\n\n    /******************************\n     * Wait for this thread to terminate or until миллисек time has\n     * elapsed, whichever occurs first.\n     * Simply returns if thread has already terminated.\n     * Выводит исключение: $(B ОшибкаНити) if the thread hasn't begun yet or\n     * is called on itself.\n     */\n    проц жди(бцел миллисек)\n    {\n\tif (сама_ли)\n\t    error(\"ожидание самой себя\");\n\tif (состояние != СН.ЗАВЕРШЕНА)\n\t{   бцел dw;\n\n\t    dw = ЖдиОдинОбъект(hdl, миллисек);\n\t    if (dw != ВЫХОД_ИЗ_ОЖИДАНИЯ)\n\t    {\n\t\tсостояние = СН.ЗАВЕРШЕНА;\n\t\tЗакройДескр(hdl);\n\t\thdl = null;\n\t    }\n\t}\n    }\n\n    /**\n     * Состояние нити.\n     */\n    enum СН\n    {\n\tНАЧАЛЬНОЕ,\t/// The thread hasn't been started yet.\n\tПУЩЕНА,\t/// The thread is running or paused.\n\tПРЕРВАНА,\t/// The thread has ended.\n        ЗАВЕРШЕНА        /// The thread has been cleaned up\n    }\n\n    /**\n     * Возвращает состояние нити.\n     */\n    СН дайСостояние()\n    {\n\treturn состояние;\n    }\n\n    /**\n     * Приоритет нити.\n     */\n    enum ПРИОРИТЕТ\n    {\n\tУВЕЛИЧЬ,\t/// Increase thread приоритет\n\tУМЕНЬШИ,\t/// Decrease thread приоритет\n\tНИЗКИЙ,\t\t/// Assign thread low приоритет\n\tВЫСОКИЙ,\t/// Assign thread high приоритет\n\tНОРМАЛЬНЫЙ,\n    }\n\n    /**\n     * Регулирует приоритет текущей нити.\n     * Выводит исключение: ОшибкаНити, если не удаётся установить приоритет\n     */\n    проц устПриор(ПРИОРИТЕТ p)\n    {\n\tППриоритетНити nPriority;\n\n\tswitch (p)\n\t{\n\t    case ПРИОРИТЕТ.УВЕЛИЧЬ:\n\t\tnPriority = ППриоритетНити.ВышеНормы;\n\t\tbreak;\n\t    case ПРИОРИТЕТ.УМЕНЬШИ:\n\t\tnPriority = ППриоритетНити.ВышеНормы;\n\t\tbreak;\n\t    case ПРИОРИТЕТ.НИЗКИЙ:\n\t\tnPriority = ППриоритетНити.Холостая;\n\t\tbreak;\n\t    case ПРИОРИТЕТ.ВЫСОКИЙ:\n\t\tnPriority = ППриоритетНити.НизРеалВрем;\n\t\tbreak;\n\t    case ПРИОРИТЕТ.НОРМАЛЬНЫЙ:\n\t\tnPriority = ППриоритетНити.Норма;\n\t\tbreak;\n\t    default:\n\t\tassert(0);\n\t}\n\n\tif (УстановиПриоритетНити(hdl, nPriority) == ППриоритетНити.ВозвратОшибок)\n\t    error(\"установка приоритета\");\n    }\n\n    /**\n     * Вернёт да, если данная нить является текущей нитью.\n     */\n    bool сама_ли()\n    {\n\t//эхо(\"id = %d, этот = %d\\n\", id, эта_нить());\n\treturn (id == ДайИдТекущейНити());\n    }\n\n    /**\n     * Возвращает ссылку на Нить, вызвавшую функцию.\n     */\n    static Нить дайЭту()\n    {\n\t//эхо(\"дайЭту(), allThreadsDim = %d\\n\", allThreadsDim);\n        бцел id = ДайИдТекущейНити();\n        for (цел i = 0; i < allThreadsDim; i++)\n        {\n            Нить t = allThreads[i];\n            if (t && id == t.id)\n            {\n                return t;\n            }\n        }\n\t//win.скажинс(\"Нить, вызвавшая функцию, не обнаружена\");\n\tassert(0);\n    }\n\n    /**\n     * Возвращает массив всех выполняемых нитей.\n     */\n    static Нить[] дайВсе()\n    {\n\tsynchronized (Нить.classinfo) return allThreads[0 .. allThreadsDim];\n    }\n\n\tбцел дайЧлоНитей()\n\t{\n\treturn члонн;\n\t}\n\t\n    /**\n     * Приостановить выполнение текущей нити.\n     */\n    проц пауза()\n    {\n\tif (состояние != СН.ПУЩЕНА || ЗаморозьНить(hdl) == 0xFFFFFFFF)\n\t    error(\"не удаётся пауза\");\n    }\n\n    /**\n     * Возобновить выполнение текущей нити.\n     */\n    проц возобнови()\n    {\n\tif (состояние != СН.ПУЩЕНА || РазморозьНить(hdl) == 0xFFFFFFFF)\n\t    error(\"не удаётся возобновить\");\n    }\n\n    /**\n     * Приостановить выполнение всех, кроме этой, нитей.\n     */\n    static проц паузаВсем()\n    {\n        synchronized (Нить.classinfo)\n        {\n            if (члонн > 1)\n            {\n\t\tбцел thisid = ДайИдТекущейНити();\n\n\t\tfor (цел i = 0; i < allThreadsDim; i++)\n\t\t{\n\t\t    Нить t = allThreads[i];\n\t\t    if (t && t.id != thisid && t.состояние == СН.ПУЩЕНА)\n\t\t\tt.пауза();\n\t\t}\n            }\n        }\n    }\n\n    /**\n     * Возобновить все приостановленные нити.\n     */\n    static проц возобновиВсе()\n    {\n        synchronized (Нить.classinfo)\n        {\n            if (члонн > 1)\n            {\n                бцел thisid = ДайИдТекущейНити();\n\n                for (цел i = 0; i < allThreadsDim; i++)\n                {\n                    Нить t = allThreads[i];\n                    if (t && t.id != thisid && t.состояние == СН.ПУЩЕНА)\n                        t.возобнови();\n                }\n            }\n        }\n    }\n\n    /**\n     * Отбросить остаток отрезка времени данной нити.\n     */\n    static проц рви()\n    {\n\tСпи(0);\n    }\n\n    /**\n     *\n     */\n    static бцел члонн = 0;\n\t\n\t\nprivate\n{\n\n    static бцел allThreadsDim;\n    static Нить[0x400] allThreads;\t// длина соответствует значению в рантайме Си\n\n    СН состояние = СН.НАЧАЛЬНОЕ;\n    цел инд = -1;\t\t\t// index into allThreads[]\n    бцел id;\n    т_мера размстека = 0;\n\n    цел (*fp)(ук);\n    ук арг;\n\n    цел delegate() дг;\n\n    проц error(ткст msg)\n    {\n\tthrow new ОшибкаНити(msg);\n    }\n\n\n}   \n /* ***********************************************\n     * Это просто мост между C rtl и Нить.пуск().\n     */\n\n   export extern (Windows) static бцел стартнити(ук p)\n    {\n\tНить t = cast(Нить) p;\n\tцел результат;\n\n\tdebug (thread) скажифнс(\"Starting thread %d\\n\", t.инд);\n\tt.низСтэка = дай_низ_стека();\n\ttry\n\t{\n\t    результат = t.пуск();\n\t}\n\tcatch (Object o)\n\t{\n\t    fprintf(cast(фук) cidrus.stderr, \"Error: %.*т\\n\", o.toString());\n\t    результат = 1;\n\t}\n\n\tdebug (thread) скажифнс(\"Ending thread %d\\n\", t.инд);\n        synchronized (Нить.classinfo)\n        {\n            allThreads[t.инд] = null;\n            члонн--;\n\t\t\t\n\t    t.состояние = СН.ПРЕРВАНА;\n            t.инд = -1;\n        }\n\treturn результат;\n    }\n\n\n    /**************************************\n     * Создаёт Нить для глобальной функции main().\n     */\n\n    public static проц пускНити()\n    {\n\tdebug(Нить) win.скажинс(\"Нить будет запускаться...\");\n\tНить t = new .Нить();\n\twin.скажинс (\"Создан экземпляр Нити\");\n\tt.состояние = СН.ПУЩЕНА;\n\tt.id = ДайИдТекущейНити();\n\tdebug(Нить) win.скажинс (\"Выполнена команда ДайИдТекущейНити\");\n\tt.hdl = Нить.дайУкНаТекНить();\n\tdebug(Нить) win.скажинс(\"Получен указатель на текущую нить\");\n\tt.низСтэка = дай_низ_стека();\n\tdebug(Нить) win.скажинс(\"Произведён опрос низа стека\");\n\n\tassert(!allThreads[0]);\n\tallThreads[0] = t;\n\tallThreadsDim = 1;\n\tt.инд = 0;\n\tdebug(Нить) win.скажи(\"Выполнены все необходимые проверки и присвоения\");\n\t}\n\n    static ~this()\n    {\n\tif (allThreadsDim)\n\t{\n\t    ЗакройДескр(allThreads[0].hdl);\n\t    allThreads[0].hdl = ДайТекущуюНить();\n\t}\n    }\n          \n    /********************************************\n     * Returns the хэндл of the current thread.\n     * This is needed because ДайТекущуюНить() always returns -2 which\n     * is a pseudo-хэндл representing the current thread.\n     * The returned thread хэндл is a windows resource and must be explicitly\n     * closed.\n     * Many thanks to Justin (jhenzie@mastd.c.com) for figuring this out\n     * and providing the fix.\n     */\n    static ук дайУкНаТекНить()\n    {\n\tук currentThread = ДайТекущуюНить();\n\tук actualThreadHandle;\n\n\t//ук currentProcess = cast(ук)-1;\n\tук currentProcess = ДайТекущийПроцесс(); // http://www.digitalmars.com/drn-bin/wwwnews?D/21217\n\n\n\tбцел access = cast(бцел)0x00000002;\n\n\tДублируйДескр(currentProcess, currentThread, currentProcess,\n\t\t\t &actualThreadHandle, cast(ППраваДоступа)0, да, access);\n\n\treturn actualThreadHandle;\n     }\n}\n\n/**********************************************\n * Determine \"bottom\" of stack (actually the top on Win32 systems).\n */\n\n export extern(D) ук дай_низ_стека()\n{\n    asm\n    {\n\tnaked\t\t\t;\n\tmov\tEAX,FS:4\t;\n\tret\t\t\t;\n    }\n}\n\n////////////////////////////////////\nexport extern(D):\n\n/** Get an environment variable D-ly */\nткст дайПеремСреды(ткст пер)\n{\n        сим[10240] буфер;\n        буфер[0] = '\\0';\n        GetEnvironmentVariableA(\n                вТкст0(пер),\n                буфер.ptr,\n                10240);\n        return вТкст(буфер.ptr);\n\n}\n\n/** Set an environment variable D-ly */\nпроц устПеремСреды(ткст пер, ткст знач)\n{\n        SetEnvironmentVariableA(\n            вТкст0(пер),\n            вТкст0(знач));\n\n}\n\n/** Get the system PATH */\nткст[] дайПуть()\n{\n    return разбей(вТкст(getenv(\"PATH\")), РАЗДПСТР);\n}\n\n/** From args[0], figure out our путь.  Returns 'нет' on failure */\nбул гдеЯ(ткст argvz, inout ткст пап, inout ткст bname)\n{\n    // split it\n    bname = извлекиИмяПути(argvz);\n    пап = извлекиПапку(argvz);\n    \n    // on Windows, this is a .exe\n    version (Windows) {\n        bname = устДефРасш(bname, \"exe\");\n    }\n    \n    // is this a directory?\n    if (пап != \"\") {\n        if (!абсПуть_ли(пап)) {\n            // make it absolute\n            пап = дайтекпап() ~ РАЗДПАП ~ пап;\n        }\n        return да;\n    }\n    \n    version (Windows) {\n        // is it in cwd?\n        char[] cwd = дайтекпап();\n        if (естьФайл(cwd ~ РАЗДПАП ~ bname)) {\n            пап = cwd;\n            return да;\n        }\n    }\n    \n    // rifle through the путь\n    char[][] путь = дайПуть();\n    foreach (pe; путь) {\n        char[] fullname = pe ~ РАЗДПАП ~ bname;\n        if (естьФайл(fullname)) {\n            version (Windows) {\n                пап = pe;\n                return да;\n            } else {\n                if (дайАтрибутыФайла(fullname) & 0100) {\n                    пап = pe;\n                    return да;\n                }\n            }\n        }\n    }\n    \n    // bad\n    return нет;\n}\n\n/// Return a canonical pathname\nткст канонПуть(ткст исхПуть)\n{\n    char[] возвр;\n    \n    version (Windows) {\n        // replace any altsep with sep\n        if (АЛЬТРАЗДПАП.length) {\n            возвр = замени(исхПуть, АЛЬТРАЗДПАП, \"\\\\\\\\\");\n        } else {\n            возвр = исхПуть.dup;\n        }\n    } else {\n        возвр = исхПуть.dup;\n    }\n    \n    // expand tildes\n    возвр = разверниТильду(возвр);\n    \n    // get rid of any duplicate separators\n    for (int i = 0; i < возвр.length; i++) {\n        if (возвр[i .. (i + 1)] == РАЗДПАП) {\n            // drop the duplicate separator\n            i++;\n            while (i < возвр.length &&\n                   возвр[i .. (i + 1)] == РАЗДПАП) {\n                возвр = возвр[0 .. i] ~ возвр[(i + 1) .. $];\n            }\n        }\n    }\n    \n    // make sure we don't miss a .. element\n    if (возвр.length > 3 && возвр[($-3) .. $] == РАЗДПАП ~ \"..\") {\n        возвр ~= РАЗДПАП;\n    }\n    \n    // or a . element\n    if (возвр.length > 2 && возвр[($-2) .. $] == РАЗДПАП ~ \".\") {\n        возвр ~= РАЗДПАП;\n    }\n    \n    // search for .. elements\n    for (int i = 0; возвр.length > 4 && i <= возвр.length - 4; i++) {\n        if (возвр[i .. (i + 4)] == РАЗДПАП ~ \"..\" ~ РАЗДПАП) {\n            // drop the previous путь element\n            int j;\n            for (j = i - 1; j > 0 && возвр[j..(j+1)] != РАЗДПАП; j--) {}\n            if (j > 0) {\n                // cut\n                if (возвр[j..j+2] == \"/.\") {\n                    j = i + 2; // skip it\n                } else {\n                    возвр = возвр[0..j] ~ возвр[(i + 3) .. $];\n                }\n            } else {\n                // can't cut\n                j = i + 2;\n            }\n            i = j - 1;\n        }\n    }\n    \n    // search for . elements\n    for (int i = 0; возвр.length > 2 && i <= возвр.length - 3; i++) {\n        if (возвр[i .. (i + 3)] == РАЗДПАП ~ \".\" ~ РАЗДПАП) {\n            // drop this путь element\n            возвр = возвр[0..i] ~ возвр[(i + 2) .. $];\n            i--;\n        }\n    }\n\n    // get rid of any introductory ./'т\n    while (возвр.length > 2 && возвр[0..2] == \".\" ~ РАЗДПАП) {\n        возвр = возвр[2..$];\n    }\n    \n    // finally, get rid of any trailing separators\n    while (возвр.length &&\n           возвр[($ - 1) .. $] == РАЗДПАП) {\n        возвр = возвр[0 .. ($ - 1)];\n    }\n\t\n    return возвр;\n}\n\n/** Make a directory and all parent directories */\nпроц сделпапР(ткст пап)\n{\n    пап = канонПуть(пап);\n    version (Windows) {\n        пап = замени(пап, \"/\", \"\\\\\\\\\");\n    }\n    \n    // split it into elements\n    char[][] элтыпап = разбей(пап, \"\\\\\\\\\");\n    \n    char[] текпап;\n    \n    // check for root пап\n    if (элтыпап.length &&\n        элтыпап[0] == \"\") {\n        текпап = РАЗДПАП;\n        элтыпап = элтыпап[1..$];\n    }\n    \n    // then go piece-by-piece, making directories\n    foreach (элтпап; элтыпап) {\n        if (текпап.length) {\n            текпап ~= РАЗДПАП ~ элтпап;\n        } else {\n            текпап ~= элтпап;\n        }\n        \n        if (!естьФайл(текпап)) {\n            сделайпап(текпап);\n        }\n    }\n}\n\n/** Remove a file or directory and all of its children */\nпроц удалиРек(ткст имя)\n{\n    // can only delete writable files on Windows\n    version (Windows) {\n        SetFileAttributesA(toStringz(имя),\n                           GetFileAttributesA(toStringz(имя)) &\n                           ~0x00000001);\n    }\n    \n    if (std.file.isdir(имя)) {\n        foreach (элем; std.file.listdir(имя)) {\n            // don't delete . or ..\n            if (элем == \".\" ||\n                элем == \"..\") continue;\n            удалиРек(имя ~ РАЗДПАП ~ элем);\n        }\n        \n        // remove the directory itself\n        std.file.rmdir(имя);\n    } else {\n        std.file.remove(имя);\n    }\n}\n\n\nprivate{\n    бул[ткст] спСущФайлов;\n}\n\n// --------------------------------------------------\nбул естьФайлВКэш(ткст имяФ)\n{\n    if (имяФ in спСущФайлов)\n    {\n        return да;\n    }\n    try {\n    if(файл_ли(имяФ) && естьФайл(имяФ))\n    {\n        спСущФайлов[имяФ] = да;\n        return да;\n    }\n    } catch { };\n    return нет;\n}\n\n// --------------------------------------------------\nпроц удалиКэшСущФайлов()\n{\n    ткст[] спКлюч;\n\n    спКлюч = спСущФайлов.keys.dup;\n    foreach(ткст спФайл; спКлюч)\n    {\n        спСущФайлов.remove(спФайл);\n    }\n}\n\n/+\nСФайл двхо;\nСФайл двых;\nСФайл дош;\n\nstatic this() {\n  // open standard I/O devices\n  двхо = new СФайл(дайСтдвхо(), ПФРежим.Ввод);\n  двых = new СФайл(дайСтдвых(), ПФРежим.Вывод);\n  дош = new СФайл(дайСтдош(), ПФРежим.Вывод);\n}\n\nstatic ~this()\n {\n  двхо.слей();\n  двхо.закрой();\n  двых.слей();\n  двых.закрой();\n  дош.слей();\n  дош.закрой();\n}\n+/",
			"file": "stdrus.d",
			"file_size": 320575,
			"file_write_time": 131306695886103515,
			"settings":
			{
				"buffer_size": 236731,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "\n// Написано на языке программирования Динрус. Разработчик Виталий Кулич.\n\n/* /////////////////////////////////////////////////////////////////////////////\n * File:        loader.d (originally from synsoft.win32..loader)\n *\n * Purpose:     Win32 exception classes\n *\n * Created      18th October 2003\n * Updated:     24th April 2004\n *\n * Author:      Matthew Wilson\n *\n * ////////////////////////////////////////////////////////////////////////// */\n\n/** \\file D/std/loader.d This file contains the \\c D standard library \n * executable module loader library, and the ExeModule class.\n */\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\nmodule std.loader;\n\n/* /////////////////////////////////////////////////////////////////////////////\n * Imports\n */\n\nprivate import std.string, std.utf;\nprivate import cidrus;\n\n//import synsoft.types;\n/+ + These are borrowed from synsoft.types, until such time as something similar is in Phobos ++\n +/\npublic alias int                    boolean;\n\n/* /////////////////////////////////////////////////////////////////////////////\n * external function declarations\n */\n\nversion(Windows)\n{\n    private import sys.WinFuncs;\n    private import rt.syserror;\n\n    extern (Windows)\n    {\n        alias HMODULE HModule_;\n    }\n}\nelse version(Posix)\n{\n    private import os.posix;\n\n    extern (C)\n    {\n\talias void* HModule_;\n    }\n}\nelse\n{\n\tconst int platform_not_discriminated = 0;\n\n\tstatic assert(platform_not_discriminated);\n}\n\n/** The platform-independent module хэндл. Note that this has to be\n * separate from the platform-dependent хэндл because different module names\n * can результат in the same module being loaded, which cannot be detected in\n * some operating systems\n */\ntypedef void    *HXModule;\n\n/* /////////////////////////////////////////////////////////////////////////////\n * ExeModule functions\n */\n\n/* These are \"forward declared\" here because I don't like the way D forces me\n * to provide my declaration and implementation together, and mixed in with all\n * the other implementation gunk.\n */\n\n/** ExeModule library Initialisation\n *\n * \\retval <0 Initialisation failed. Processing must gracefully terminate, \n * without making any use of the ExeModule library\n * \\retval 0 Initialisation succeeded for the first time. Any necessary resources\n * were successfully allocated\n * \\retval >0 Initialisation has already succeefully completed via a prior call.\n */\npublic int ExeModule_Init()\n{\n    return ExeModule_Init_();\n}\n\npublic void ExeModule_Uninit()\n{\n    ExeModule_Uninit_();\n}\n\n/** \n *\n * \\note The value of the хэндл returned may not be a valid хэндл for your operating\n * system, and you <b>must not</b> attempt to use it with any other operating system\n * or other APIs. It is only valid for use with the ExeModule library.\n */\npublic HXModule ExeModule_Load(in string moduleName)\n{\n    return ExeModule_Load_(moduleName);\n}\n\npublic HXModule ExeModule_AddRef(HXModule hModule)\n{\n    return ExeModule_AddRef_(hModule);\n}\n\n/**\n *\n * \\param hModule The module handler. It must not be null.\n */\npublic void ExeModule_Release(inout HXModule hModule)\n{\n    ExeModule_Release_(hModule);\n}\n\npublic void *ExeModule_GetSymbol(inout HXModule hModule, in string symbolName)\n{\n    return ExeModule_GetSymbol_(hModule, symbolName);\n}\n\npublic string ExeModule_Error()\n{\n    return ExeModule_Error_();\n}\n\n\nversion(Windows)\n{\n    private int         s_init;\n    private int         s_lastError;    // This is NOT thread-specific\n\n    private void record_error_()\n    {\n        s_lastError = GetLastError();\n    }\n\n\n    private int ExeModule_Init_()\n    {\n        return ++s_init > 1;\n    }\n\n    private void ExeModule_Uninit_()\n    {\n        --s_init;\n    }\n\n    private HXModule ExeModule_Load_(in string moduleName)\n    in\n    {\n        assert(null !is moduleName);\n    }\n    body\n    {\n        HXModule hmod = cast(HXModule)LoadLibraryA(toStringz(moduleName));\n\n        if(null is hmod)\n        {\n            record_error_();\n        }\n\n        return hmod;\n    }\n\n    private HXModule ExeModule_AddRef_(HXModule hModule)\n    in\n    {\n        assert(null !is hModule);\n    }\n    body\n    {\n        return ExeModule_Load_(ExeModule_GetPath_(hModule));\n    }\n\n    private void ExeModule_Release_(inout HXModule hModule)\n    in\n    {\n        assert(null !is hModule);\n    }\n    body\n    {\n        if(!FreeLibrary(cast(HModule_)hModule))\n        {\n            record_error_();\n        }\n        hModule = null;\n    }\n\n    private void *ExeModule_GetSymbol_(inout HXModule hModule, in string symbolName)\n    in\n    {\n        assert(null !is hModule);\n    }\n    body\n    {\n        void    *symbol = GetProcAddress(cast(HModule_)hModule, toStringz(symbolName));\n\n        if(null is symbol)\n        {\n            record_error_();\n        }\n\n        return symbol;\n    }\n\n    private string ExeModule_Error_()\n    {\n\treturn sysErrorString(s_lastError);\n    }\n\n    private string ExeModule_GetPath_(HXModule hModule)\n    {\n        char    szFileName[260]; // Need to use a constant here\n\n\t// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getmodulefilename.asp\n        uint cch = GetModuleFileNameA(cast(HModule_)hModule, szFileName.ptr, szFileName.length);\n\n\tif (cch == 0)\n\t{\n            record_error_();\n\t}\n        return szFileName[0 .. cch].dup;\n    }\n}\nelse version(Posix)\n{\n    private class ExeModuleInfo\n    {\n    public:\n        int         m_cRefs;\n        HModule_    m_hmod;\n        string      m_name;\n\n        this(HModule_ hmod, string name)\n        {\n            m_cRefs =   1;\n            m_hmod  =   hmod;\n            m_name  =   name;\n        }\n    };\n\n    private int                     s_init;\n    private ExeModuleInfo [string]  s_modules;\n    private string                  s_lastError;    // This is NOT thread-specific\n\n    private void record_error_()\n    {\n        char *err = dlerror();\n        s_lastError = (null is err) ? \"\" : err[0 .. cidrus.strlen(err)];\n    }\n\n    private int ExeModule_Init_()\n    {\n        if(1 == ++s_init)\n        {\n\n            return 0;\n        }\n\n        return 1;\n    }\n\n    private void ExeModule_Uninit_()\n    {\n        if(0 == --s_init)\n        {\n        }\n    }\n\n    private HXModule ExeModule_Load_(in string moduleName)\n    in\n    {\n        assert(null !is moduleName);\n    }\n    body\n    {\n\tExeModuleInfo*   mi_p = moduleName in s_modules;\n\tExeModuleInfo   mi = mi_p is null ? null : *mi_p;\n\n        if(null !is mi)\n        {\n            return (++mi.m_cRefs, cast(HXModule)mi);\n        }\n        else\n        {\n            HModule_    hmod = dlopen(toStringz(moduleName), RTLD_NOW);\n\n            if(null is hmod)\n            {\n                record_error_();\n\n                return null;\n            }\n            else\n            {\n                ExeModuleInfo   mi2  =   new ExeModuleInfo(hmod, moduleName);\n\n                s_modules[moduleName]   =   mi2;\n\n                return cast(HXModule)mi2;\n            }\n        }\n    }\n\n    private HXModule ExeModule_AddRef_(HXModule hModule)\n    in\n    {\n        assert(null !is hModule);\n\n        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;\n\n        assert(0 < mi.m_cRefs);\n        assert(null !is mi.m_hmod);\n        assert(null !is mi.m_name);\n        assert(null !is s_modules[mi.m_name]);\n        assert(mi is s_modules[mi.m_name]);\n    }\n    body\n    {\n        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;\n\n        if(null !is mi)\n        {\n            return (++mi.m_cRefs, hModule);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    private void ExeModule_Release_(inout HXModule hModule)\n    in\n    {\n        assert(null !is hModule);\n\n        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;\n\n        assert(0 < mi.m_cRefs);\n        assert(null !is mi.m_hmod);\n        assert(null !is mi.m_name);\n        assert(null !is s_modules[mi.m_name]);\n        assert(mi is s_modules[mi.m_name]);\n    }\n    body\n    {\n        ExeModuleInfo   mi      =   cast(ExeModuleInfo)hModule;\n\n        if(0 == --mi.m_cRefs)\n        {\n            string      name    =   mi.m_name;\n\n            if (dlclose(mi.m_hmod))\n            {\n                record_error_();\n            }\n            s_modules.remove(name);\n            delete mi;\n        }\n\n        hModule = null;\n    }\n\n    private void *ExeModule_GetSymbol_(inout HXModule hModule, in string symbolName)\n    in\n    {\n        assert(null !is hModule);\n\n        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;\n\n        assert(0 < mi.m_cRefs);\n        assert(null !is mi.m_hmod);\n        assert(null !is mi.m_name);\n        assert(null !is s_modules[mi.m_name]);\n        assert(mi is s_modules[mi.m_name]);\n    }\n    body\n    {\n        ExeModuleInfo   mi      =   cast(ExeModuleInfo)hModule;\n        void *symbol = dlsym(mi.m_hmod, toStringz(symbolName));\n\n        if(null == symbol)\n        {\n            record_error_();\n        }\n\n        return symbol;\n    }\n\n    private string ExeModule_Error_()\n    {\n        return s_lastError;\n    }\n\n    private string ExeModule_GetPath_(HXModule hModule)\n    in\n    {\n        assert(null !is hModule);\n\n        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;\n\n        assert(0 < mi.m_cRefs);\n        assert(null !is mi.m_hmod);\n        assert(null !is mi.m_name);\n        assert(null !is s_modules[mi.m_name]);\n        assert(mi is s_modules[mi.m_name]);\n    }\n    body\n    {\n        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;\n\n        return mi.m_name;\n    }\n}\nelse\n{\n\tconst int platform_not_discriminated = 0;\n\n\tstatic assert(platform_not_discriminated);\n}\n\n/* /////////////////////////////////////////////////////////////////////////////\n * Classes\n */\n\npublic class ExeModuleException\n    : Exception\n{\npublic:\n    this(string message)\n    {\n        super(\"Неудачное подключение к модулю:\"~message,__FILE__,__LINE__);\t\t\n    }\n\n    this(uint errcode)\n    {\n      version (Posix)\n      {\n\tchar[80] buf = void;\n\tsuper(std.string.toString(strerror_r(errcode, buf.ptr, buf.length)).dup);\n      }\n      else\n      {\n\tsuper(строшиб(errcode));\n\t  }\n    }\n}\n\n/// This class represents an executable image\npublic scope class ExeModule\n{\n/// \\name Construction\n/// @{\npublic:\n    /// Constructs from an existing image хэндл\n    this(HXModule hModule, boolean bTakeOwnership)\n    in\n    {\n        assert(null !is hModule);\n    }\n    body\n    {\n        if(bTakeOwnership)\n        {\n            m_hModule = hModule;\n        }\n        else\n        {\n\t    version (Windows)\n\t    {\n\t\tstring path = Path();\n\t\tm_hModule = cast(HXModule)LoadLibraryA(toStringz(path));\n\t\tif (m_hModule == null)\n\t\t    throw new ExeModuleException(GetLastError());\n\t    }\n\t    else version (Posix)\n\t    {\n\t\tm_hModule = ExeModule_AddRef(hModule);\n\t    }\n\t    else\n\t\tstatic assert(0);\n        }\n    }\n\n    this(string moduleName)\n    in\n    {\n        assert(null !is moduleName);\n    }\n    body\n    {\n\tversion (Windows)\n\t{\n\t    m_hModule = cast(HXModule)LoadLibraryA(toStringz(moduleName));\n\t    if (null is m_hModule)\n\t\tthrow new ExeModuleException(GetLastError());\n\t}\n\telse version (Posix)\n\t{\n\t    m_hModule = ExeModule_Load(moduleName);\n\t    if (null is m_hModule)\n\t\tthrow new ExeModuleException(ExeModule_Error());\n\t}\n\telse\n\t{\n\t    static assert(0);\t\t// unsupported system\n\t}\n    }\n    ~this()\n    {\n        close();\n    }\n/// @}\n\n/// \\name Operations\n/// @{\npublic:\n    /// Closes the library\n    ///\n    /// \\note This is available to close the module at any time. Repeated\n    /// calls do not результат in an error, and are simply ignored.\n    void close()\n    {\n        if(null !is m_hModule)\n        {\n\t    version (Windows)\n\t    {\n\t\tif(!FreeLibrary(cast(HModule_)m_hModule))\n\t\t    throw new ExeModuleException(GetLastError());\n\t    }\n\t    else version (Posix)\n\t    {\n\t\tExeModule_Release(m_hModule);\n\t    }\n\t    else\n\t\tstatic assert(0);\n        }\n    }\n/// @}\n\n/// \\name Accessors\n/// @{\npublic:\n    /** Retrieves the named symbol.\n     *\n     * \\return A pointer to the symbol. There is no null return - failure to retrieve the symbol\n     * results in an ExeModuleException exception being thrown.\n     */\n    void *getSymbol(in string symbolName)\n    {\n\tversion (Windows)\n\t{\n\t    void *symbol = GetProcAddress(cast(HModule_)m_hModule, toStringz(symbolName));\n\t    if(null is symbol)\n\t    {\n\t\tthrow new ExeModuleException(GetLastError());\n\t    }\n\t}\n\telse version (Posix)\n\t{\n\t    void *symbol = ExeModule_GetSymbol(m_hModule, symbolName);\n\n\t    if(null is symbol)\n\t    {\n\t\tthrow new ExeModuleException(ExeModule_Error());\n\t    }\n\t}\n\telse\n\t{\n\t    static assert(0);\n\t}\n\n        return symbol;\n    }\n\n    /** Retrieves the named symbol.\n     *\n     * \\return A pointer to the symbol, or null if it does not exist\n     */\n    void *findSymbol(in string symbolName)\n    {\n        return ExeModule_GetSymbol(m_hModule, symbolName);\n    }\n\n/// @}\n\n/// \\name Properties\n/// @{\npublic:\n    /// The хэндл of the module\n    ///\n    /// \\note Will be \\c null if the module load in the constructor failed\n    HXModule Дескр()\n    {\n        return m_hModule;\n    }\n    /// The хэндл of the module\n    ///\n    /// \\note Will be \\c null if the module load in the constructor failed\n    string Path()\n    {\n        assert(null != m_hModule);\n\n\tversion (Windows)\n\t{\n\t    char szFileName[260]; // Need to use a constant here\n\n\t    // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getmodulefilename.asp\n\t    uint cch = GetModuleFileNameA(cast(HModule_)m_hModule, szFileName.ptr, szFileName.length);\n\t    if (cch == 0)\n\t\tthrow new ExeModuleException(GetLastError());\n\n\t    return szFileName[0 .. cch].dup;\n\t}\n\telse version (Posix)\n\t{\n\t    return ExeModule_GetPath_(m_hModule);\n\t}\n\telse\n\t    static assert(0);\n    }\n/// @}\n\nprivate:\n    HXModule m_hModule;\n};\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\nversion(TestMain)\n{\n    int main(string[] args)\n    {\n        if(args.length < 3)\n        {\n            эхо(\"USAGE: <moduleName> <symbolName>\\n\");\n        }\n        else\n        {\n            string  moduleName  =   args[1];\n            string  symbolName  =   args[2];\n\n            try\n            {\n                auto ExeModule xmod =   new ExeModule(moduleName);\n\n                эхо(\"\\\"%.*s\\\" is loaded\\n\", moduleName);\n\n                void    *symbol =   xmod.getSymbol(symbolName);\n\n                if(null == symbol)\n                {\n                    throw new ExeModuleException(ExeModule_Error());\n                }\n                else\n                {\n                    эхо(\"\\\"%.*s\\\" is acquired\\n\", symbolName);\n                }\n            }\n            catch(ExeModuleException x)\n            {\n                x.print();\n            }\n        }\n\n        return 0;\n    }\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n",
			"file": "std/loader.d",
			"file_size": 16743,
			"file_write_time": 131266929178891263,
			"settings":
			{
				"buffer_size": 14867,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "// Written in the D programming language\n\n/**\n * Macros:\n *\tWIKI = Phobos/StdRandom\n */\n\n// random.d\n// www.digitalmars.com\n\nmodule std.random;\nimport std.io, cidrus: exit;\n// Segments of the code in this file Copyright (c) 1997 by Rick Booth\n// From \"Inner Loops\" by Rick Booth, Addison-Wesley\n\nversion (Win32)\n{\n    extern (Windows) int QueryPerformanceCounter(ulong *count);\n}\n\nversion (Posix)\n{\n    private import os.posix;\n}\n\n/* ===================== Random ========================= */\n\n// BUG: not multithreaded\n\nprivate uint seed;\t\t// starting seed\nprivate uint index;\t\t// ith random number\nalias seed семя;\nalias index индекс;\n/**\n * The random number generator is seeded at program startup with a random value.\n *This ensures that each program generates a different sequence of random\n* numbers. To generate a repeatable sequence, use rand_seed() to start the\n* sequence. seed and index start it, and each successive value increments index.\n* This means that the $(I n)th random number of the sequence can be directly\n* generated\n* by passing index + $(I n) to rand_seed().\n*\n* Note: This is more random, but slower, than C's rand() function.\n* To use C's rand() instead, import cidrus.\n */\nпроц случсей(бцел семя, бцел индекс)\n{\nrand_seed(cast(uint) семя, cast(uint) индекс);\n}\n\nvoid rand_seed(uint seed, uint index)\n{\n     .seed = seed;\n     .index = index;\n}\n\n/**\n * Get the следщ random number in sequence.\n * BUGS: shares a global single состояние, not multithreaded\n */\nбцел случайно()\n{\nreturn cast(бцел) rand();\n}\n\nuint rand()\n{\n    static uint xormix1[20] =\n    [\n                0xbaa96887, 0x1e17d32c, 0x03bcdc3c, 0x0f33d1b2,\n                0x76a6491d, 0xc570d85d, 0xe382b1e3, 0x78db4362,\n                0x7439a9d4, 0x9cea8ac5, 0x89537c5c, 0x2588f55d,\n                0x415b5e1d, 0x216e3d95, 0x85c662e7, 0x5e8ab368,\n                0x3ea5cc8c, 0xd26a0f74, 0xf3a9222b, 0x48aad7e4\n    ];\n\n    static uint xormix2[20] =\n    [\n                0x4b0f3b58, 0xe874f0c3, 0x6955c5a6, 0x55a7ca46,\n                0x4d9a9d86, 0xfe28a195, 0xb1ca7865, 0x6b235751,\n                0x9a997a61, 0xaa6e95c8, 0xaaa98ee1, 0x5af9154c,\n                0xfc8e2263, 0x390f5e8c, 0x58ffd802, 0xac0a5eba,\n                0xac4874f6, 0xa9df0913, 0x86be4c74, 0xed2c123b\n    ];\n\n    uint hiword, loword, hihold, temp, itmpl, itmph, i;\n\n    loword = seed;\n    hiword = index++;\n    for (i = 0; i < 4; i++)\t\t// loop limit can be 2..20, we choose 4\n    {\n        hihold  = hiword;                           // save hiword for later\n        temp    = hihold ^  xormix1[i];             // mix up bits of hiword\n        itmpl   = temp   &  0xffff;                 // decompose to hi & lo\n        itmph   = temp   >> 16;                     // 16-bit words\n        temp    = itmpl * itmpl + ~(itmph * itmph); // do a multiplicative mix\n        temp    = (temp >> 16) | (temp << 16);      // swap hi and lo halves\n        hiword  = loword ^ ((temp ^ xormix2[i]) + itmpl * itmph); //loword mix\n        loword  = hihold;                           // old hiword is loword\n    }\n    return hiword;\n}\n\nбцел случген(бцел семя, бцел индекс, реал члоциклов)\n{\nreturn cast(бцел) randomGen(cast(uint) семя, cast(uint) индекс, cast(uint) члоциклов);\n}\n\nuint randomGen(uint seed, uint index, real ncycles)\n\t{\n\treal i;\n\tuint rn;\n\t\n    uint seedsave = seed;\n    uint indexsave = index;\n\t\n\t\n     rand_seed(seed, index);\n\t try\n\t{\n    for (i = 0; i < ncycles; i++)\n\t\t{\t\n\t\trn = rand();\n\t\tэхо(\"0x%x \", rn);\t\n\t\t}\n\t\tseed = seedsave;\n\t\tindex = indexsave;\n\t}\n\tcatch(Exception e)\n\t\t{\n\t\tsay(\" Произошло исключение:\"); e.print();\n\t\texit(1);\n\t\t}\n\t\t\n\t\treturn rn;\n\t}\n\t\nstatic this()\n{\n    ulong s;\n\n    version(Win32)\n    {\n\tQueryPerformanceCounter(&s);\n    }\n    version(Posix)\n    {\n\t// time.h\n\t// sys/time.h\n\n\ttimeval tv;\n\n\tif (gettimeofday(&tv, null))\n\t{   // Some error happened - try time() instead\n\t    s = time(null);\n\t}\n\telse\n\t{\n\t    s = cast(ulong)((cast(long)tv.tv_sec << 32) + tv.tv_usec);\n\t}\n    }\n    rand_seed(cast(uint) s, cast(uint)(s >> 32));\n}\n\n\nunittest\n{\n    static uint results[10] =\n    [\n\t0x8c0188cb,\n\t0xb161200c,\n\t0xfc904ac5,\n\t0x2702e049,\n\t0x9705a923,\n\t0x1c139d89,\n\t0x346b6d1f,\n\t0xf8c33e32,\n\t0xdb9fef76,\n\t0xa97fcb3f\n    ];\n    int i;\n    uint seedsave = seed;\n    uint indexsave = index;\n\n    rand_seed(1234, 5678);\n    for (i = 0; i < 10; i++)\n    {\tuint r = rand();\n\t//эхо(\"0x%x,\\n\", rand());\n\tassert(r == results[i]);\n    }\n\n    seed = seedsave;\n    index = indexsave;\n}\n",
			"file": "std/random.d",
			"file_size": 4813,
			"file_write_time": 130318806149062500,
			"settings":
			{
				"buffer_size": 4456,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Windows"
			}
		},
		{
			"file": "std/uri.d",
			"settings":
			{
				"buffer_size": 10058,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Unix"
			}
		},
		{
			"file": "dll.d",
			"settings":
			{
				"buffer_size": 3537,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/dinrus/dev/DINRUS/Base/basedll"
	],
	"file_history":
	[
		"/D/dinrus/dev/DINRUS/Base/base/sys/DStructs.d",
		"/D/dinrus/dev/DINRUS/Base/base/sys/DConsts.d",
		"/D/dinrus/dev/DINRUS/Base/clean.d",
		"/D/dinrus/dev/DINRUS/Base/base/runtime.d",
		"/D/Новая папка/sublime.py"
	],
	"find":
	{
		"height": 23.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"fgetwc",
			"getwchar",
			"сим*",
			"elSize",
			"newlength",
			"weakpointerCreate",
			"oldb",
			"allocdim"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"char*",
			"размЭлта",
			"новДлина",
			"создайСлабУк",
			"старб",
			"размпам"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 6,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "gc.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 117425,
						"regions":
						{
						},
						"selection":
						[
							[
								110774,
								110787
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 60750.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "cidrus.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 74712,
						"regions":
						{
						},
						"selection":
						[
							[
								64617,
								64617
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 31681.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "runtime.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35481,
						"regions":
						{
						},
						"selection":
						[
							[
								14919,
								14919
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 21886.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "stdrus.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 236731,
						"regions":
						{
						},
						"selection":
						[
							[
								51835,
								51835
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 34695.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "std/loader.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14867,
						"regions":
						{
						},
						"selection":
						[
							[
								14724,
								14723
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8055.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "std/random.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4456,
						"regions":
						{
						},
						"selection":
						[
							[
								1083,
								1083
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2250.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "std/uri.d",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 10058,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 6631.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "dll.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3537,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "BaseDll.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 178.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
