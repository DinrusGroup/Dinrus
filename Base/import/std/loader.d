module std.loader;

extern(D):
    

	цел иницМодуль();
	проц деиницМодуль();
	ук загрузиМодуль(in ткст имямод);
	ук добавьСсылНаМодуль(ук умодуль);
	проц отпустиМодуль(inout ук умодуль);
	ук дайСимволИМодуля(inout ук умодуль, in ткст имяСимвола);
	ткст ошибкаИМодуля();

	alias иницМодуль ExeModule_Init;
	alias деиницМодуль ExeModule_Uninit;
	alias загрузиМодуль ExeModule_Load;
	alias добавьСсылНаМодуль ExeModule_AddRef;
	alias отпустиМодуль ExeModule_Release;
	alias дайСимволИМодуля ExeModule_GetSymbol;
	alias ошибкаИМодуля ExeModule_Error;



	//Загрузчик от Derelict'а	........................................



ткст дайТкстОшибки();


 class Биб
{

    ткст имя();
  this(ук укз, ткст имя);
}


 Биб загрузиБиб(ткст имяб);
 Биб загрузиБиб(ткст[] именаб);
 проц выгрузиБиб(Биб биб);
 ук дайПроцИзБиб(Биб биб, ткст имяПроц);


 struct ЖанБибгр
  {


   проц заряжай(ткст винБибы, проц function(Биб) пользовательскийЗагр, ткст текстВерсии = "") ;
    проц загружай(ткст текстНазвБиб = null);
    проц загружай(ткст[] назвыБиб);
    ткст строкаВерсии();
    проц выгружай();
    бул загружено();
    ткст имяБиб();

}


 struct ЗавЖанБибгр {


    проц заряжай(ЖанБибгр* зависимость,  проц function(Биб) пользовательскийЗагр);
    проц загружай();
    ткст строкаВерсии();
    проц выгружай();
    бул загружено();
    ткст имяБиб();
}

struct Вяз(T) {
    проц opCall(ткст n, Биб lib) {
        *fptr = дайПроцИзБиб(lib, n);
    }
        ук* fptr;
}


template вяжи(T) {
    Вяз!(T) вяжи(inout T a) {
        Вяз!(T) рез;
        рез.fptr = cast(ук*)&a;
        return рез;
    }
}


 