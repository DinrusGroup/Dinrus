/**
 * Authors: The D DBI project
 * Copyright: BSD license
 */

module dbi.mysql.MysqlDatabase;

private import dbi.model.Database,dbi.mysql.imp, lib.mysql,
               dbi.model.Result,
               dbi.model.Constants;

private import dbi.DBIException,
               dbi.AbstractDatabase,
               dbi.ValidityToken;

private import dbi.mysql.MysqlError,
               dbi.mysql.MysqlResult,
               dbi.mysql.MysqlStatement;

private import lib.mysql;

private import util.log.Log,
               util.log.Config;
private import core.Variant;
private import Integer = text.convert.Integer;
private import text.convert.Format;

private import stringz;

class МайЭсКюЭлБД : БДсПротекциейДоступа, ПоддержкаМультиРезультата
{

private:

    Логгер лог;
    static бул[ВозможностьДби] _поддерживаемыеВозможности;
    бул[ВозможностьДби] _имеющиесяВозможности;

    ТокенВалидности токен;
    ТокеноДерж токеноДерж;

    static this()
    {
        _поддерживаемыеВозможности[ВозможностьДби.МультиИнструкции] = да;
        _поддерживаемыеВозможности[ВозможностьДби.МультиРезультаты] = да;
    }

package:
    MYSQL* подключение = пусто;

public:

    this ()
    {
        лог = Журнал.отыщи(this.classinfo.вТкст);
        токен = new ТокенВалидности();
        токеноДерж = new ТокеноДерж(токен);
        подключение = mysql_init(пусто);
		if (подключение is пусто)
			throw new ИсклДБИ("Не удалось подключение к MYSQL");
    }

    this (ткст имя, ткст пользователь = пусто, 
          ткст пароль = пусто,
          ткст[ткст] парамы = пусто,
          ВозможностьДби[] возможности = пусто)
    {
        this();
        подключись(имя, пользователь, пароль, парамы, возможности);
    }

    ~this()
    {
        закрой;
    }   

    проц подключись (ткст имя, 
                  ткст[ткст] парамы = пусто, 
                  ВозможностьДби[] возможности = пусто)
    {
        подключись(имя, пусто, пусто, парамы, возможности);
    }
 
    проц подключись (ткст имя, ткст пользователь = пусто, 
                  ткст пароль = пусто,
                  ткст[ткст] парамы = пусто, 
                  ВозможностьДби[] возможности = пусто)
    {
		scope (failure)
			подключение = пусто;
        if (возможности !is пусто) {
            foreach (ВозможностьДби возможность; возможности) {
                включи(возможность);
            }
        }

        бцел флаг_клиента = 0;
		auto мультиИнструкции = ВозможностьДби.МультиИнструкции in _имеющиесяВозможности;
		auto мультиРезультаты = ВозможностьДби.МультиРезультаты in _имеющиесяВозможности;
        if (мультиИнструкции && *мультиИнструкции) {
            флаг_клиента |= (1 << 16)/*CLIENT_MULTI_STATEMENTS*/;
        }
        else if (мультиРезультаты && *мультиРезультаты) {
            флаг_клиента |= (1 << 17)/*CLIENT_MULTI_RESULTS*/;
        }
        
        ткст host = "localhost";
        ткст sock = пусто;
        бцел порт = 0;

		if ( подключение is пусто )
			throw new ИсклДБИ ("Данное подключение к базе данных было закрыто.");

        if ("host" in парамы) 
			host = парамы["host"];
		if ("sock" in парамы) 
			sock = парамы["sock"];
		if ("port" in парамы)
            порт = cast(бцел)Integer.разбор(парамы["port"]);

        // TODO: проверь docs - проверь for пусто?
        mysql_real_connect(подключение, вТкст0(host), вТкст0(пользователь), 
                           вТкст0(пароль), вТкст0(имя), порт, 
                           вТкст0(sock), флаг_клиента);
		проверь("Невозможно подключиться к базе данных MySQL");
    }

    бул естьВозможность(ВозможностьДби возможность)
    {
        if (возможность in _поддерживаемыеВозможности)
            return _поддерживаемыеВозможности[возможность];

        return false;
    }

    бул включен(ВозможностьДби возможность)
    {
        if (возможность in _имеющиесяВозможности)
            return _имеющиесяВозможности[возможность];

        return false;
    }

    проц включи(ВозможностьДби возможность)
    {
         if ((возможность in _поддерживаемыеВозможности &&
             _поддерживаемыеВозможности[возможность])) {
                 _имеющиесяВозможности[возможность] = да;
         }
         else {
             throw new ИсклДБИ("Свойство не поддерживается: ", возможность);
         }
    }

    проц отключи(ВозможностьДби возможность)
    {
        _имеющиесяВозможности[возможность] = false;
    }

    проц закрой()
    {		
        if (подключение !is пусто) {
			mysql_close(подключение);
			проверь("Не удаётся закрыть базу данных MySQL");
			подключение = пусто;
		}

        if (токен !is пусто) {
            delete токен;
            токен = пусто;
        }
    }

    ткст искейп(in ткст инстр, ткст приёмн = пусто)
    {
        if (приёмн is пусто) {
            приёмн = new char[2*инстр.length+1];
        }
        бдол r = mysql_real_escape_string(подключение, приёмн.ptr, инстр.ptr, инстр.length);
        return приёмн[0..r];
    }

    проц выполни(in ткст эскюэл)
    {
   		if (цел ошибка = mysql_real_query(подключение, эскюэл.ptr, эскюэл.length)) {
			краш("Не удаётся выполнить команду к базе данных MySQL", эскюэл);
		}
    }

    РезультатМайЭсКюЭл запрос(in ткст эскюэл)
    {
        выполни(эскюэл);
        auto результаты = mysql_store_result(подключение);

        if (результаты is пусто) {
			краш("Не удаётся запрос к базе данных MySQL");
        }

        return new РезультатМайЭсКюЭл(результаты, подключение, токеноДерж);
    }

    ИнструкцияМайЭсКюЭл подготовь(in ткст эскюэл)
    {
        // TODO: подготовьd запрос syntax standardized? Will a dbms agnostic
        // frontend need to adjust it?
		auto инстр = mysql_stmt_init(подключение);
		auto результаты = mysql_stmt_prepare(инстр, эскюэл.ptr, эскюэл.length);
		if(результаты != 0) {
			инструкцияКраша(инстр, "Не удаётся подготовить инструкцию", эскюэл);
		}
		return new ИнструкцияМайЭсКюЭл(инстр, подключение);
    }

    ТаблицыМайЭсКюЭл таблицы(in ткст фильтр = пусто)
    {
        auto результаты = mysql_list_tables(подключение, вТкст0(фильтр)); 
   	    if(!результаты) {
			краш("Запрос к таблице MySQL вернул ответ \"пусто\"");
		}
    
        return new ТаблицыМайЭсКюЭл(this, new РезультатМайЭсКюЭл(результаты, подключение, 
                                                     токеноДерж));
    }

    override бул естьТаблица(ткст имя)
    {
   	    auto результаты = mysql_list_tables(подключение, вТкст0(имя));
	    if(!результаты) {
			краш("Запрос к таблице MySQL вернул ответ \"пусто\"");
		}
		бул есть = mysql_num_rows(результаты) > 0;
		mysql_free_result(результаты);
		return есть;
    }

    override бдол идПоследнейВставки()
    {
        return mysql_insert_id(подключение);
    }

    override бдол задействованныеРяды()
    {
        return mysql_affected_rows(подключение);
    }

    override проц стартТранзакции()
    {
   		const ткст эскюэл = "START TRANSACTION;";
		mysql_real_query(подключение, эскюэл.ptr, эскюэл.length);
    }

    override проц откат()
    {
   	    mysql_rollback(подключение);
    }

    override проц коммит()
    {
        mysql_commit(подключение);
    }

	private проц проверь(ткст сообКраша, ткст эскюэл = "")
	{
		auto номош = mysql_errno(подключение);
		if (номош)
			краш(сообКраша, эскюэл, номош);
	}

	private проц краш(ткст сообКраша, ткст эскюэл = "", бцел номош = 0)
	{
		if (номош == 0) номош = mysql_errno(подключение);
		auto ошибка = mysql_error(подключение);
		if (ошибка)
			сообКраша ~= ": " ~ изТкст0(ошибка);
		throw new ИсклДБИ(сообКраша, номош, спецВОбщ(номош), эскюэл);
	}
}

private проц инструкцияКраша(MYSQL_STMT* инстр, ткст сообКраша, ткст эскюэл = "", бцел номош = 0)
{
	if (номош == 0) номош = mysql_stmt_errno(инстр);
	auto ошибка = mysql_stmt_error(инстр);
	if (ошибка)
		сообКраша ~= ": " ~ изТкст0(ошибка);
	throw new ИсклДБИ(сообКраша, номош, спецВОбщ(номош), эскюэл);
}

class ТаблицыМайЭсКюЭл : Таблицы
{
private:

    РядыМайЭсКюЭл _ряды;
    МайЭсКюЭлБД _дбаза;

public:

    this (МайЭсКюЭлБД дбаза, РезультатМайЭсКюЭл результаты)
    {
        _ряды = new РядыМайЭсКюЭл(результаты);
        _дбаза = дбаза;
    }

    цел opApply (цел delegate(inout Таблица) дг)
    {
        if (!_ряды.действителен)
            throw new ИсклДБИ("Подлежащий набор результатов более не действителен");

        цел  результат;
        MysqlТаблица таблица = new MysqlТаблица(_дбаза);
        foreach (Ряд рядТаблицы; _ряды) {    
            таблица.установи(рядТаблицы.текстПо(0));
            Таблица t = таблица;
            if ((результат = дг(t)) != 0)
                 break;
        } 
        return результат;
    }

    т_мера таблицы() { return _ряды.члоРядов; }
}

class MysqlТаблица : АбстрактнаяТаблица
{
private:

    МайЭсКюЭлБД _дбаза;

public:

    this(МайЭсКюЭлБД дбаза) 
    {
        _дбаза = дбаза;
    }

    this(МайЭсКюЭлБД дбаза, ткст имя)
    {
        this(дбаза);
        _имя = имя;
    }

    override ИнфОСтолбце[] метаданные()
    {
        char[96] буфЗапросаПоля;
        // TODO: look into using mysql_list_fields here
        auto запросПолей = Формат.sprint(буфЗапросаПоля, "SELECT * FROM {} LIMIT 1;", имя);
        буфЗапросаПоля[запросПолей.length] = 0;

        mysql_real_query(_дбаза.подключение, запросПолей.ptr, запросПолей.length);
        auto результаты = mysql_store_result(_дбаза.подключение);
        auto поля = mysql_fetch_fields(результаты);

        _метаданные = new ИнфОСтолбце[mysql_num_fields(результаты)];
        for (бдол i = 0; i < mysql_num_fields(результаты); i++) {
            изПоляМайЭсКюЭл(_метаданные[i], поля[i]);
        }

        mysql_free_result(результаты);

        return _метаданные;
    }

    ИнфОСтолбце метаданные(т_мера инд)
    in {
        if (_метаданные !is пусто)
            assert (инд > 0 && инд < _метаданные.length);
    }
    body {
        if (_метаданные is пусто)
            метаданные();
        return _метаданные[инд];
    }

    бдол члоПолей() 
    { 
        if (_метаданные is пусто)
            метаданные();
        return _метаданные.length;
    }

    бдол члоРядов() { 
        return _члоРядов; 
    }

    РядыМайЭсКюЭл ряды()
    {
        char[96] буфЗапросаРядов;
        auto запросРядов = Формат.sprint(буфЗапросаРядов, "SELECT * FROM {};", имя);
        буфЗапросаРядов[запросРядов.length] = 0;

        mysql_real_query(_дбаза.подключение, запросРядов.ptr, запросРядов.length); 
        auto результаты = mysql_store_result(_дбаза.подключение);

        _члоРядов = mysql_num_rows(результаты);
        if (результаты is пусто) {
            throw new ИсклДБИ("Запрос рядов из базы данных MySQL не удался.");
        }

        return (new РезультатМайЭсКюЭл(результаты, _дбаза.подключение, _дбаза.токеноДерж)).ряды;
    }

    ткст вТкст() { return имя; }
}

