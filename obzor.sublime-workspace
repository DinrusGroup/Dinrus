{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "module stdrus;\n\nprivate import sys.WinStructs, sys.WinConsts,sys.WinFuncs;\nprivate import tpl.args, tpl.stream;\nimport cidrus, global;\npublic import exception;\n\n\nextern (D) struct Процессор\n{\n\tткст производитель();\n\tткст название()\t\t;\n\tбул поддержкаММЭкс()\t;\n\tбул поддержкаФЭксСР()\t;\n\tбул поддержкаССЕ()\t\t;\n\tбул поддержкаССЕ2()\t\t;\n\tбул поддержкаССЕ3()\t\t;\n\tбул поддержкаСССЕ3()\t;\n\tбул поддержкаАМД3ДНау()\t;\n\tбул поддержкаАМД3ДНауЭкст();\n\tбул поддержкаАМДММЭкс()\t;\n\tбул являетсяИА64()\t\t;\n\tбул являетсяАМД64()\t\t;\n\tбул поддержкаГиперПоточности();\n\tбцел потоковНаЦПБ()\t\t;\n\tбцел ядерНаЦПБ()\t\t;\n\tбул являетсяИнтел()\t\t;\n\tбул являетсяАМД()\t\t;\n\tбцел поколение()\t\t;\n\tбцел модель()\t\t\t;\n\tбцел семейство()\t\t;\n\tткст вТкст()\t\t\t;\n}\n\n//////////////////////////////////\n\nбул число_ли(ИнфОТипе[] _arguments, спис_ва _argptr)\n{\n    ткст  s  = \"\";\n    шткст ws = \"\";\n    юткст ds = \"\";\n\n    \n    if (_arguments.length == 0)\n        return нет;\n\n    if (_arguments[0] == typeid(ткст))\n        return чис_ли(ва_арг!(ткст)(_argptr));\n    else if (_arguments[0] == typeid(шткст))\n        return чис_ли(вЮ8(ва_арг!(шткст)(_argptr)));\n    else if (_arguments[0] == typeid(юткст))\n        return чис_ли(вЮ8(ва_арг!(юткст)(_argptr)));\n    else if (_arguments[0] == typeid(реал))\n        return да;\n    else if (_arguments[0] == typeid(дво)) \n        return да;   \n    else if (_arguments[0] == typeid(плав)) \n        return да;  \n    else if (_arguments[0] == typeid(бдол)) \n        return да; \n    else if (_arguments[0] == typeid(дол)) \n        return да;   \n    else if (_arguments[0] == typeid(бцел)) \n        return да;  \n    else if (_arguments[0] == typeid(цел)) \n        return да;   \n    else if (_arguments[0] == typeid(бкрат)) \n        return да;   \n    else if (_arguments[0] == typeid(крат)) \n        return да;   \n    else if (_arguments[0] == typeid(ббайт)) \n    {\n       s.length = 1;\n       s[0]= ва_арг!(ббайт)(_argptr);\n       return чис_ли(cast(ткст)s);\n    }\n    else if (_arguments[0] == typeid(байт)) \n    {\n       s.length = 1;\n       s[0] = ва_арг!(сим)(_argptr);\n       return чис_ли(cast(ткст)s);\n    }\n    else if (_arguments[0] == typeid(вреал))\n        return да;\n    else if (_arguments[0] == typeid(вдво)) \n        return да;   \n    else if (_arguments[0] == typeid(вплав)) \n        return да;  \n    else if (_arguments[0] == typeid(креал))\n        return да;\n    else if (_arguments[0] == typeid(кдво)) \n        return да;   \n    else if (_arguments[0] == typeid(кплав)) \n        return да;  \n    else if (_arguments[0] == typeid(сим))\n    {\n        s.length = 1;\n        s[0] = ва_арг!(сим)(_argptr);\n        return чис_ли(s);\n    }\n    else if (_arguments[0] == typeid(шим))\n    {\n        ws.length = 1;\n        ws[0] = ва_арг!(шим)(_argptr);\n        return чис_ли(вЮ8(ws));\n    }\n    else if (_arguments[0] == typeid(дим))\n    { \n        ds.length =  1;\n        ds[0] = ва_арг!(дим)(_argptr);\n        return чис_ли(вЮ8(ds));\n    }    \n    else       \t\t\n       return нет; \t   \n} \n\nбул число_ли(...){ return cast(бул) число_ли(_arguments, _argptr);}\n\n\n/*********************************\n * Возвращает !=0, если x нормализован (не равен 0, не субнормален, не бесконечен, не $(NAN)).\n */\n\n/* Need one for each format because подстnormal floats might\n * be converted to normal reals.\n */\n\nцел нормален_ли(X)(X x)\n{\n    alias плавТрэтс!(X) П;\n\n    static if(real.mant_dig==106) { // doubledouble\n        // doubledouble is normal if the least significant part is normal.\n        return нормален_ли((cast(дво*)&x)[МАНТИССА_МЗЧ]);\n    } else {\n        // ridiculous DMD warning\n        бкрат e = cast(бкрат)(П.МАСКАВЫР & (cast(бкрат *)&x)[П.ПОЗВЫР_КРАТ]);\n        return (e != П.МАСКАВЫР && e!=0);\n    }\n}\n////////////////////////////////////////////////////////////////////\n\nstruct т_регсвер\n{\n    цел рснач;\t\t\t\n    цел рскон;\t\t\t\n}\n\n//////////////////////////////////////////////\nextern (D)\n{\n\n\tбул вОбразце(дим с, ткст образец);\n\tбул вОбразце(дим с, ткст[] образец);\n\t\n\tткст вТкст(сим с);\n\tткст вТкст(бул с);\n\tткст вТкст(ббайт с);\n\tткст вТкст(бкрат с);\n\tткст вТкст(бцел с);\n\tткст вТкст(бдол с);\n\tткст вТкст(байт с);\n\tткст вТкст(крат с);\n\tткст вТкст(цел с);\n\tткст вТкст(дол с);\n\tткст вТкст(плав с);\n\tткст вТкст(дво с);\n\tткст вТкст(реал с);\n\tткст вТкст(вплав с);\n\tткст вТкст(вдво с);\n\tткст вТкст(вреал с);\n\tткст вТкст(кплав с);\n\tткст вТкст(кдво с);\n\tткст вТкст(креал с);\n\tткст вТкст(дол знач, бцел корень);\n\tткст вТкст(бдол знач, бцел корень);\n\tткст вТкст(сим *с);\n\t\n\tИнфОТипе простаяИнфОТипе(ПМангл m);\n\tБиб загрузиБиб(ткст имяб);\n\tБиб загрузиБиб(ткст[] именаб);\n\tпроц выгрузиБиб(Биб биб);\n\tук дайПроцИзБиб(Биб биб, ткст имяПроц);\n\tткст дайТкстОшибки();\n\tцел генМакетИмпорта(ткст имяМ, ткст[] список);\n\tбул создайЛистинг(ткст имяБ);\n\tбул создайБибИзДлл(ткст имяБ, ткст имяД = пусто, ткст путь = пусто, ткст расшД = \"dll\");\n}\n\nextern (D) class Биб\n{\n    ткст имя();\n  this(ук укз, ткст имя);\n}\n\n\nextern (D) struct ЖанБибгр {\n\n   проц заряжай(ткст winLibs, проц function(Биб) userLoad, ткст versionStr = \"\");\n    проц загружай(ткст libNameString = пусто);\n    проц загружай(ткст[] libNames);\n\t\n\talias загружай иниц, init;\n\t\n    ткст строкаВерсии();\n    проц выгружай();\n    бул загружено();\n    ткст имяБиб();\n    static ~this();\n}\n//Зависимый Жанровый Загрузчик Библиотек\nextern (D) struct ЗавЖанБибгр {\n\n    проц заряжай(ЖанБибгр* dependence, проц function(Биб) userLoad);\n    проц загружай();\n    ткст строкаВерсии();\n    проц выгружай();\n    бул загружено();\n    ткст имяБиб();\n}\n\nstruct Вяз(T) {\n    проц opCall(ткст n, Биб lib) {\n        *fptr = дайПроцИзБиб(lib, n);\n    }\n        ук* fptr;  \n}\n\n\ntemplate вяжи(T) {\n    Вяз!(T) вяжи(inout T a) {\n        Вяз!(T) рез;\n        рез.fptr = cast(ук*)&a;\n        return рез;\n    }\n}\n\n/////////////////////////////////////////////////////\nextern (D) struct ЧленАрхиваЗИП //ArchiveMember\n{\n\n    бкрат версияСборки = 20;\t\n    бкрат версияИзвлечения = 20;\t\n    бкрат флаги;\t\t\n    бкрат методСжатия;\t\n    ФВремяДос время;\t\n    бцел цпи32;\t\t\t\n    бцел сжатыйРазмер;\t\n    бцел расжатыйРазмер;\t\t\n    бкрат номерДиска;\t\t\n    бкрат внутренниеАтрибуты;\t\n    бцел внешниеАтрибуты;\t\n    private бцел смещение;\n    ткст имя;\n    ббайт[] экстра;\t\t\n    ткст комментарий;\t\t\n    ббайт[] сжатыеДанные;\t\n    ббайт[] расжатыеДанные;\t\n\n    проц выведи();\n    \n}\n\nextern (D) class АрхивЗИП\n{\n\n extern  (C) extern\n {\n    ббайт[] данные;\t\n    бцел смещКПоследнЗаписи;\n\n    бцел номерДиска;\t\n    бцел стартПапкаДиска;\t\n    бцел члоЗаписей;\t\n    бцел всегоЗаписей;\t\n    ткст комментарий;\n }\n \n    проц выведи();\n    this();\n    проц добавьЧлен(ЧленАрхиваЗИП de);\n    проц удалиЧлен(ЧленАрхиваЗИП de);\n    this(проц[] буфер);\n    ббайт[]расжать(ЧленАрхиваЗИП de);    \n}\n\nextern(D) class СжатиеЗлиб\n{\n\tenum\n\t{\n\t\tБЕЗ_СЛИВА      = 0,\n\t\tСИНХ_СЛИВ    = 2,\n\t\tПОЛН_СЛИВ    = 3,\n\t\tФИНИШ       = 4,\n\t}\n\n\tthis(цел ур);\n\tthis();\n\t~this();\n\tпроц[] сжать(проц[] буф);\n\tпроц[] слей(цел режим = ФИНИШ);\n}\n\nextern(D) class РасжатиеЗлиб\n{\n\t\n\tthis(бцел размБуфЦели);\n\tthis();\n\t~this();\n\tпроц[] расжать(проц[] буф);\n\tпроц[] слей();\n}\n\nextern(D) class РегВыр\n{\n     this(рсим[] образец, рсим[] атрибуты = пусто);\n    static РегВыр opCall(рсим[] образец, рсим[] атрибуты = пусто);\n     РегВыр ищи(рсим[] текст);   \n     цел opApply(цел delegate(inout РегВыр) дг);\n     ткст сверь(т_мера n);\n     ткст перед();\n\t ткст после();\n    бцел члоподстр;\t\t\n    т_регсвер[] псовп;\t\n    рсим[] ввод;\t\t\n    \n    рсим[] образец;\t\t\n    рсим[] флаги;\t\t\n    цел ошибки;\n    бцел атрибуты;\n\n    enum РВА\n    {\n\tглоб\t\t= 1,\t\n\tлюбрег\t= 2,\t\n\tмногострок\t= 4,\t\t\t\t\t\n\tтчксовплф\t= 8,\t\n    }\n\n проц компилируй(рсим[] образец, рсим[] атрибуты);\n рсим[][] разбей(рсим[] текст);\n цел найди(рсим[] текст);\n рсим[][] сверь(рсим[] текст);\n рсим[] замени(рсим[] текст, рсим[] формат);\n рсим[][] выполни(рсим[] текст);\n рсим[][] выполни();\n цел проверь(рсим[] текст);\n цел проверь();\n цел проверь(ткст текст, цел стартиндекс);\nцел чр(inout бцел ит, рсим c);\nпроц выведиПрограмму(ббайт[] прог);\nцел пробнсвер(цел pc, цел пценд);\nцел разборРегвыр();\nцел разборКуска();\nцел разборАтома();\nрсим[] замени(рсим[] формат);\nstatic рсим[] замени3(рсим[] формат, рсим[] ввод, т_регсвер[] псовп);\nрсим[] замениСтарый(рсим[] формат);\n~this();\n}\n\n\nextern(D) struct Дата\n\t{\n\t\n\tцел год = цел.min;\n    цел месяц;\n    цел день;\n    цел час;\n    цел минута;\t\n    цел секунда;\n    цел мс;\t\n    цел день_недели;\n    цел коррекцияЧП = цел.min;\t    \n\t\n    проц разбор(ткст т);\n}\n\n\t\nextern(D) struct ПапЗап\n\t{\t\n\tткст имя;\n    бдол размер = ~0UL;\n    т_время времяСоздания = т_время_нч;\n    т_время времяПоследнегоДоступа = т_время_нч;\t\n    т_время времяПоследнейЗаписи = т_время_нч;\n    бцел атрибуты;\n\n    проц иниц(ткст путь, ПОИСК_ДАННЫХ_А *дф);\n    проц иниц(ткст путь, ПОИСК_ДАННЫХ *дф);\n    бцел папка_ли();\n    бцел файл_ли();\n}\n\t\nextern(D) class БуферВывода\n{\nббайт данные[];\nбцел смещение;\n\ninvariant\n    {\n\tassert(смещение <= данные.length);\n\t\n    }\n\t\n\tthis();\t\n\t~this();\n\t\n\tббайт[] вБайты();\n\tпроц резервируй(бцел члобайт);\n    проц пиши(ббайт[] байты);\n    проц пиши(ббайт b);\n    проц пиши(байт b);\n    проц пиши(сим c);\n    проц пиши(бкрат w);\n    проц пиши(крат s);\n    проц пиши(шим c);\n    проц пиши(бцел w);\n    проц пиши(цел i);\n    проц пиши(бдол l);\n    проц пиши(дол l);\n    проц пиши(плав f);\n    проц пиши(дво f);\n    проц пиши(реал f);\n    проц пиши(ткст s);\n    проц пиши(БуферВывода буф);\n    проц занули(бцел члобайт);\n    проц расклад(бцел мера);\n    проц расклад2();\n    проц расклад4();\n    ткст вТкст();\n    проц ввыводф(ткст формат, спис_ва арги);\n    проц выводф(ткст формат, ...);\n    проц простели(бцел индекс, бцел члобайт);\n}\n\nextern(D) struct МассивБит\n{\n\nт_мера длин;\nбцел *ук;\n\n\t\n\tт_мера разм();\n\tт_мера длина();\n\tпроц длина(т_мера новдлин);\n  бул opIndex(т_мера i);\n  бул opIndexAssign(бул b, т_мера i);\n МассивБит дубль();\n цел opApply(цел delegate(inout бул) дг);\n    цел opApply(цел delegate(inout т_мера, inout бул) дг);\n\t МассивБит реверсни();\n\t МассивБит сортируй();\n    цел opEquals(МассивБит a2);\n    цел opCmp(МассивБит a2);\n\t проц иниц(бул[] бм);\n\t проц иниц(проц[] в, т_мера члобит);\n    проц[] opCast();\n    МассивБит opCom();\n    МассивБит opAnd(МассивБит e2);\n     МассивБит opOr(МассивБит e2);\n    МассивБит opXor(МассивБит e2);\n    МассивБит opSub(МассивБит e2);\n    МассивБит opAndAssign(МассивБит e2);\n    МассивБит opOrAssign(МассивБит e2);\n    МассивБит opXorAssign(МассивБит e2);\n    МассивБит opSubAssign(МассивБит e2);\n     МассивБит opCatAssign(бул b);\n    МассивБит opCatAssign(МассивБит b);\n    МассивБит opCat(бул b);\n    МассивБит opCat_r(бул b);\n    МассивБит opCat(МассивБит b);\t\n}\n\nextern(D) class Модуль\n{\n\n\tthis(ук модуль, бул овладеть);\n\tthis(ткст имяМодуля);\n\tпроц закрой();\n\tук дайСимвол(in ткст симв);\n\tук найдиСимвол(in ткст симв);\n\tук Ук();\n\tткст Путь();\n\t~this();\n}\n\n\n\n//Файл, Размещённый в Карте Памяти (MMFile)\nextern (D) class РПФайл\n{\nalias длина length;\n\n    enum Режим\n    {\n\tЧтение,\t\t/// read existing файл\n\tЧтенЗапНов,\t/// delete existing файл, write new файл\n\tЧтенЗап,\t/// read/write existing файл, create if not existing\n\tЧтенКопирПриЗап, /// read/write existing файл, copy on write\n\t\n    }\n\tstatic this(){};\n    this(ткст имяф);\n    \n\n    this(ткст имяф, Режим режим, бдол размер, ук адрес,\n\t\t\tт_мера окно = 0);\n\t~this();\n\tпроц слей();\n\tбдол длина();\n\tРежим режим();\n\tпроц[] opSlice();\n\tпроц[] opSlice(бдол i1, бдол i2);\n\tббайт opIndex(бдол i);\n\tббайт opIndexAssign(ббайт значue, бдол i);\n\n}\n\nextern (D) class Файл: Поток \n{\n\tstatic this(){};\n  this();\n  this(ук файлУк, ПФРежим режим);\n  this(ткст имяф, ПРежимФайла режим = cast(ПФРежим)1);\n  проц открой(ткст имяф, ПРежимФайла режим = cast(ПФРежим)1);\n  проц создай(ткст имяф);\n  проц создай(ткст имяф, ПРежимФайла режим);\n  override  проц закрой();\n  ~this();\n  override  бдол размер() ;\n  т_мера читайБлок(ук буфер, т_мера размер);\n  т_мера пишиБлок(ук буфер, т_мера размер);\n  бдол сместись(дол смещение, ППозКурсора rel);\n  override т_мера доступно();\n  ук хэндл();\n  \n }\n\nextern (D) class ФильтрПоток : Поток\n {\n\textern(C) extern\n\t{\n\t  Поток п;              // source stream\n\tбул закрытьГнездо;\n\t}\n\t\n  бул закрытьИсток();\n  проц закрытьИсток(бул б);\n\tstatic this(){};\n  this(Поток исток);\n   Поток исток();\n  проц исток(Поток s);\n  проц сбросьИсток() ;\n  т_мера читайБлок(ук буфер, т_мера размер);\n  т_мера пишиБлок(ук буфер, т_мера размер) ;\n  override проц закрой();\n  бдол сместись(дол смещение, ППозКурсора откуда) ;\n  override т_мера доступно ();\n  override проц слей() ;\n   ~this();\n}\n\nextern (D) class БуфПоток : ФильтрПоток \n{\nextern(C) extern\n{\n      ббайт[] буфер; \n\t  бцел текБуфПоз;  \n\t бцел длинаБуф; \n\t  бул черновойБуф;\n\t   бцел позИстокаБуф;  \n\t  бдол позПотока; \n }\t\n  \t\tstatic this(){};\n\tпроц устБуфер(ббайт[] буф);//setter\n\tббайт[] дайБуфер();\t//getter\n\t  \n \tпроц устТекБуфПоз(бцел тбп);\n\tбцел дайТекБуфПоз();\n\t  \n  \tпроц устДлинуБуф(бцел дб);\n\tбцел дайДлинуБуф();\n\t\n  \tпроц устЧерновой(бул чб);\n\tбул дайЧерновойБуф();\n\t\n \tпроц устПозИстокаБуф(бцел пиб);\n\t бцел дайПозИстокаБуф();\n\t  \n \tпроц устПозПотока(бдол пп);\n\tбдол дайПозПотока();\n\t\n \n  const бцел дефРазмБуфера = 8192;\n\n   this(Поток исток, бцел размБуф = дефРазмБуфера);\n   override проц сбросьИсток();\n   override т_мера читайБлок(ук результат, т_мера длин);\n   override т_мера пишиБлок(ук результат, т_мера длин) ;\n   override бдол сместись(дол смещение, ППозКурсора откуда);\n   override ткст читайСтр(ткст буфввода);\n   override шткст читайСтрШ(шткст буфввода) ;\n   override проц слей();\n   override бул кф();\n   override бдол размер() ;\n   override т_мера доступно() ;\n  ~this();\n}\n\nextern (D) class БуфФайл: БуфПоток {\n\n\tstatic this(){};\n  this();\n  this(ткст имяф, ПРежимФайла режим = cast(ПФРежим) 1,\n       бцел размБуф = дефРазмБуфера);\n  this(Файл файл, бцел размБуф = дефРазмБуфера);\n  this(ук  файлУк, ПРежимФайла режим, бцел размбуфа);\n  проц открой(ткст имяф, ПРежимФайла режим = cast(ПФРежим) 1);\n  проц создай(ткст имяф, ПРежимФайла режим = cast(ПФРежим) 6) ;\n  override  проц удали(ткст фимя);\n  override проц закрой();\n  \n  ~this();\n}\nextern(D) БуфФайл объБуфФайл();\n\n\nextern (D) class ПотокЭндианец : ФильтрПоток {\n\n  Эндиан эндиан;\n\tstatic this(){};\n  this(Поток исток, Эндиан end = _эндиан);\n  проц устЭндиан(Эндиан э);\n  проц выведиЭндиан();\n  цел читайМПБ(цел размВозврСим = 1);\n   проц фиксируйПБ(ук буфер, бцел размер);\n   проц фиксируйБлокПБ(ук буфер, бцел размер, т_мера повтор);\n   проц читай(out байт x) ;\n   проц читай(out ббайт x);\n  проц читай(out крат x);\n  проц читай(out бкрат x) ;\n  проц читай(out цел x) ;\n  проц читай(out бцел x) ;\n  проц читай(out дол x) ;\n  проц читай(out бдол x) ;\n  проц читай(out плав x) ;\n  проц читай(out дво x) ;\n  проц читай(out реал x) ;\n  проц читай(out вплав x) ;\n  проц читай(out вдво x) ;\n  проц читай(out вреал x) ;\n  проц читай(out кплав x) ;\n  проц читай(out кдво x) ;\n  проц читай(out креал x) ;\n  проц читай(out шим x) ;\n  проц читай(out дим x) ;\n  шим бериш();\n  шткст читайТкстШ(т_мера длина) ;\n  проц пишиМПБ(МПБ b);\n   проц пиши(байт x);\n   проц пиши(ббайт x);\n  проц пиши(крат x) ;\n  проц пиши(бкрат x) ;\n  проц пиши(цел x) ;\n  проц пиши(бцел x) ;\n  проц пиши(дол x) ;\n  проц пиши(бдол x) ;\n  проц пиши(плав x) ;\n  проц пиши(дво x) ;\n  проц пиши(реал x) ;\n  проц пиши(вплав x) ;\n  проц пиши(вдво x) ;\n  проц пиши(вреал x) ;\n  проц пиши(кплав x);\n  проц пиши(кдво x);\n  проц пиши(креал x);  \n  проц пиши(шим x) ;\n  проц пиши(дим x) ;\n  проц пишиТкстШ(шткст str);\n   бул кф();\n   бдол размер() ;\n   ~this();\n}\n\nextern (D) class ПотокПамяти : ТПотокМассив!(ббайт[])\n {\n\tstatic this(){};\n  this(ббайт[] буф = пусто) ;\n  this(байт[] буф);\n  this(ткст буф) ;\n  проц резервируй(т_мера count);\n  override т_мера пишиБлок(ук буфер, т_мера размер);\n  override т_мера читайБлок(ук буфер, т_мера размер);\n  override бдол сместись(дол смещение, ППозКурсора rel);\n   override т_мера доступно ();\n  override ббайт[] данные();\n  ткст вТкст();\n  ~this();\n\n}\n\nextern (D) class РПФайлПоток : ТПотокМассив!(РПФайл)\n {\n \tstatic this(){};\n  this(РПФайл файл) ;\n  override проц слей() ;\n override  проц закрой();\n override т_мера пишиБлок(ук буфер, т_мера размер);\n  override т_мера читайБлок(ук буфер, т_мера размер);\n override  бдол сместись(дол смещение, ППозКурсора rel);\n override  т_мера доступно ();\n override ббайт[] данные();\n override ткст вТкст();  \n  override проц удали(ткст фимя);\n  ~this();\n}\n \nextern (D) class ПотокСрез : ФильтрПоток\n {\nextern (C) extern\n{\n  бдол поз;  // our позиция relative to low\n  бдол низ; // низ stream смещение.\n  бдол верх; // верх stream смещение.\n  бул ограничен; // upper-ограничен by верх.\n\tПоток п;\n}\n\tstatic this(){};\n  this (Поток s, бдол нз);  \n  this (Поток s, бдол нз, бдол вх);\n  override т_мера читайБлок (проц *буфер, т_мера размер);\n  override т_мера пишиБлок (проц *буфер, т_мера размер) ;\n  override  бдол сместись(дол смещение, ППозКурсора rel) ;\n  override т_мера доступно () ;\n  ~this();\n}\n\nextern (D) class СФайл : Поток\n {\n extern  (C) extern\tфук файлси;\n \tstatic this(){};\n  this(фук файлси, ПРежимФайла режим, бул сканируемый = нет);\n  ~this();\n  фук файл();\n  проц файл(фук файлси);\n  override проц слей() ;\n  override проц закрой();\n  override бул кф() ;\n  override сим берис() ;\n  override сим отдайс(сим c);\n  override т_мера читайБлок(ук буфер, т_мера размер);\n  override т_мера пишиБлок(ук буфер, т_мера размер);\n  бдол сместись(дол смещение, ППозКурсора rel);\n  override проц пишиСтр(ткст s);\n  override проц пишиСтрШ(шткст s);\n}\n\nextern (D) class СокетПоток: Поток\n{\n\tstatic this(){};\n  \tthis(Сокет сок, ПРежимФайла режим);\n\tthis(Сокет сок);\n\tСокет сокет();\n\toverride т_мера читайБлок(ук _буфер, т_мера размер);\n\toverride т_мера пишиБлок(ук _буфер, т_мера размер);\n\tбдол сместись(дол смещение, ППозКурсора куда);\n\toverride ткст вТкст();\n\toverride проц закрой();\n}\n////////////////////////////////////////////////////\nextern (D) class СчётчикВысокойПроизводительности\n {  \n\talias   дол    т_интервал;\n\t//alias PerformanceCounterScope!(СчётчикВысокойПроизводительности)  scope_type;\n\tstatic this();\n\tпроц старт();\n\tпроц стоп();\n   \tт_интервал счётПериодов();\n\tт_интервал секунды();\n\tт_интервал миллисекунды();\n\tт_интервал микросекунды();\n }\n \nextern (D) class СчётчикТиков\n    {\n  \talias   дол    т_интервал;\n\t//alias PerformanceCounterScope!(СчётчикТиков) scope_type;\n  \tпроц старт();\n\tпроц стоп();  \n\tт_интервал счётПериодов();\n\tт_интервал секунды();\n\tт_интервал миллисекунды();\n\tт_интервал микросекунды();\n    }\n\nextern (D) class СчётчикВремениНити\n    {\n\talias   дол    т_интервал;\n\t//alias PerformanceCounterScope!(СчётчикВремениНити)  scope_type;\n  \n\tthis();\n\tпроц старт();\n\tпроц стоп();\n\tт_интервал счётПериодаЯдра();\n\tт_интервал секундыЯдра();\n\tт_интервал миллисекундыЯдра();\t\n\tт_интервал микросекундыЯдра();\n\tт_интервал счётПользовательскогоПериода();\n\tт_интервал секундыПользователя();\n\tт_интервал миллисекундыПользователя();\n\tт_интервал микросекундыПользователя();\n\tт_интервал счётПериодов()\t;\n\tт_интервал секунды();\n\tт_интервал миллисекунды()\t;\n\tт_интервал микросекунды()\t;  \n   \n    }\t\n\t\nextern (D) class СчётчикВремениПроцесса\n    {\n\talias   long    т_интервал;\n\t//alias PerformanceCounterScope!(СчётчикВремениПроцесса) scope_type;\n \tпроц старт();\n\tпроц стоп();\n\tт_интервал счётПериодаЯдра();\t\n\tт_интервал секундыЯдра();\n\tт_интервал миллисекундыЯдра();\n\tт_интервал микросекундыЯдра();\n\tт_интервал счётПользовательскогоПериода()\t;\n\tт_интервал секундыПользователя()\t;\n\tт_интервал миллисекундыПользователя()\t;\n\tт_интервал микросекундыПользователя();\n\tт_интервал счётПериодов()\t;\n\tт_интервал секунды();\n\tт_интервал миллисекунды()\t;\n\tт_интервал микросекунды();\n\tstatic this();\n  \n    }\n\t\nabstract class Адрес\n{\n\tprotected адрессок* имя();\n\tprotected цел длинаИм();\n\tПСемействоАдресов семействоАдресов();\t/// Family of this address.\n\tткст вТкст();\t\t/// Human readable string representing this address.\n}\n\nextern (D)  class Протокол\n{\n\tППротокол тип;\n\tткст имя;\n\tткст[] алиасы;\n\n\tпроц заполни(протзап* прото);\n\tбул дайПротоколПоИмени(ткст имя);\n\tбул дайПротоколПоТипу(ППротокол тип);\n}\n\nextern (D)  class Служба\n{\n\tткст имя;\n\tткст[] алиасы;\n\tбкрат порт;\n\tткст имяПротокола;\n\n\tпроц заполни(служзап* служба);\n\tбул дайСлужбуПоИмени(ткст имя, ткст имяПротокола);\n\tбул дайСлужбуПоИмени(ткст имя);\n\tбул дайСлужбуПоПорту(бкрат порт, ткст имяПротокола);\n\tбул дайСлужбуПоПорту(бкрат порт);\n}\n\nextern (D)  class ИнтернетХост\n{\n\tткст имя;\n\tткст[] алиасы;\n\tбцел[] списокАдр;\n\n\tпроц реальнаяХостзап(хостзап* хз);\n\tпроц заполни(хостзап* хз);\n\tбул дайХостПоИмени(ткст имя);\n\tбул дайХостПоАдр(бцел адр);\n\tбул дайХостПоАдр(ткст адр);\n}\n\nextern (D)  class НеизвестныйАдрес: Адрес\n{\nprotected:\n\toverride адрессок* имя();\n\toverride цел длинаИм();\n\t\n\tpublic:\n\toverride ПСемействоАдресов семействоАдресов();\n\toverride ткст вТкст();\n}\n\nextern (D)  class ИнтернетАдрес: Адрес\n{\n\tprotected:\n\tадрессок_ин иас;\n\toverride адрессок* имя();\n\toverride цел длинаИм();\n\tthis();\t\n\t\npublic:\n\tconst бцел АДР_ЛЮБОЙ = 0;//INADDR_ANY;\t/// Любое адресное число IPv4.\n\tconst бцел АДР_НЕУК = 0xFFFFFFFF;//INADDR_NONE;\t/// Любое неверное адресное число IPv4.\n\tconst бкрат ПОРТ_ЛЮБОЙ = 0;\t/// Любое число порта IPv4.\n\t\n\toverride ПСемействоАдресов семействоАдресов();\n\tбкрат порт();\t\n\tбцел адр();\t\n\tthis(ткст адр, бкрат порт);\n\tthis(бцел адр, бкрат порт);\n\tthis(бкрат порт);\n\tткст вАдрТкст();\n\tткст вПортТкст();\n\toverride ткст вТкст();\t\n\tstatic бцел разбор(ткст адр);\n}\n\n\nextern (D)  class НаборСокетов\n{\n\tthis(бцел макс);\n\tthis();\n\tпроц переуст();\n\tпроц прибавь(т_сокет с);\n\tпроц прибавь(Сокет с);\n\tпроц удали(т_сокет с);\n\tпроц удали(Сокет с);\n\tцел вНаборе(т_сокет с);\n\tцел вНаборе(Сокет с);\n\tбцел макс();\n\tнабор_уд* вНабор_уд();\n\tцел выберич();\n}\n\nextern (D)  class Сокет\n{\n\nthis(ПСемействоАдресов са, ПТипСок тип, ППротокол протокол);\nthis(ПСемействоАдресов са, ПТипСок тип);\nthis(ПСемействоАдресов са, ПТипСок тип, ткст имяПротокола);\n~this();\nт_сокет Ук();\nбул блокируемый();\nпроц блокируемый(бул б);\nПСемействоАдресов семействоАдресов() ;\nбул жив_ли() ;\nпроц свяжи(Адрес адр);\nпроц подключись(Адрес к);\nпроц слушай(цел backlog);\nСокет принимающий();\nСокет прими();\nпроц экстрзак(ПЭкстрЗакрытиеСокета how);\nпроц закрой();\nstatic ткст имяХоста() ;\nАдрес удалённыйАдрес();\nАдрес локальныйАдрес();\n\nconst цел ОШИБКА = -1;\n\nцел шли(проц[] буф, ПФлагиСокета флаги);\nцел шли(проц[] буф);\nцел шли_на(проц[] буф, ПФлагиСокета флаги, Адрес куда);\nцел шли_на(проц[] буф, Адрес куда);\nцел шли_на(проц[] буф, ПФлагиСокета флаги);\nцел шли_на(проц[] буф);\nцел получи(проц[] буф, ПФлагиСокета флаги);\nцел получи(проц[] буф);\nцел получи_от(проц[] буф, ПФлагиСокета флаги, out Адрес от);\nцел получи_от(проц[] буф, out Адрес от);\nцел получи_от(проц[] буф, ПФлагиСокета флаги);\nцел получи_от(проц[] буф);\nцел дайОпцию(ППротокол уровень, ПОпцияСокета опция, проц[] результат);\nцел дайОпцию(ППротокол уровень, ПОпцияСокета опция, out цел результат);\nцел дайОпцию(ППротокол уровень, ПОпцияСокета опция, out заминка результат);\nпроц установиОпцию(ППротокол уровень, ПОпцияСокета опция, проц[] значение);\nпроц установиОпцию(ППротокол уровень, ПОпцияСокета опция, цел значение);\nпроц установиОпцию(ППротокол уровень, ПОпцияСокета опция, заминка значение);\nstatic цел выбери(НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError, значврем* tv);\nstatic цел выбери(НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError, цел микросекунды);\nstatic цел выбери(НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError);\n}\n\nextern (D) class ПутСокет: Сокет\n{\n\tthis(ПСемействоАдресов семейство);\n\tthis();\n\tthis(Адрес подкл_к);\n}\n\nextern (D) class ПпдСокет: Сокет\n{\n\tthis(ПСемействоАдресов семейство);\n\tthis();\n}\n\nalias ук нук;\nalias бцел нид;\n\nextern (Windows) alias бцел (*stdfp)(ук);\n\nextern (C) нук начниНитьДоп(ук безоп, бцел размстека, stdfp стартадр, ук списаргов, бцел иницфлаг, нид* адрнити);\n\nextern (D) class Нить\n{\t\n    this(т_мера размстека = 0);  \n    this(цел (*fp)(ук), ук арг, т_мера размстека = 0);\n    this(цел delegate() дг, т_мера размстека = 0);\n    ~this();\n    \n    ук низСтэка;\n\n   проц старт();\t\t\n    цел пуск();\n    проц жди();\n    проц жди(бцел миллисек);\n\tбцел дайЧлоНитей();\n\t\n    enum СН\n    {\n\tНАЧАЛЬНОЕ,\t/// The thread hasn't been started yet.\n\tПУЩЕНА,\t/// The thread is running or paused.\n\tПРЕРВАНА,\t/// The thread has ended.\n        ЗАВЕРШЕНА        /// The thread has been cleaned up\n    }\n\n    СН дайСостояние();\n\n    enum ПРИОРИТЕТ\n    {\n\tУВЕЛИЧЬ,\t/// Increase thread priority\n\tУМЕНЬШИ,\t/// Decrease thread priority\n\tНИЗКИЙ,\t\t/// Assign thread low priority\n\tВЫСОКИЙ,\t/// Assign thread high priority\n\tНОРМАЛЬНЫЙ,\n    }\n\n    проц устПриор(ПРИОРИТЕТ p);\n    бул сама_ли();\n    static Нить дайЭту();\n    static Нить[] дайВсе();\n    проц пауза();\n    проц возобнови();\n    static проц паузаВсем();\n    static проц возобновиВсе();\n    static проц рви();\t\n  \n\t\n\textern (C) static бцел стартнити(ук p);\n\n\t\tpublic static проц пускНити();\t\t\t\n\t\t\n\t\tstatic ~this();\n\t\t\n\t\tstatic ук дайУкНаТекНить();\t\t\t\n\n}\n\n\n///////////////////////////////////////////////////////////////////////\n\t\nextern(D) struct ПерестановкаБайт\n{\n\n        /***********************************************************************\n\n                Реверсирует двубайтные цепочки. Параметр приёмн указывает \n                число байтов, которое должно быть кратно 2\n\n        ***********************************************************************/\n\n        final static проц своп16 (проц[] приёмн);\n        /***********************************************************************\n\n               Реверсирует четырёхбайтные цепочки. Параметр приёмн указывает  \n                число байтов, к-е д.б. кратно 4\n\n        ***********************************************************************/\n\n        final static проц своп32 (проц[] приёмн);\n\n        /***********************************************************************\n\n               Реверсирует 8-байтные цепочки. Параметр приёмн указывает  \n                число байтов, к-е д.б. кратно 8\n\n        ***********************************************************************/\n\n        final static проц своп64 (проц[] приёмн);\n\n        /***********************************************************************\n\n               Реверсирует 10-байтные цепочки. Параметр приёмн указывает  \n                число байтов, к-е д.б. кратно 10\n\n        ***********************************************************************/\n\n        final static проц своп80 (проц[] приёмн);\n\n        /***********************************************************************\n\n               Реверсирует 2-байтные цепочки. Параметр приёмн указывает  \n                число байтов, к-е д.б. кратно 2\n\n        ***********************************************************************/\n\n        final static проц своп16 (ук приёмн, бцел байты);\n\n        /***********************************************************************\n\n               Реверсирует четырёхбайтные цепочки. Параметр приёмн указывает  \n                число байтов, к-е д.б. кратно 4\n\n        ***********************************************************************/\n\n        final static проц своп32 (ук приёмн, бцел байты);\n\n        /***********************************************************************\n\n               Реверсирует 8-байтные цепочки. Параметр приёмн указывает  \n                число байтов, к-е д.б. кратно 8\n\n        ***********************************************************************/\n\n        final static проц своп64 (ук приёмн, бцел байты);\n\n        /***********************************************************************\n\n               Реверсирует 10-байтные цепочки. Параметр приёмн указывает  \n                число байтов, к-е д.б. кратно 10\n\n        ***********************************************************************/\n\n        final static проц своп80 (ук приёмн, бцел байты);\n}\n///////////////////////////////////////////////////////////////////////\nextern(D)\n{\n\n\tбцел байтЮ(ткст т, т_мера и);\n\tбцел байтЮ(шткст т, т_мера и);\t\n\tбцел байтЮ(юткст т, т_мера и);\n\tт_мера доИндексаУНС(ткст т, т_мера и);\n\tт_мера доИндексаУНС(шткст т, т_мера и);\n\tт_мера доИндексаУНС(юткст т, т_мера и);\n\tт_мера вИндексЮ(ткст т, т_мера и);\n\tт_мера вИндексЮ(шткст т, т_мера и);\n\tт_мера вИндексЮ(юткст т, т_мера и);\n\tдим раскодируйЮ(ткст т, inout т_мера инд);\n\tдим раскодируйЮ(шткст т, inout т_мера инд);\n\tдим раскодируйЮ(юткст т, inout т_мера инд);\n\tпроц кодируйЮ(inout ткст т, дим с);\n\tпроц кодируйЮ(inout шткст т, дим с);\n\tпроц кодируйЮ(inout юткст т, дим с);\n\tпроц оцениЮ(ткст т);\n\tпроц оцениЮ(шткст т);\n\tпроц оцениЮ(юткст т);\n\tткст вЮ8(ткст т);\n\tткст вЮ8(шткст т);\n\tткст вЮ8(юткст т);\n\tткст вЮ8(сим[4] буф, дим с);\n\tшткст вЮ16(ткст т);\n\tшим* вЮ16н(ткст т);\n\tшткст вЮ16(шткст т);\n\tшткст вЮ16(юткст т);\n\tшткст вЮ16(шим[2] буф, дим с);\n\tюткст вЮ32(ткст т);\n\tюткст вЮ32(шткст т);\n\tюткст вЮ32(юткст т);\n\t\nпроц пишиф(...);\nпроц пишифнс(...);\nпроц скажифнс(...);\nпроц скажиф(...);\nпроц пишиф_в(фук чф, ...);\nпроц пишифнс_в(фук чф, ...);\nткст фм(...);\nalias фм форматируй;\n\nпроц форматДелай(проц delegate(дим) putc, ИнфОТипе[] arguments, спис_ва аргук);\nткст форматируйс(ткст т, ...);\n\nпроц разборСпискаАргументов(ref ИнфОТипе[] арги, ref спис_ва аргук, out ткст format);\n\nткст[] списпап(ткст имяп, РегВыр рег);\nпроц списпап(ткст имяп, бул delegate(ткст имяф) обрвызов);\nпроц списпап(ткст имяп, бул delegate(ПапЗап* пз) обрвызов);\n\nткст подставь(ткст текст, ткст образец, ткст delegate(РегВыр) дг, ткст атрибуты = пусто);\n\nРегВыр ищи(ткст текст, ткст образец, ткст атрибуты = пусто);\n\nт_время вЦел(т_время n);\n\n\tреал абс(креал х);\n\tреал абс(вреал х);\n\tкреал конъюнк(креал у);\n\tвреал конъюнк(вреал у);\n\tкреал кос(креал х);\n\tреал кос(вреал х);\n\tкреал син(креал х);\n\tвреал син(вреал х);\n\tкреал квкор(креал х);\n\tцел больш_из(цел а, цел б);\n\tдол больш_из(дол а, дол б);\n\tцел больш_из(цел[] ч);\n\tдол больш_из(дол[] ч);\n\tцел меньш_из(цел а, цел б);\n\tдол меньш_из(дол а, дол б);\n\tцел меньш_из(цел[] ч);\n\tдол меньш_из(дол[] ч);\n\tцел сумма(цел[] ч);\n\tдол сумма(дол[] ч);\n\tдол квадрат(цел а);\n\tцел квадрат(цел а);\n}\n/////////////////////////////////////\nextern(D)\n{\n\tткст ДАТА(); ////alias _ДАТА ДАТА;\n\tткст ВРЕМЯ(); //alias _ВРЕМЯ ВРЕМЯ;\n\n\tук дай_низ_стека(); //alias  _дай_низ_стека дай_низ_стека;\n\n\t//МД5\n\tпроц суммаМД5(ббайт[16] дайджест, проц[] данные); //alias _суммаМД5 суммаМД5;\n\tпроц выведиМД5Дайджест(ббайт дайджест[16]); //alias _выведиМД5Дайджест выведиМД5Дайджест;\n\tткст дайджестМД5вТкст(ббайт[16] дайджест); //alias _дайджестМД5вТкст дайджестМД5вТкст;\n\t//ЗИП\n\n\t//ЗЛИБ\n\tбцел адлер32(бцел адлер, проц[] буф); //alias _адлер32 адлер32;\n\tбцел цпи32(бцел кс, проц[] буф); //alias _цпи32 цпи32;\n\tпроц[] сожмиЗлиб(проц[] истбуф, цел ур = цел.init); //alias _сожмиЗлиб сожмиЗлиб;\n\tпроц[] разожмиЗлиб(проц[] истбуф, бцел итдлин = 0u, цел винбиты = 15); //alias _разожмиЗлиб разожмиЗлиб;\n\n\t//Универсальный Идентификатор Ресурса\n\tбцел аски8гекс(дим с); alias аски8гекс аскиВгекс;\n\n\tткст раскодируйУИР(ткст кодирУИР);\n\talias раскодируйУИР раскодуир;\n\n\tткст раскодируйКомпонентУИР(ткст кодирКомпонУИР);\n\talias раскодируйКомпонентУИР раскодкомпуир;\n\n\tткст кодируйУИР(ткст уир);\n\talias кодируйУИР кодуир;\n\n\tткст кодируйКомпонентУИР(ткст уирКомпон);\n\talias кодируйКомпонентУИР кодкомпуир;\n\n\t//Юникод\n\n\tбул юпроп_ли(дим с); //alias _юпроп_ли юпроп_ли;\n\tбул юзаг_ли(дим с); //alias _юзаг_ли юзаг_ли;\n\tдим в_юпроп(дим с); //alias _в_юпроп в_юпроп;\n\tдим в_юзаг(дим с);  //alias _в_юзаг в_юзаг;\n\tбул юцб_ли(дим с); alias юцб_ли юцифрабукв_ли;\n\n\t//утилиты\n\tткст текстСисОшибки(бцел кодош); //alias _текстСисОшибки текстСисОшибки;\n\n\t//Динамически загружаемая библиотека\n\tцел иницМодуль(); //alias _иницМодуль иницМодуль;\n\tпроц деиницМодуль(); //alias _деиницМодуль деиницМодуль;\n\tук загрузиМодуль(in ткст имямод); //alias _загрузиМодуль загрузиМодуль;\n\tук добавьСсылНаМодуль(ук умодуль); //alias _добавьСсылНаМодуль добавьСсылНаМодуль;\n\tпроц отпустиМодуль(inout ук умодуль); //alias _отпустиМодуль отпустиМодуль, высвободиМодуль;\n\tук дайСимволИМодуля(inout ук умодуль, in ткст имяСимвола); //alias _дайСимволИМодуля дайСимволМодуля;\n\tткст ошибкаИМодуля(); //alias _ошибкаИМодуля ошибкаМодуля;\n\n\tцел пуб(бцел х); alias пуб дайПервУстБит;\n\tцел пубр(бцел х); alias пубр найдиПервУстБит;\n\tцел тб(in бцел *х, бцел номбит); alias тб тестируйБит;\n\tцел тбз(бцел *х, бцел номбит); alias тбз тестируйЗаполниБит;\n\tцел тбп(бцел *х, бцел номбит); alias тбп тестируйИзмениБит;\n\tцел тбу(бцел *х, бцел номбит); alias тбу тестируйУстановиБит;\n\tбцел развербит(бцел б); alias развербит разверниБайт;\n\tббайт чипортБб(бцел адр_порта); alias чипортБб читайПортБбайт;\n\tбкрат чипортБк(бцел адр_порта); alias чипортБк читайПортБкрат;\n\tбкрат чипортБц(бцел адр_порта); alias чипортБц читайПортБцел;\n\tббайт пипортБб(бцел адр_порта, ббайт зап); alias пипортБб пишиПортБбайт;\n\tбкрат пипортБк(бцел адр_порта, бкрат зап); alias пипортБк пишиПортБкрат;\n\tбкрат пипортБц(бцел адр_порта, бцел зап); alias  пипортБц пишиПортБцел;\n\tцел члоустбит32( бцел x ); //alias _члоустбит32 члоустбит32;\n\tбкрат битсвоп( бцел x ); alias битсвоп переставьБит ;\n\n\tбкрат кодируйДлину64(бцел сдлин); //alias _кодируйДлину64 кодируйДлину64;\n\tткст кодируй64(ткст стр, ткст буф = ткст.init); //alias _кодируй64 кодируй64;\n\tбкрат раскодируйДлину64(бцел кдлин); //alias _раскодируйДлину64 раскодируйДлину64;\n\tткст раскодируй64(ткст кстр, ткст буф = ткст.init); //alias _раскодируй64 раскодируй64;\n\t\n\tпроц пишификс(фук фу, ИнфОТипе[] аргументы, ук аргук, цел нс = нет); //alias _пишификс пишификс;\n\n\tткст читайстр(); //alias _читайстр читайстр, читайКонсоль;\n\tт_мера читайстр(фук чф, inout ткст буф);\n\tт_мера читайстр(inout ткст буф);\n\n\tцел числобукв_ли(дим б); //alias _числобукв_ли числобукв_ли;\n\tцел буква_ли(дим б); //alias _буква_ли буква_ли;\n\tцел управ_ли(дим б); //alias _управ_ли управ_ли;\n\tцел цифра_ли(дим б); //alias _цифра_ли цифра_ли;\n\tцел проп_ли(дим б); //alias _проп_ли проп_ли;\n\tцел пунктзнак_ли(дим б); //alias _пунктзнак_ли пунктзнак_ли;\n\tцел межбукв_ли(дим б); //alias _межбукв_ли межбукв_ли;\n\tцел заг_ли(дим б); //alias _заг_ли заг_ли;\n\tцел цифраикс_ли(дим б); //alias _цифраикс_ли цифраикс_ли;\n\tцел граф_ли(дим б); //alias _граф_ли граф_ли;\n\tцел печат_ли(дим б) ; //alias _печат_ли печат_ли;\n\tцел аски_ли(дим б); //alias _аски_ли аски_ли;\n\tдим впроп(дим б); //alias _впроп впроп;\n\tдим взаг(дим б); //alias _взаг взаг;\n\tцел руспроп_ли(дим б); //alias _руспроп_ли руспроп_ли;\n\tцел русзаг_ли(дим б); //alias _русзаг_ли русзаг_ли;\n\n\tбул пробел_ли(дим s); //alias _пробел_ли пробел_ли;\n\tдол ткствцел(ткст s); //alias _ткствцел ткствцел;\n\tреал ткствдробь(ткст s); //alias _ткствдробь ткствдробь;\n\tцел сравни(ткст s1, ткст s2); //alias _сравни сравни;\n\tцел сравнлюб(ткст s1, ткст s2); //alias _сравнлюб сравнлюб;\n\tсим* вТкст0(ткст s); //alias _вТкст0 вТкст0;\n\tцел найди(ткст s, дим c); //alias _найди найди;\n\tцел найдлюб(ткст s, дим c); //alias _найдлюб найдлюб;\n\tцел найдрек(ткст s, дим c); //alias _найдрек найдрек;\n\tцел найдлюбрек(ткст s, дим c); //alias _найдлюбрек найдлюбрек;\n\tцел найди(ткст s, ткст подст);\n\tцел найдлюб(ткст s, ткст подст);\n\tцел найдрек(ткст s, ткст подст);\n\tцел найдлюбрек(ткст s, ткст подст);\n\tткст впроп(ткст s);\n\tткст взаг(ткст s);\n\tткст озаг(ткст т); //alias _озаг озаг;\n\tткст озагслова(ткст т); //alias _озагслова озагслова;\n\tткст повтори(ткст т, т_мера м);\n\tткст объедини(ткст[] слова, ткст разд); //alias _объедини объедини;\n\tткст [] разбейдоп(ткст т, ткст разделитель); //alias _разбейдоп разбейдоп;\n\tткст [] разбей(ткст т); //alias _разбей разбей;\n\tткст [] разбейнастр(ткст т); //alias _разбейнастр разбейнастр;\n\tткст уберислева(ткст т); //alias _уберислева уберислева;\n\tткст уберисправа(ткст т); //alias _уберисправа уберисправа;\n\tткст убери(ткст т); //alias _убери убери;\n\tткст убериразгр(ткст т); //alias _убериразгр убериразгр;\n\tткст уберигран(ткст т); //alias _уберигран уберигран;\n\tткст полев(ткст т, цел ширина); //alias _полев полев;\n\tткст поправ(ткст т, цел ширина); //alias _поправ поправ;\n\tткст вцентр(ткст т, цел ширина); //alias _вцентр вцентр;\n\tткст занули(ткст т, цел ширина); //alias _занули занули;\n\tткст замени(ткст т, ткст с, ткст на); //alias _замени замени;\n\tткст заменисрез(ткст т, ткст срез, ткст замена);\n\tткст вставь(ткст т, т_мера индекс, ткст подст); //alias _вставь вставь;\n\tт_мера счесть(ткст т, ткст подст); //alias \n\n\tткст заменитабнапбел(ткст стр, цел размтаб=8); //alias _заменитабнапбел заменитабнапбел;\n\tткст заменипбелнатаб(ткст стр, цел размтаб=8); //alias _заменипбелнатаб заменипбелнатаб;\n\tткст постройтранстаб(ткст из, ткст в); //alias _постройтранстаб постройтранстаб;\n\tткст транслируй(ткст т, ткст табтранс, ткст удсим); //alias _транслируй транслируй; \n\t\n\tт_мера посчитайсимв(ткст т, ткст образец); //alias _посчитайсимв посчитайсимв;\n\tткст удалисимв(ткст т, ткст образец); //alias _удалисимв удалисимв;\n\tткст сквиз(ткст т, ткст образец= пусто); //alias _сквиз сквиз;\n\tткст следщ(ткст т); //alias _следщ следщ;\n\tткст тз(ткст ткт, ткст из, ткст в, ткст модифф= пусто); //alias _тз тз;\n\n\tбул чис_ли(in ткст т, in бул раздВкл = нет); //alias _чис_ли чис_ли; \n\tт_мера колном(ткст ткт, цел размтаб=8); //alias _колном колном;\n\tткст параграф(ткст т, цел колонки = 80, ткст первотступ = пусто, ткст отступ = пусто, цел размтаб = 8); //alias _параграф параграф;\n\tткст эладр_ли(ткст т); //alias _эладр_ли эладр_ли;\n\tткст урл_ли(ткст т); //alias _урл_ли урл_ли;\n\tткст целВЮ8(ткст врем, бцел знач); //alias _целВЮ8 целВЮ8;\n\tткст бдолВЮ8(ткст врем, бцел знач); //alias _бдолВЮ8 бдолВЮ8;\n\n\n\tцел вЦел(ткст т); //alias _вЦел вЦел;\n\tбцел вБцел(ткст т); //alias _вБцел вБцел;\n\tдол вДол(ткст т); //alias _вДол вДол;\n\tбдол вБдол(ткст т); //alias _вБдол вБдол;\n\tкрат вКрат(ткст т); //alias _вКрат вКрат;\n\tбкрат вБкрат(ткст т); //alias _вБкрат вБкрат;\n\tбайт вБайт(ткст т); //alias _вБайт вБайт;\n\tббайт вБбайт(ткст т); //alias _вБбайт вБбайт;\n\tплав вПлав(ткст т); //alias _вПлав вПлав;\n\tдво вДво(ткст т); //alias _вДво вДво;\n\tреал вРеал(ткст т); //alias _вРеал вРеал;\n\n\tпроц установиИсходнуюПапкуДляКовер(ткст путь);\n\tпроц установиПапкуЗаписиДляКовер(ткст путь);\n\tпроц установиСлияниеКовер(бул флаг);\n\tпроц регитьКовер(ткст фимя, МассивБит оу, бцел[] данные);\n\n\tбул дим_ли(дим д);\n\n\tпроц случсей(бцел семя, бцел индекс);\n\tбцел случайно();\n\tбцел случген(бцел семя, бцел индекс, реал члоциклов);\n\n\tпроц[] читайФайл(ткст имяф); //alias _читайФайл читайФайл;\n\tпроц пишиФайл(ткст имяф, проц[] буф); //alias _пишиФайл пишиФайл;\n\tпроц допишиФайл(ткст имяф, проц[] буф); //alias _допишиФайл допишиФайл;\n\tпроц переименуйФайл(ткст из, ткст в); //alias _переименуйФайл переименуйФайл;\n\tпроц удалиФайл(ткст имяф); //alias _удалиФайл удалиФайл;\n\tбдол дайРазмерФайла(ткст имяф); //alias _дайРазмерФайла дайРазмФайла, дайРазмерФайла;\n\tпроц дайВременаФайла(ткст имяф, out т_время фтц, out т_время фта, out т_время фтм);\n\tбул естьФайл(ткст имяф); //alias _естьФайл естьФайл;\n\tбкрат дайАтрибутыФайла(ткст имяф); alias дайАтрибутыФайла дайАтрыФайла;\n\tбул файл_ли(ткст имяф); //alias _файл_ли файл_ли;\n\tбул папка_ли(ткст имяп); //alias _папка_ли папка_ли;\n\tпроц сменипап(ткст имяп);\talias сменипап перейди_в;\n\tпроц сделайпап(ткст имяп); alias сделайпап сделайПапку;\n\tпроц удалипап(ткст имяп); alias удалипап  удалиПапку;\n\tткст дайтекпап(); alias дайтекпап дайТекущуюПапку;\n\tткст [] списпап(ткст имяп, ткст образец); alias списпап  списокПапки;\n\tткст [] списпап(ткст имяп);\n\tпроц копируйФайл(ткст из, ткст в); //alias _копируйФайл копируйФайл;\n\tсим* вМБТ_0(ткст т);\n\tбул выведиФайл(ткст имяф);\n\n\tДата разборДаты(ткст т);\n\n\tпроц вГодНедИСО8601(т_время t, out цел год, out цел неделя);\t\n\tцел День(т_время t);\n\tцел високосныйГод(цел y);\n\tцел днейВГоду(цел y);\n\tцел деньИзГода(цел y);\n\tт_время времяИзГода(цел y);\n\tцел годИзВрем(т_время t);\t\n\tбул високосный_ли(т_время t);\n\tцел месяцИзВрем(т_время t);\n\tцел датаИзВрем(т_время t);\n\tцел часИзВрем(т_время t);\n\tцел минИзВрем(т_время t);\n\tцел секИзВрем(т_время t);\n\tцел мсекИзВрем(т_время t);\n\tцел времениВДне(т_время t);\n\tцел ДеньНедели(т_время вр);\n\tт_время МВ8Местное(т_время вр);\n\tт_время местное8МВ(т_время вр);\n\tт_время сделайВремя(т_время час, т_время мин, т_время сек, т_время мс);\n\tт_время сделайДень(т_время год, т_время месяц, т_время дата);\n\tт_время сделайДату(т_время день, т_время вр);\n\n\tцел датаОтДняНеделиМесяца(цел год, цел месяц, цел день_недели, цел ч);\n\tцел днейВМесяце(цел год, цел месяц);\n\tткст вТкст(т_время время);\n\tткст вТкстМВ(т_время время);\n\tткст вТкстДаты(т_время время);\n\tткст вТкстВремени(т_время время);\n\tт_время разборВремени(ткст т);\n\tт_время дайВремяМВ();\n\tт_время ФВРЕМЯ8т_время(ФВРЕМЯ *фв);\n\tт_время СИСТВРЕМЯ8т_время(СИСТВРЕМЯ *св, т_время вр);\n\tт_время дайМестнуюЗЧП();\n\tцел дневноеСохранениеЧО(т_время вр);\n\tт_время вДвремя(ФВремяДос вр);\n\tФВремяДос вФВремяДос(т_время вр);\n\n\tткст о_ЦПУ();\n\n\tткст разманглируй(ткст имя);\n\tткст извлекиРасш(ткст пимя); alias извлекиРасш дайРасш;\n\tткст дайИмяПути(ткст пимя);\n\n\tткст извлекиИмяПути(ткст пимя);\n\tткст извлекиПапку(ткст пимя);\n\n\tткст извлекиМеткуДиска(ткст пимя);\n\tткст устДефРасш(ткст пимя, ткст расш);\n\tткст добРасш(ткст фимя, ткст расш);\n\tбул абсПуть_ли(ткст путь); //alias _абсПуть_ли абсПуть_ли;\n\tткст слейПути(ткст п1, ткст п2); //alias _слейПути слейПути, объедини;\n\tбул сравниПути(дим п1, дим п2);\n\tбул сравниПутьОбразец(ткст фимя, ткст образец);\n\tткст разверниТильду(ткст путь);\n\n\tреал абс(реал х); //alias _абс абс;\n\tдол абс(дол х);\n\tцел абс(цел х);\n\tреал кос(реал х); //alias _кос кос;\n\tреал син(реал х); //alias _син син;\n\tреал тан(реал х); //alias _тан тан;\n\tреал акос(реал х); //alias _акос акос;\n\tреал асин(реал х); //alias _асин асин;\n\tреал атан(реал х); //alias _атан атан;\n\tреал атан2(реал у, реал х); //alias _атан2 атан2;\n\tреал гкос(реал х); //alias _гкос гкос;\n\tреал гсин(реал х); //alias _гсин гсин;\n\tреал гтан(реал х); //alias _гтан гтан;\n\tреал гакос(реал х);  //alias _гакос гакос;\n\tреал гасин(реал х);  //alias _гасин гасин;\n\tреал гатан(реал х);  //alias _гатан гатан;\n\tдол округливдол(реал х);  //alias _округливдол округливдол;\n\tдол округливближдол(реал х);  //alias _округливближдол округливближдол;\n\tплав квкор(плав х);  //alias _квкор квкор;\n\tдво квкор(дво х); \n\tреал квкор(реал х);\n\tреал эксп(реал х);  //alias _эксп эксп;\n\tреал экспм1(реал х);  //alias _экспм1 экспм1;\n\tреал эксп2(реал х);  //alias _эксп2 эксп2;\n\tкреал экспи(реал х);  //alias _экспи экспи;\n\tреал прэксп(реал знач, out цел эксп);  //alias _прэксп прэксп;\n\tцел илогб(реал х);  //alias _илогб илогб;\n\tреал лдэксп(реал н, цел эксп);  //alias _лдэксп лдэксп;\n\tреал лог(реал х);  //alias _лог лог;\n\tреал лог10(реал х);  //alias _лог10 лог10;\n\tреал лог1п(реал х);  //alias _лог1п лог1п;\n\tреал лог2(реал х);  //alias _лог2 лог2;\n\tреал логб(реал х);  //alias _логб логб;\n\tреал модф(реал х, inout реал у);  //alias _модф модф;\n\tреал скалбн(реал х, цел н);  //alias _скалбн скалбн;\n\tреал кубкор(реал х);  //alias _кубкор кубкор;\n\tреал фабс(реал х);  //alias _фабс фабс;\n\tреал гипот(реал х, реал у);  //alias _гипот гипот;\n\tреал фцош(реал х);  //alias _фцош фцош;\n\tреал лгамма(реал х);  //alias _лгамма лгамма;\n\tреал тгамма(реал х);  //alias _тгамма тгамма;\n\tреал потолок(реал х);  //alias _потолок потолок;\n\tреал пол(реал х);  //alias _пол пол;\n\tреал ближцел(реал х);  //alias _ближцел ближцел;\n\tцел окрвцел(реал x); //alias _окрвцел окрвцел;\n\tреал окрвреал(реал х);   //alias _окрвреал окрвреал;\n\tдол окрвдол(реал х);  //alias _окрвдол окрвдол;\n\tреал округли(реал х);  //alias _округли округли;\n\tдол докругли(реал х);  //alias _докругли докругли;\n\tреал упрости(реал х);  //alias _упрости упрости;\n\tреал остаток(реал х, реал у);  //alias _остаток остаток;\n\tбул нч_ли(реал х);  //alias _нч_ли нч_ли;\n\tбул конечен_ли(реал р);  //alias _конечен_ли конечен_ли;\n\tбул субнорм_ли(плав п);  //alias _субнорм_ли субнорм_ли;\n\tбул субнорм_ли(дво п); \n\tбул субнорм_ли(реал п);\n\tбул беск_ли(реал р);  //alias _беск_ли беск_ли;\n\tбул идентичен_ли(реал р, реал д);  //alias _идентичен_ли идентичен_ли;\n\tбул битзнака(реал р);  //alias _битзнака битзнака;\n\tреал копируйзнак(реал кому, реал у_кого);  //alias _копируйзнак копируйзнак;\n\tреал нч(ткст тэгп);  //alias _нч нч;\n\tреал следщБольш(реал р);  //alias _следщБольш следщБольш;\n\tдво следщБольш(дво р);  \n\tплав следщБольш(плав р);\n\tреал следщМеньш(реал р);  //alias _следщМеньш следщМеньш;\n\tдво следщМеньш(дво р); \n\tплав следщМеньш(плав р); \n\tреал следщза(реал а, реал б);  //alias _следщза следщза;\n\tплав следщза(плав а, плав б);\n\tдво следщза(дво а, дво б); \n\tреал пдельта(реал а, реал б);  //alias _пдельта пдельта;\n\tреал пбольш_из(реал а, реал б);  //alias _пбольш_из пбольш_из;\n\tреал пменьш_из(реал а, реал б);  //alias _пменьш_из пменьш_из;\n\tреал степень(реал а, бцел н);  //alias _степень степень;\n\tреал степень(реал а, цел н);\n\tреал степень(реал а, реал н); \n\tбул правны(реал а, реал б);  //alias _правны правны;\n\tбул правны(реал а, реал б, реал эпс);\n\tреал квадрат(цел а);  //alias _квадрат квадрат;\n\tреал дробь(реал а);  //alias _дробь дробь;\n\tцел знак(цел а);  //alias _знак знак;\n\tцел знак(дол а); \n\tцел знак(реал а);  \n\tреал цикл8градус(реал ц);  //alias _цикл8градус цикл8градус;\n\tреал цикл8радиан(реал ц);  //alias _цикл8радиан цикл8радиан;\n\tреал цикл8градиент(реал ц);  //alias _цикл8градиент цикл8градиент;\n\tреал градус8цикл(реал г);  //alias _градус8цикл градус8цикл;\n\tреал градус8радиан(реал г);  //alias _градус8радиан градус8радиан;\n\tреал градус8градиент(реал г);  //alias _градус8градиент градус8градиент;\n\tреал радиан8градус(реал р);  //alias _радиан8градус радиан8градус;\n\tреал радиан8цикл(реал р);  //alias _радиан8цикл радиан8цикл;\n\tреал радиан8градиент(реал р);  //alias _радиан8градиент радиан8градиент;\n\tреал градиент8градус(реал г);  //alias _градиент8градус градиент8градус;\n\tреал градиент8цикл(реал г);  //alias _градиент8цикл градиент8цикл;\n\tреал градиент8радиан(реал г);  //alias _градиент8радиан градиент8радиан;\n\tреал сариф(реал[] ч);  //alias _сариф сариф;\n\tреал сумма(реал[] ч);  //alias _сумма сумма;\n\tреал меньш_из(реал[] ч);  //alias _меньш_из меньш_из;\n\tреал меньш_из(реал а, реал б);  \n\tреал больш_из(реал[] ч);  //alias _больш_из больш_из;\n\tреал больш_из(реал а, реал б);\n\tреал акот(реал р);  //alias _акот акот;\n\tреал асек(реал р);  //alias _асек асек;\n\tреал акосек(реал р);  //alias _акосек акосек;\n\tреал кот(реал р);  //alias _кот кот;\n\tреал сек(реал р);  //alias _сек сек;\n\tреал косек(реал р);  //alias _косек косек;\n\tреал гкот(реал р);  //alias _гкот гкот;\n\tреал гсек(реал р);  //alias _гсек гсек;\n\tреал гкосек(реал р);  //alias _гкосек гкосек;\n\tреал гакот(реал р);  //alias _гакот гакот;\n\tреал гасек(реал р);  //alias _гасек гасек;\n\tреал гакосек(реал р);  //alias _гакосек гакосек;\n\tреал ткст8реал(ткст т);  //alias _ткст8реал ткст8реал;\n\n\tткст подставь(ткст текст, ткст образец, ткст формат, ткст атрибуты = пусто); //alias _подставь подставь;\n\n\tцел найди(рткст текст, ткст образец, ткст атрибуты);\n\tцел найдирек(рткст текст, ткст образец, ткст атрибуты = пусто);\n\tткст [] разбей(ткст текст, ткст образец, ткст атрибуты = пусто);\n\n\tцел система (ткст команда); alias система сис;\n\t\n\tцел пауза(); alias пауза пз;\n\tцел пускпрог(цел режим, ткст путь, ткст[] арги);\n\tцел выппрог(ткст путь, ткст[] арги);\n\tцел выппрог(ткст путь, ткст[] арги, ткст[] перемср);\n\tцел выппрогcp(ткст путь, ткст[] арги);\n\tцел выппрогср(ткст путь, ткст[] арги, ткст[] перемср);\n\n\t//std.crc32 (ЦПИ - Циклическая Проверка Избыточности)\n\tбкрат иницЦПИ32();\n\tбкрат обновиЦПИ32б(ббайт зн, бцел црц);\n\tбкрат обновиЦПИ32с(сим зн, бцел црц);\n\tбкрат ткстЦПИ32(ткст т);\n\n\tбул закройДисковод(ткст меткаДиска);\n\tбул откройДисковод(ткст меткаДиска);\n\n\tпроц инфо(ткст сооб); //alias _инфо инфо;\n} //end of extern C\n////////////////////////////////////////////////////////\n/+\nСФайл двхо;\nСФайл двых;\nСФайл дош;\n\nstatic this() {\n  // open standard I/O devices\n  двхо = new СФайл(СТДВВОД, ПФРежим.Ввод);\n  двых = new СФайл(СТДВЫВОД, ПФРежим.Вывод);\n  дош = new СФайл(СТДОШ, ПФРежим.Вывод);\n}\n\nstatic ~this()\n {\n  двхо.слей();\n  двхо.закрой();\n  двых.слей();\n  двых.закрой();\n  дош.слей();\n  дош.закрой();\n}\n+/\nextern(D):\n\nткст дайПеремСреды(ткст пер);\nпроц устПеремСреды(ткст пер, ткст знач);\nткст[] дайПуть();\nбул гдеЯ(ткст арги, inout ткст пап, inout ткст имя);\nткст канонПуть(ткст origpath);\nпроц сделпапР(ткст пап);\nпроц удалиРек(ткст имя);\nбул естьФайлВКэш(ткст имяФ);\nпроц удалиКэшСущФайлов();",
			"file": "Base/import/stdrus.d",
			"file_size": 75015,
			"file_write_time": 131296270640000000,
			"settings":
			{
				"buffer_size": 48104,
				"line_ending": "Windows"
			}
		},
		{
			"contents": " /// Author: Aziz Köksal\n/// License: GPL3\n/// $(Maturity average)\nmodule SettingsLoader;\n\nimport drc.ast.Node,\n       drc.ast.Declarations,\n       drc.ast.Expressions;\nimport drc.semantic.Module,\n       drc.semantic.Pass1,\n       drc.semantic.Symbol,\n       drc.semantic.Symbols;\nimport drc.Messages;\nimport drc.Diagnostics;\nimport drc.Compilation;\nimport Settings;\nimport common;\n\nimport io.FilePath;\nimport sys.Environment;\n\n/// Загружает настройки из файла модуля Ди.\nabstract class ЗагрузчикНастроек\n{\n  Диагностика диаг; /// Собирает сообщения об ошибках.\n  Модуль мод; /// Текущий модуль.\n\n  this(Диагностика диаг)\n  {\n    this.диаг = диаг;\n  }\n\n  /// Создает отчёт об ошибках.\n  /// Параметры:\n  ///   сема = в которой произошла ошибка.\n  ///   форматирСооб = сообщение об ошибке.\n  проц  ошибка(Сема* сема, ткст форматирСооб, ...)\n  {\n    auto положение = сема.дайПоложениеОшибки();\n    auto сооб = Формат(_arguments, _argptr, форматирСооб);\n    диаг ~= new ОшибкаСемантики(положение, сооб);\n  }\n\n  T дайЗначение(T)(ткст имя)\n  {\n    auto перм = мод.сыщи(имя);\n    if (!перм) // Returning T.иниц instead of null, because dmd gives an ошибка.\n      return ошибка(мод.перваяСема, \"переменная '{}' не указана\", имя), T.init;\n    auto t = перм.узел.начало;\n    if (!перм.Переменная_ли)\n      return ошибка(t, \"'{}' не является декларацией переменной\", имя), T.init;\n    auto значение = перм.в!(Переменная).значение;\n    if (!значение)\n      return ошибка(t, \"у переменной '{}' не установлено значение\", имя), T.init;\n    T знач = значение.Является!(T); // Пробуй casting в T.\n    if (!знач)\n      ошибка(значение.начало, \"значение '{}' должно быть типа {}\", имя, T.stringof);\n    return знач;\n  }\n\n  T перебросьВ(T)(Узел n)\n  {\n    if (auto результат = n.Является!(T))\n      return результат;\n    ткст тип = T.stringof;\n    (is(T == ТекстовоеВыражение) && (тип = \"сим[]\").ptr) ||\n    (is(T == ВыражениеИницМассива) && (тип = \"[]\").ptr) ||\n    (is(T == ЦелВыражение) && (тип = \"цел\"));\n    ошибка(n.начало, \"выражение не является типа {}\", тип);\n    return null;\n  }\n\n  проц  загрузи()\n  {}\n}\n\n/// Загружает файл конфигурации drc.\nclass ЗагрузчикКонфиг : ЗагрузчикНастроек\n{\n  static ткст имяФайлаКонфиг = \"drc.conf\"; /// Имя файла конфигурации.\n  ткст путьКЭкзе; /// Абсолютный путь к исполнимому коду drc.\n  ткст папкаСЭкзе; /// Абсолютный путь к папке с исполнимым кодом drc.\n  ткст папкаСДанными; /// Абсолютный путь к папке с данными drc.\n  ткст путьДомой; /// Путь к домашней папке.\n\n  this(Диагностика диаг)\n  {\n    super(диаг);\n    this.путьДомой = Среда.получи(\"HOME\");\n    this.путьКЭкзе = ДайПутьКИсполнимомуФайлу();\n    this.папкаСЭкзе = (new ФПуть(this.путьКЭкзе)).папка();\n    Среда.установи(\"BINDIR\", this.папкаСЭкзе);\n  }\n\n  static ЗагрузчикКонфиг opCall(Диагностика диаг)\n  {\n    return new ЗагрузчикКонфиг(диаг);\n  }\n\n  static ткст раскройПеременные(ткст знач)\n  {\n    ткст сделайТекст(сим* начало, сим* конец)\n    {\n      assert(начало && конец && начало <= конец);\n      return начало[0 .. конец - начало];\n    }\n\n    ткст результат;\n    сим* p = знач.ptr, конец = p + знач.length;\n    сим* началоКуска = p; // Points в the piece of the ткст after a переменная.\n\n    while (p+3 < конец)\n    {\n      if (p[0] == '$' && p[1] == '{')\n      {\n        auto началоПеременной = p;\n        while (p < конец && *p != '}')\n          p++;\n        if (p == конец)\n          break; // Не раскрывать незаконченные переменные.\n        результат ~= сделайТекст(началоКуска, началоПеременной);\n        началоПеременной += 2; // Skip ${\n        // Получить переменную среды и добавить её в результат.\n        результат ~= Среда.получи(сделайТекст(началоПеременной, p));\n        началоКуска = p + 1; // Указывает на символ после '}'.\n      }\n      p++;\n    }\n    if (началоКуска < конец)\n      результат ~= сделайТекст(началоКуска, конец);\n    return результат;\n  }\nalias раскройПеременные рп;\n  проц  загрузи()\n  {\n    // Искать файл конфигурации.\n    auto путьКФайлу = НайдиПутьКФайлуКонфигурации();\n    if (путьКФайлу is null)\n    {\n      диаг ~= new drc.Information.Ошибка(new Положение(\"\",0),\n        \"файл конфигурации \"~имяФайлаКонфиг~\" найти не удалось.\");\n      return;\n    }\n    // Загрузить файл как модуль Ди.\n    мод = new Модуль(путьКФайлу, диаг);\n    мод.разбор();\n\n    if (мод.естьОшибки)\n      return;\n\n    auto контекст = new КонтекстКомпиляции;\n    auto проход1 = new СемантическаяПроходка1(мод, контекст);\n    проход1.пуск();\n\n    // Инициализация члена папкаСДанными.\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"ПАПДАНДРК\"))\n      this.папкаСДанными = знач.дайТекст();\n    this.папкаСДанными = рп(this.папкаСДанными);\n    ГлобальныеНастройки.папкаСДанными = this.папкаСДанными;\n    Среда.установи(\"ПАПДАНДРК\", this.папкаСДанными);\n\n    if (auto массив = дайЗначение!(ВыражениеИницМассива)(\"ИДЫ_ВЕРСИИ\"))\n      foreach (значение; массив.значения)\n        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))\n          ГлобальныеНастройки.идыВерсий ~= рп(знач.дайТекст());\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"ФАЙЛ_ЯЗ\"))\n      ГлобальныеНастройки.файлЯзыка = рп(знач.дайТекст());\n    if (auto массив = дайЗначение!(ВыражениеИницМассива)(\"ПУТИ_ИМПОРТА\"))\n      foreach (значение; массив.значения)\n        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))\n          ГлобальныеНастройки.путиИмпорта ~= рп(знач.дайТекст());\n    if (auto массив = дайЗначение!(ВыражениеИницМассива)(\"ФАЙЛЫ_ДДОК\"))\n      foreach (значение; массив.значения)\n        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))\n          ГлобальныеНастройки.путиКФайлуДдок ~= рп(знач.дайТекст());\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"КАРТА_РЯР\"))\n      ГлобальныеНастройки.файлКартыРЯР = рп(знач.дайТекст());\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"КАРТА_ГЯР\"))\n      ГлобальныеНастройки.файлКартыГЯР = рп(знач.дайТекст());\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"ОШ_ЛЕКСЕРА\"))\n      ГлобальныеНастройки.форматОшибкиЛексера = рп(знач.дайТекст());\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"ОШ_ПАРСЕРА\"))\n      ГлобальныеНастройки.форматОшибкиПарсера = рп(знач.дайТекст());\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"СЕМОШ\"))\n      ГлобальныеНастройки.форматОшибкиСемантики = рп(знач.дайТекст());\n    if (auto знач = дайЗначение!(ЦелВыражение)(\"ШИРИНА_ТАБ\"))\n    {\n      ГлобальныеНастройки.ширинаТаб = cast(бцел)знач.число;\n      Положение.ШИРИНА_ТАБ = cast(бцел)знач.число;\n    }\n\n\n    // Загрузка файла языка.\n    // TODO: создать для этого отдельный класс?\n    путьКФайлу = рп(ГлобальныеНастройки.файлЯзыка);\n    мод = new Модуль(путьКФайлу);\n    мод.разбор();\n\n    if (мод.естьОшибки)\n\t{\n\t//base.ошибка(Формат(\"Ошибки при разборе файла языка:\\n {}\", раскройПеременные(ГлобальныеНастройки.файлЯзыка)),__FILE__,__LINE__);\n      return;\n\t}\n\n    проход1 = new СемантическаяПроходка1(мод, контекст);\n    проход1.пуск();\n\n    if (auto массив = дайЗначение!(ВыражениеИницМассива)(\"сообщения\"))\n    {\n      сим[][] сообщения;\n      foreach (значение; массив.значения)\n        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))\n          сообщения ~= знач.дайТекст();\n      if (сообщения.length != ИДС.max+1)\n        ошибка(мод.перваяСема,\n              \"таблица сообщений  в {} должна иметь строго {} записей, а не {}.\",\n              путьКФайлу, ИДС.max+1, сообщения.length);\n      ГлобальныеНастройки.сообщения = сообщения;\n      drc.Messages.УстановиСообщения(сообщения);\n    }\n    if (auto знач = дайЗначение!(ТекстовоеВыражение)(\"код_языка\"))\n      ГлобальныеНастройки.кодЯзыка = знач.дайТекст();\n  }\n\n  /// Ищет файл конфигурации drc.\n  /// Возвращает: путьКФайлу или null, если файл найти не удаётся.\n  ткст НайдиПутьКФайлуКонфигурации()\n  {\n    // 1. Находит переменную среды DRCONF.\n    auto путьКФайлу = new ФПуть(Среда.получи(\"DRCONF\"));\n    if (путьКФайлу.есть_ли())\n      return путьКФайлу.вТкст();\n    // 2. Поиск в текущем рабочем каталоге.\n    путьКФайлу.установи(this.имяФайлаКонфиг);\n    if (путьКФайлу.есть_ли())\n      return путьКФайлу.вТкст();\n    // 3. Поиск в папке, указанной в переменной HOME.\n    путьКФайлу.установи(this.путьДомой);\n    путьКФайлу.добавь(this.имяФайлаКонфиг);\n    if (путьКФайлу.есть_ли())\n      return путьКФайлу.вТкст();\n    // 4. Поиск в папке с бинарниками.\n    путьКФайлу.установи(this.папкаСЭкзе);\n    путьКФайлу.добавь(this.имяФайлаКонфиг);\n    if (путьКФайлу.есть_ли())\n      return путьКФайлу.вТкст();\n    return null;\n  }\n}\n\n/// Загружает ассоциативный массив из файла модуля Ди.\nclass ЗагрузчикКартыТегов : ЗагрузчикНастроек\n{\n  this(Диагностика диаг)\n  {\n    super(диаг);\n  }\n\n  static ЗагрузчикКартыТегов opCall(Диагностика диаг)\n  {\n    return new ЗагрузчикКартыТегов(диаг);\n  }\n\n  ткст[ткст] загрузи(ткст путьКФайлу)\n  {\n    мод = new Модуль(путьКФайлу, диаг);\n    мод.разбор();\n    if (мод.естьОшибки)\n      return null;\n\n    auto контекст = new КонтекстКомпиляции;\n    auto проход1 = new СемантическаяПроходка1(мод, контекст);\n    проход1.пуск();\n\n    ткст[ткст] карта;\n    if (auto массив = дайЗначение!(ВыражениеИницМассива)(\"карта\"))\n      foreach (i, значение; массив.значения)\n      {\n        auto key = массив.ключи[i];\n        if (auto valExp = перебросьВ!(ТекстовоеВыражение)(значение))\n          if (!key)\n            ошибка(значение.начало, \"ожидались ключ : значение\");\n          else if (auto keyExp = перебросьВ!(ТекстовоеВыражение)(key))\n            карта[keyExp.дайТекст()] = valExp.дайТекст();\n      }\n    return карта;\n  }\n}\n\n/// Определяет путь к файлу относительно папки исполнимого кода.\n/// Возвращает: путьКФайлу, если он относительный, или путьИсп + путьКФайлу.\nткст определиПуть(ткст путьИсп, ткст путьКФайлу)\n{\n  scope путь = new ФПуть(путьКФайлу);\n  if (путь.абс_ли())\n    return путьКФайлу;\n  путь.установи(путьИсп).добавь(путьКФайлу);\n  return путь.вТкст();\n}\n\nversion(DDoc)\n{\n  /// Возвращает полный квалифицированыый путь к данному исполнимому файлу.\n  ткст ДайПутьКИсполнимомуФайлу();\n}\nelse version(Windows)\n{\nprivate extern(Windows) бцел GetModuleFileNameA(проц *, сим*, бцел);\n\nткст ДайПутьКИсполнимомуФайлу()\n{\n  alias GetModuleFileNameA GetModuleFileName;\n  ткст буфер = new сим[256];\n  бцел счёт;\n\n  while (1)\n  {\n    if (буфер is null)\n      return null;\n\n    счёт = GetModuleFileName(null, буфер.ptr, буфер.length);\n    if (счёт == 0)\n      return null;\n    if (буфер.length != счёт && буфер[счёт] == 0)\n      break;\n    // Increase размер of буфер\n    буфер.length = буфер.length * 2;\n  }\n  assert(буфер[счёт] == 0);\n  // Reduce буфер в the actual length of the ткст (excluding '\\0'.)\n  if (счёт < буфер.length)\n    буфер.length = счёт;\n  return буфер;\n}\n}\nelse version(linux)\n{\nprivate extern(C) т_мера readlink(сим* путь, сим* буф, т_мера буфразм);\n\nткст ДайПутьКИсполнимомуФайлу()\n{\n  ткст буфер = new сим[256];\n  т_мера счёт;\n\n  while (1)\n  {\n    // Этот won't work on very old Linux systems.\n    счёт = readlink(\"/proc/self/exe\".ptr, буфер.ptr, буфер.length);\n    if (счёт == -1)\n      return null;\n    if (счёт < буфер.length)\n      break;\n    буфер.length = буфер.length * 2;\n  }\n  буфер.length = счёт;\n  return буфер;\n}\n}\nelse\n  static assert(0, \"ДайПутьКИсполнимомуФайлу() на данной платформе не реализован.\");\n",
			"file": "DRC/src/SettingsLoader.d",
			"file_size": 16909,
			"file_write_time": 131599182709384765,
			"settings":
			{
				"buffer_size": 11231,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#\n#\n#           The Nim Compiler\n#        (c) Copyright 2017 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## General framework for performing dataflow computations.\n## Useful for semantic checks and optimizations.\n## Instead of a control flow graph we generate bytecode for an abstract\n## machine and use the algorithms based on this paper:\n## http://link.springer.com/chapter/10.1007%2F3-540-45937-5_6\n## \"A Graph—Free Approach to Data—Flow Analysis\"\n## The resulting algorithms use much less memory and are faster to operate\n## on.\n\nimport ast, msgs, intsets, strutils\nfrom os import splitFile\n\nconst\n  byteExcess* = 128 # we use excess-K for immediates\n  wordExcess* = 32768\n\ntype\n  Register* = range[0..255]\n  Dest* = range[-1 .. 255]\n  Instr* = distinct uint32\n\n  Opcode = enum\n    opcJmp, opcJmpBack, opcFJmp, opcTJmp,\n    opcBranch, opcTry, opcExcept, opcFinally, opcFinallyEnd, opcRaise,\n    opcCall,\n    opcRet,\n    opcUse, opcDef\n\n  Block* = object\n    label*: PSym\n    fixups*: seq[Position]\n\n  IR* = object\n    code*: seq[Instr]\n    info: seq[TLineInfo]\n    mapping: seq[PSym]\n    blocks: seq[Block]\n    slots*: array[Register, bool]\n    maxSlots*: int\n\n  PCtx = var IR\n\n  Position* = distinct int\n\nconst\n  relativeJumps* = {opcTJmp, opcFJmp, opcJmp, opcJmpBack}\n\ntemplate opcode*(x: Instr): Opcode = Opcode(x.uint32 and 0xff'u32)\ntemplate regA*(x: Instr): Register = Register(x.uint32 shr 8'u32 and 0xff'u32)\ntemplate regB*(x: Instr): Register = Register(x.uint32 shr 16'u32 and 0xff'u32)\ntemplate regC*(x: Instr): Register = Register(x.uint32 shr 24'u32)\ntemplate regBx*(x: Instr): int = (x.uint32 shr 16'u32).int\n\ntemplate jmpDiff*(x: Instr): int = regBx(x) - wordExcess\n\ntype\n  TGenFlag = enum gfAddrOf, gfFieldAccess\n  TGenFlags = set[TGenFlag]\n\nproc debugInfo(info: TLineInfo): string =\n  result = info.toFilename.splitFile.name & \":\" & $info.line\n\nproc codeListing(c: PCtx, result: var string, start=0; last = -1) =\n  # first iteration: compute all necessary labels:\n  var jumpTargets = initIntSet()\n  let last = if last < 0: c.code.len-1 else: min(last, c.code.len-1)\n  for i in start..last:\n    let x = c.code[i]\n    if x.opcode in relativeJumps:\n      jumpTargets.incl(i+x.regBx-wordExcess)\n\n  # for debugging purposes\n  var i = start\n  while i <= last:\n    if i in jumpTargets: result.addf(\"L$1:\\n\", i)\n    let x = c.code[i]\n\n    result.add($i)\n    let opc = opcode(x)\n    if opc in relativeJumps:\n      result.addf(\"\\t$#\\tr$#, L$#\", ($opc).substr(3), x.regA,\n                  i+x.regBx-wordExcess)\n    else:\n      let idx = x.regBx-wordExcess\n      result.addf(\"\\t$#\\tr$#, $# ($#)\", ($opc).substr(3), x.regA,\n        c.mapping[idx].name.s, $idx)\n    result.add(\"\\t#\")\n    result.add(debugInfo(c.info[i]))\n    result.add(\"\\n\")\n    inc i\n\nproc echoCode*(c: PCtx; start=0; last = -1) {.deprecated.} =\n  var buf = \"\"\n  codeListing(c, buf, start, last)\n  echo buf\n\nproc gABC(ctx: PCtx; n: PNode; opc: Opcode; a, b, c: Register = 0) =\n  ## Takes the registers `b` and `c`, applies the operation `opc` to them, and\n  ## stores the result into register `a`\n  ## The node is needed for debug information\n  assert opc.ord < 255\n  let ins = (opc.uint32 or (a.uint32 shl 8'u32) or\n                           (b.uint32 shl 16'u32) or\n                           (c.uint32 shl 24'u32)).Instr\n  ctx.code.add(ins)\n  ctx.info.add(n.info)\n\nproc gABx(c: PCtx; n: PNode; opc: Opcode; a: Register = 0; bx: int) =\n  # Applies `opc` to `bx` and stores it into register `a`\n  # `bx` must be signed and in the range [-32768, 32767]\n  if bx >= -32768 and bx <= 32767:\n    let ins = (opc.uint32 or a.uint32 shl 8'u32 or\n              (bx+wordExcess).uint32 shl 16'u32).Instr\n    c.code.add(ins)\n    c.info.add(n.info)\n  else:\n    localError(n.info, errGenerated,\n      \"VM: immediate value does not fit into an int16\")\n\nproc xjmp(c: PCtx; n: PNode; opc: Opcode; a: Register = 0): Position =\n  #assert opc in {opcJmp, opcFJmp, opcTJmp}\n  result = Position(c.code.len)\n  gABx(c, n, opc, a, 0)\n\nproc genLabel(c: PCtx): Position =\n  result = Position(c.code.len)\n  #c.jumpTargets.incl(c.code.len)\n\nproc jmpBack(c: PCtx, n: PNode, p = Position(0)) =\n  let dist = p.int - c.code.len\n  internalAssert(-0x7fff < dist and dist < 0x7fff)\n  gABx(c, n, opcJmpBack, 0, dist)\n\nproc patch(c: PCtx, p: Position) =\n  # patch with current index\n  let p = p.int\n  let diff = c.code.len - p\n  #c.jumpTargets.incl(c.code.len)\n  internalAssert(-0x7fff < diff and diff < 0x7fff)\n  let oldInstr = c.code[p]\n  # opcode and regA stay the same:\n  c.code[p] = ((oldInstr.uint32 and 0xffff'u32).uint32 or\n               uint32(diff+wordExcess) shl 16'u32).Instr\n\nproc getTemp(c: PCtx; tt: PType): Register =\n  # we prefer the same slot kind here for efficiency. Unfortunately for\n  # discardable return types we may not know the desired type. This can happen\n  # for e.g. mNAdd[Multiple]:\n  for i in 0 .. c.maxSlots-1:\n    if not c.slots[i]:\n      c.slots[i] = true\n      return Register(i)\n  if c.maxSlots >= high(Register):\n    internalError(\"VM problem: too many registers required\")\n  result = Register(c.maxSlots)\n  c.slots[c.maxSlots] = true\n  inc c.maxSlots\n\nproc freeTemp(c: PCtx; r: Register) =\n  c.slots[r] = false\n\ntemplate withTemp(tmp, typ, body: untyped) {.dirty.} =\n  var tmp = getTemp(c, typ)\n  body\n  c.freeTemp(tmp)\n\nproc popBlock(c: PCtx; oldLen: int) =\n  for f in c.blocks[oldLen].fixups:\n    c.patch(f)\n  c.blocks.setLen(oldLen)\n\ntemplate withBlock(labl: PSym; body: untyped) {.dirty.} =\n  var oldLen {.gensym.} = c.blocks.len\n  c.blocks.add Block(label: labl, fixups: @[])\n  body\n  popBlock(c, oldLen)\n\nproc gen(c: PCtx; n: PNode; dest: var Dest; flags: TGenFlags = {})\nproc gen(c: PCtx; n: PNode; dest: Register; flags: TGenFlags = {}) =\n  var d: Dest = dest\n  gen(c, n, d, flags)\n  internalAssert d == dest\n\nproc gen(c: PCtx; n: PNode; flags: TGenFlags = {}) =\n  var tmp: Dest = -1\n  gen(c, n, tmp, flags)\n  #if n.typ.isEmptyType: InternalAssert tmp < 0\n\nproc genx(c: PCtx; n: PNode; flags: TGenFlags = {}): Register =\n  var tmp: Dest = -1\n  gen(c, n, tmp, flags)\n  internalAssert tmp >= 0\n  result = Register(tmp)\n\nproc clearDest(c: PCtx; n: PNode; dest: var Dest) {.inline.} =\n  # stmt is different from 'void' in meta programming contexts.\n  # So we only set dest to -1 if 'void':\n  if dest >= 0 and (n.typ.isNil or n.typ.kind == tyVoid):\n    c.freeTemp(dest)\n    dest = -1\n\nproc isNotOpr(n: PNode): bool =\n  n.kind in nkCallKinds and n.sons[0].kind == nkSym and\n    n.sons[0].sym.magic == mNot\n\nproc isTrue(n: PNode): bool =\n  n.kind == nkSym and n.sym.kind == skEnumField and n.sym.position != 0 or\n    n.kind == nkIntLit and n.intVal != 0\n\nproc genWhile(c: PCtx; n: PNode) =\n  # L1:\n  #   cond, tmp\n  #   fjmp tmp, L2\n  #   body\n  #   jmp L1\n  # L2:\n  let L1 = c.genLabel\n  withBlock(nil):\n    if isTrue(n.sons[0]):\n      c.gen(n.sons[1])\n      c.jmpBack(n, L1)\n    elif isNotOpr(n.sons[0]):\n      var tmp = c.genx(n.sons[0].sons[1])\n      let L2 = c.xjmp(n, opcTJmp, tmp)\n      c.freeTemp(tmp)\n      c.gen(n.sons[1])\n      c.jmpBack(n, L1)\n      c.patch(L2)\n    else:\n      var tmp = c.genx(n.sons[0])\n      let L2 = c.xjmp(n, opcFJmp, tmp)\n      c.freeTemp(tmp)\n      c.gen(n.sons[1])\n      c.jmpBack(n, L1)\n      c.patch(L2)\n\nproc genBlock(c: PCtx; n: PNode; dest: var Dest) =\n  withBlock(n.sons[0].sym):\n    c.gen(n.sons[1], dest)\n  c.clearDest(n, dest)\n\nproc genBreak(c: PCtx; n: PNode) =\n  let L1 = c.xjmp(n, opcJmp)\n  if n.sons[0].kind == nkSym:\n    #echo cast[int](n.sons[0].sym)\n    for i in countdown(c.blocks.len-1, 0):\n      if c.blocks[i].label == n.sons[0].sym:\n        c.blocks[i].fixups.add L1\n        return\n    globalError(n.info, errGenerated, \"VM problem: cannot find 'break' target\")\n  else:\n    c.blocks[c.blocks.high].fixups.add L1\n\nproc genIf(c: PCtx, n: PNode; dest: var Dest) =\n  #  if (!expr1) goto L1;\n  #    thenPart\n  #    goto LEnd\n  #  L1:\n  #  if (!expr2) goto L2;\n  #    thenPart2\n  #    goto LEnd\n  #  L2:\n  #    elsePart\n  #  Lend:\n  if dest < 0 and not isEmptyType(n.typ): dest = getTemp(c, n.typ)\n  var endings: seq[Position] = @[]\n  for i in countup(0, len(n) - 1):\n    var it = n.sons[i]\n    if it.len == 2:\n      withTemp(tmp, it.sons[0].typ):\n        var elsePos: Position\n        if isNotOpr(it.sons[0]):\n          c.gen(it.sons[0].sons[1], tmp)\n          elsePos = c.xjmp(it.sons[0].sons[1], opcTJmp, tmp) # if true\n        else:\n          c.gen(it.sons[0], tmp)\n          elsePos = c.xjmp(it.sons[0], opcFJmp, tmp) # if false\n      c.clearDest(n, dest)\n      c.gen(it.sons[1], dest) # then part\n      if i < sonsLen(n)-1:\n        endings.add(c.xjmp(it.sons[1], opcJmp, 0))\n      c.patch(elsePos)\n    else:\n      c.clearDest(n, dest)\n      c.gen(it.sons[0], dest)\n  for endPos in endings: c.patch(endPos)\n  c.clearDest(n, dest)\n\nproc genAndOr(c: PCtx; n: PNode; opc: Opcode; dest: var Dest) =\n  #   asgn dest, a\n  #   tjmp|fjmp L1\n  #   asgn dest, b\n  # L1:\n  if dest < 0: dest = getTemp(c, n.typ)\n  c.gen(n.sons[1], dest)\n  let L1 = c.xjmp(n, opc, dest)\n  c.gen(n.sons[2], dest)\n  c.patch(L1)\n\nproc unused(n: PNode; x: Dest) {.inline.} =\n  if x >= 0:\n    #debug(n)\n    globalError(n.info, \"not unused\")\n\nproc genCase(c: PCtx; n: PNode; dest: var Dest) =\n  #  if (!expr1) goto L1;\n  #    thenPart\n  #    goto LEnd\n  #  L1:\n  #  if (!expr2) goto L2;\n  #    thenPart2\n  #    goto LEnd\n  #  L2:\n  #    elsePart\n  #  Lend:\n  if not isEmptyType(n.typ):\n    if dest < 0: dest = getTemp(c, n.typ)\n  else:\n    unused(n, dest)\n  var endings: seq[Position] = @[]\n  withTemp(tmp, n.sons[0].typ):\n    c.gen(n.sons[0], tmp)\n    # branch tmp, codeIdx\n    # fjmp   elseLabel\n    for i in 1 .. <n.len:\n      let it = n.sons[i]\n      if it.len == 1:\n        # else stmt:\n        c.gen(it.sons[0], dest)\n      else:\n        c.gABx(it, opcBranch, tmp, 0)\n        let elsePos = c.xjmp(it.lastSon, opcFJmp, tmp)\n        c.gen(it.lastSon, dest)\n        if i < sonsLen(n)-1:\n          endings.add(c.xjmp(it.lastSon, opcJmp, 0))\n        c.patch(elsePos)\n      c.clearDest(n, dest)\n  for endPos in endings: c.patch(endPos)\n\nproc genTry(c: PCtx; n: PNode; dest: var Dest) =\n  if dest < 0 and not isEmptyType(n.typ): dest = getTemp(c, n.typ)\n  var endings: seq[Position] = @[]\n  let elsePos = c.xjmp(n, opcTry, 0)\n  c.gen(n.sons[0], dest)\n  c.clearDest(n, dest)\n  c.patch(elsePos)\n  for i in 1 .. <n.len:\n    let it = n.sons[i]\n    if it.kind != nkFinally:\n      var blen = len(it)\n      # first opcExcept contains the end label of the 'except' block:\n      let endExcept = c.xjmp(it, opcExcept, 0)\n      c.gen(it.lastSon, dest)\n      c.clearDest(n, dest)\n      if i < sonsLen(n)-1:\n        endings.add(c.xjmp(it, opcJmp, 0))\n      c.patch(endExcept)\n  for endPos in endings: c.patch(endPos)\n  let fin = lastSon(n)\n  # we always generate an 'opcFinally' as that pops the safepoint\n  # from the stack\n  c.gABx(fin, opcFinally, 0, 0)\n  if fin.kind == nkFinally:\n    c.gen(fin.sons[0])\n    c.clearDest(n, dest)\n  c.gABx(fin, opcFinallyEnd, 0, 0)\n\nproc genRaise(c: PCtx; n: PNode) =\n  let dest = genx(c, n.sons[0])\n  c.gABC(n, opcRaise, dest)\n  c.freeTemp(dest)\n\nproc genReturn(c: PCtx; n: PNode) =\n  if n.sons[0].kind != nkEmpty:\n    gen(c, n.sons[0])\n  c.gABC(n, opcRet)\n\nproc genCall(c: PCtx; n: PNode; dest: var Dest) =\n  for i in 0.. <n.len:\n    c.gen(n.sons[i], dest)\n  c.gABC(n, opcCall, 0, 0, 0)\n\ntemplate isGlobal(s: PSym): bool = sfGlobal in s.flags and s.kind != skForVar\nproc isGlobal(n: PNode): bool = n.kind == nkSym and isGlobal(n.sym)\n\nproc genUnaryABC(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  let tmp = c.genx(n.sons[1])\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABC(n, opc, dest, tmp)\n  c.freeTemp(tmp)\n\nproc genUnaryABI(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  let tmp = c.genx(n.sons[1])\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABI(n, opc, dest, tmp, 0)\n  c.freeTemp(tmp)\n\nproc genBinaryABC(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  let\n    tmp = c.genx(n.sons[1])\n    tmp2 = c.genx(n.sons[2])\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABC(n, opc, dest, tmp, tmp2)\n  c.freeTemp(tmp)\n  c.freeTemp(tmp2)\n\nproc genBinaryABCD(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  let\n    tmp = c.genx(n.sons[1])\n    tmp2 = c.genx(n.sons[2])\n    tmp3 = c.genx(n.sons[3])\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABC(n, opc, dest, tmp, tmp2)\n  c.gABC(n, opc, tmp3)\n  c.freeTemp(tmp)\n  c.freeTemp(tmp2)\n  c.freeTemp(tmp3)\n\nproc genNarrow(c: PCtx; n: PNode; dest: Dest) =\n  let t = skipTypes(n.typ, abstractVar-{tyTypeDesc})\n  # uint is uint64 in the VM, we we only need to mask the result for\n  # other unsigned types:\n  if t.kind in {tyUInt8..tyUInt32}:\n    c.gABC(n, opcNarrowU, dest, Register(t.size*8))\n  elif t.kind in {tyInt8..tyInt32}:\n    c.gABC(n, opcNarrowS, dest, Register(t.size*8))\n\nproc genNarrowU(c: PCtx; n: PNode; dest: Dest) =\n  let t = skipTypes(n.typ, abstractVar-{tyTypeDesc})\n  # uint is uint64 in the VM, we we only need to mask the result for\n  # other unsigned types:\n  if t.kind in {tyUInt8..tyUInt32, tyInt8..tyInt32}:\n    c.gABC(n, opcNarrowU, dest, Register(t.size*8))\n\nproc genBinaryABCnarrow(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  genBinaryABC(c, n, dest, opc)\n  genNarrow(c, n, dest)\n\nproc genBinaryABCnarrowU(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  genBinaryABC(c, n, dest, opc)\n  genNarrowU(c, n, dest)\n\nproc genBinarySet(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  let\n    tmp = c.genx(n.sons[1])\n    tmp2 = c.genx(n.sons[2])\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.genSetType(n.sons[1], tmp)\n  c.genSetType(n.sons[2], tmp2)\n  c.gABC(n, opc, dest, tmp, tmp2)\n  c.freeTemp(tmp)\n  c.freeTemp(tmp2)\n\nproc genBinaryStmt(c: PCtx; n: PNode; opc: Opcode) =\n  let\n    dest = c.genx(n.sons[1])\n    tmp = c.genx(n.sons[2])\n  c.gABC(n, opc, dest, tmp, 0)\n  c.freeTemp(tmp)\n\nproc genBinaryStmtVar(c: PCtx; n: PNode; opc: Opcode) =\n  var x = n.sons[1]\n  if x.kind in {nkAddr, nkHiddenAddr}: x = x.sons[0]\n  let\n    dest = c.genx(x)\n    tmp = c.genx(n.sons[2])\n  c.gABC(n, opc, dest, tmp, 0)\n  #c.genAsgnPatch(n.sons[1], dest)\n  c.freeTemp(tmp)\n\nproc genUnaryStmt(c: PCtx; n: PNode; opc: Opcode) =\n  let tmp = c.genx(n.sons[1])\n  c.gABC(n, opc, tmp, 0, 0)\n  c.freeTemp(tmp)\n\nproc genVarargsABC(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  if dest < 0: dest = getTemp(c, n.typ)\n  var x = c.getTempRange(n.len-1, slotTempStr)\n  for i in 1..n.len-1:\n    var r: TRegister = x+i-1\n    c.gen(n.sons[i], r)\n  c.gABC(n, opc, dest, x, n.len-1)\n  c.freeTempRange(x, n.len)\n\nproc isInt8Lit(n: PNode): bool =\n  if n.kind in {nkCharLit..nkUInt64Lit}:\n    result = n.intVal >= low(int8) and n.intVal <= high(int8)\n\nproc isInt16Lit(n: PNode): bool =\n  if n.kind in {nkCharLit..nkUInt64Lit}:\n    result = n.intVal >= low(int16) and n.intVal <= high(int16)\n\nproc genAddSubInt(c: PCtx; n: PNode; dest: var Dest; opc: Opcode) =\n  if n.sons[2].isInt8Lit:\n    let tmp = c.genx(n.sons[1])\n    if dest < 0: dest = c.getTemp(n.typ)\n    c.gABI(n, succ(opc), dest, tmp, n.sons[2].intVal)\n    c.freeTemp(tmp)\n  else:\n    genBinaryABC(c, n, dest, opc)\n  c.genNarrow(n, dest)\n\nproc genConv(c: PCtx; n, arg: PNode; dest: var Dest; opc=opcConv) =\n  if n.typ.kind == arg.typ.kind and arg.typ.kind == tyProc:\n    # don't do anything for lambda lifting conversions:\n    gen(c, arg, dest)\n    return\n  let tmp = c.genx(arg)\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABC(n, opc, dest, tmp)\n  c.gABx(n, opc, 0, genType(c, n.typ.skipTypes({tyStatic})))\n  c.gABx(n, opc, 0, genType(c, arg.typ.skipTypes({tyStatic})))\n  c.freeTemp(tmp)\n\nproc genCard(c: PCtx; n: PNode; dest: var Dest) =\n  let tmp = c.genx(n.sons[1])\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.genSetType(n.sons[1], tmp)\n  c.gABC(n, opcCard, dest, tmp)\n  c.freeTemp(tmp)\n\nproc genMagic(c: PCtx; n: PNode; dest: var Dest; m: TMagic) =\n  case m\n  of mAnd: c.genAndOr(n, opcFJmp, dest)\n  of mOr:  c.genAndOr(n, opcTJmp, dest)\n  of mUnaryLt:\n    let tmp = c.genx(n.sons[1])\n    if dest < 0: dest = c.getTemp(n.typ)\n    c.gABI(n, opcSubImmInt, dest, tmp, 1)\n    c.freeTemp(tmp)\n  of mPred, mSubI:\n    c.genAddSubInt(n, dest, opcSubInt)\n  of mSucc, mAddI:\n    c.genAddSubInt(n, dest, opcAddInt)\n  of mInc, mDec:\n    unused(n, dest)\n    let opc = if m == mInc: opcAddInt else: opcSubInt\n    let d = c.genx(n.sons[1])\n    if n.sons[2].isInt8Lit:\n      c.gABI(n, succ(opc), d, d, n.sons[2].intVal)\n    else:\n      let tmp = c.genx(n.sons[2])\n      c.gABC(n, opc, d, d, tmp)\n      c.freeTemp(tmp)\n    c.genNarrow(n.sons[1], d)\n    c.genAsgnPatch(n.sons[1], d)\n    c.freeTemp(d)\n  of mOrd, mChr, mArrToSeq: c.gen(n.sons[1], dest)\n  of mNew, mNewFinalize:\n    unused(n, dest)\n    c.genNew(n)\n  of mNewSeq:\n    unused(n, dest)\n    c.genNewSeq(n)\n  of mNewSeqOfCap: c.genNewSeqOfCap(n, dest)\n  of mNewString:\n    genUnaryABC(c, n, dest, opcNewStr)\n    # XXX buggy\n  of mNewStringOfCap:\n    # we ignore the 'cap' argument and translate it as 'newString(0)'.\n    # eval n.sons[1] for possible side effects:\n    var tmp = c.genx(n.sons[1])\n    c.gABx(n, opcLdImmInt, tmp, 0)\n    if dest < 0: dest = c.getTemp(n.typ)\n    c.gABC(n, opcNewStr, dest, tmp)\n    c.freeTemp(tmp)\n    # XXX buggy\n  of mLengthOpenArray, mLengthArray, mLengthSeq, mXLenSeq:\n    genUnaryABI(c, n, dest, opcLenSeq)\n  of mLengthStr, mXLenStr:\n    genUnaryABI(c, n, dest, opcLenStr)\n  of mIncl, mExcl:\n    unused(n, dest)\n    var d = c.genx(n.sons[1])\n    var tmp = c.genx(n.sons[2])\n    c.genSetType(n.sons[1], d)\n    c.gABC(n, if m == mIncl: opcIncl else: opcExcl, d, tmp)\n    c.freeTemp(d)\n    c.freeTemp(tmp)\n  of mCard: genCard(c, n, dest)\n  of mMulI: genBinaryABCnarrow(c, n, dest, opcMulInt)\n  of mDivI: genBinaryABCnarrow(c, n, dest, opcDivInt)\n  of mModI: genBinaryABCnarrow(c, n, dest, opcModInt)\n  of mAddF64: genBinaryABC(c, n, dest, opcAddFloat)\n  of mSubF64: genBinaryABC(c, n, dest, opcSubFloat)\n  of mMulF64: genBinaryABC(c, n, dest, opcMulFloat)\n  of mDivF64: genBinaryABC(c, n, dest, opcDivFloat)\n  of mShrI: genBinaryABCnarrowU(c, n, dest, opcShrInt)\n  of mShlI: genBinaryABCnarrowU(c, n, dest, opcShlInt)\n  of mBitandI: genBinaryABCnarrowU(c, n, dest, opcBitandInt)\n  of mBitorI: genBinaryABCnarrowU(c, n, dest, opcBitorInt)\n  of mBitxorI: genBinaryABCnarrowU(c, n, dest, opcBitxorInt)\n  of mAddU: genBinaryABCnarrowU(c, n, dest, opcAddu)\n  of mSubU: genBinaryABCnarrowU(c, n, dest, opcSubu)\n  of mMulU: genBinaryABCnarrowU(c, n, dest, opcMulu)\n  of mDivU: genBinaryABCnarrowU(c, n, dest, opcDivu)\n  of mModU: genBinaryABCnarrowU(c, n, dest, opcModu)\n  of mEqI, mEqB, mEqEnum, mEqCh:\n    genBinaryABC(c, n, dest, opcEqInt)\n  of mLeI, mLeEnum, mLeCh, mLeB:\n    genBinaryABC(c, n, dest, opcLeInt)\n  of mLtI, mLtEnum, mLtCh, mLtB:\n    genBinaryABC(c, n, dest, opcLtInt)\n  of mEqF64: genBinaryABC(c, n, dest, opcEqFloat)\n  of mLeF64: genBinaryABC(c, n, dest, opcLeFloat)\n  of mLtF64: genBinaryABC(c, n, dest, opcLtFloat)\n  of mLePtr, mLeU, mLeU64: genBinaryABC(c, n, dest, opcLeu)\n  of mLtPtr, mLtU, mLtU64: genBinaryABC(c, n, dest, opcLtu)\n  of mEqProc, mEqRef, mEqUntracedRef:\n    genBinaryABC(c, n, dest, opcEqRef)\n  of mXor: genBinaryABCnarrowU(c, n, dest, opcXor)\n  of mNot: genUnaryABC(c, n, dest, opcNot)\n  of mUnaryMinusI, mUnaryMinusI64:\n    genUnaryABC(c, n, dest, opcUnaryMinusInt)\n    genNarrow(c, n, dest)\n  of mUnaryMinusF64: genUnaryABC(c, n, dest, opcUnaryMinusFloat)\n  of mUnaryPlusI, mUnaryPlusF64: gen(c, n.sons[1], dest)\n  of mBitnotI:\n    genUnaryABC(c, n, dest, opcBitnotInt)\n    genNarrowU(c, n, dest)\n  of mZe8ToI, mZe8ToI64, mZe16ToI, mZe16ToI64, mZe32ToI64, mZeIToI64,\n     mToU8, mToU16, mToU32, mToFloat, mToBiggestFloat, mToInt,\n     mToBiggestInt, mCharToStr, mBoolToStr, mIntToStr, mInt64ToStr,\n     mFloatToStr, mCStrToStr, mStrToStr, mEnumToStr:\n    genConv(c, n, n.sons[1], dest)\n  of mEqStr, mEqCString: genBinaryABC(c, n, dest, opcEqStr)\n  of mLeStr: genBinaryABC(c, n, dest, opcLeStr)\n  of mLtStr: genBinaryABC(c, n, dest, opcLtStr)\n  of mEqSet: genBinarySet(c, n, dest, opcEqSet)\n  of mLeSet: genBinarySet(c, n, dest, opcLeSet)\n  of mLtSet: genBinarySet(c, n, dest, opcLtSet)\n  of mMulSet: genBinarySet(c, n, dest, opcMulSet)\n  of mPlusSet: genBinarySet(c, n, dest, opcPlusSet)\n  of mMinusSet: genBinarySet(c, n, dest, opcMinusSet)\n  of mSymDiffSet: genBinarySet(c, n, dest, opcSymdiffSet)\n  of mConStrStr: genVarargsABC(c, n, dest, opcConcatStr)\n  of mInSet: genBinarySet(c, n, dest, opcContainsSet)\n  of mRepr: genUnaryABC(c, n, dest, opcRepr)\n  of mExit:\n    unused(n, dest)\n    var tmp = c.genx(n.sons[1])\n    c.gABC(n, opcQuit, tmp)\n    c.freeTemp(tmp)\n  of mSetLengthStr, mSetLengthSeq:\n    unused(n, dest)\n    var d = c.genx(n.sons[1])\n    var tmp = c.genx(n.sons[2])\n    c.gABC(n, if m == mSetLengthStr: opcSetLenStr else: opcSetLenSeq, d, tmp)\n    c.genAsgnPatch(n.sons[1], d)\n    c.freeTemp(tmp)\n  of mSwap:\n    unused(n, dest)\n    c.gen(lowerSwap(n, if c.prc == nil: c.module else: c.prc.sym))\n  of mIsNil: genUnaryABC(c, n, dest, opcIsNil)\n  of mCopyStr:\n    if dest < 0: dest = c.getTemp(n.typ)\n    var\n      tmp1 = c.genx(n.sons[1])\n      tmp2 = c.genx(n.sons[2])\n      tmp3 = c.getTemp(n.sons[2].typ)\n    c.gABC(n, opcLenStr, tmp3, tmp1)\n    c.gABC(n, opcSubStr, dest, tmp1, tmp2)\n    c.gABC(n, opcSubStr, tmp3)\n    c.freeTemp(tmp1)\n    c.freeTemp(tmp2)\n    c.freeTemp(tmp3)\n  of mCopyStrLast:\n    if dest < 0: dest = c.getTemp(n.typ)\n    var\n      tmp1 = c.genx(n.sons[1])\n      tmp2 = c.genx(n.sons[2])\n      tmp3 = c.genx(n.sons[3])\n    c.gABC(n, opcSubStr, dest, tmp1, tmp2)\n    c.gABC(n, opcSubStr, tmp3)\n    c.freeTemp(tmp1)\n    c.freeTemp(tmp2)\n    c.freeTemp(tmp3)\n  of mParseBiggestFloat:\n    if dest < 0: dest = c.getTemp(n.typ)\n    var d2: TRegister\n    # skip 'nkHiddenAddr':\n    let d2AsNode = n.sons[2].sons[0]\n    if needsAsgnPatch(d2AsNode):\n      d2 = c.getTemp(getSysType(tyFloat))\n    else:\n      d2 = c.genx(d2AsNode)\n    var\n      tmp1 = c.genx(n.sons[1])\n      tmp3 = c.genx(n.sons[3])\n    c.gABC(n, opcParseFloat, dest, tmp1, d2)\n    c.gABC(n, opcParseFloat, tmp3)\n    c.freeTemp(tmp1)\n    c.freeTemp(tmp3)\n    c.genAsgnPatch(d2AsNode, d2)\n    c.freeTemp(d2)\n  of mReset:\n    unused(n, dest)\n    var d = c.genx(n.sons[1])\n    c.gABC(n, opcReset, d)\n  of mOf, mIs:\n    if dest < 0: dest = c.getTemp(n.typ)\n    var tmp = c.genx(n.sons[1])\n    var idx = c.getTemp(getSysType(tyInt))\n    var typ = n.sons[2].typ\n    if m == mOf: typ = typ.skipTypes(abstractPtrs-{tyTypeDesc})\n    c.gABx(n, opcLdImmInt, idx, c.genType(typ))\n    c.gABC(n, if m == mOf: opcOf else: opcIs, dest, tmp, idx)\n    c.freeTemp(tmp)\n    c.freeTemp(idx)\n  of mSizeOf:\n    globalError(n.info, errCannotInterpretNodeX, renderTree(n))\n  of mHigh:\n    if dest < 0: dest = c.getTemp(n.typ)\n    let tmp = c.genx(n.sons[1])\n    case n.sons[1].typ.skipTypes(abstractVar-{tyTypeDesc}).kind:\n    of tyString, tyCString:\n      c.gABI(n, opcLenStr, dest, tmp, 1)\n    else:\n      c.gABI(n, opcLenSeq, dest, tmp, 1)\n    c.freeTemp(tmp)\n  of mEcho:\n    unused(n, dest)\n    let n = n[1].skipConv\n    let x = c.getTempRange(n.len, slotTempUnknown)\n    internalAssert n.kind == nkBracket\n    for i in 0.. <n.len:\n      var r: TRegister = x+i\n      c.gen(n.sons[i], r)\n    c.gABC(n, opcEcho, x, n.len)\n    c.freeTempRange(x, n.len)\n  of mAppendStrCh:\n    unused(n, dest)\n    genBinaryStmtVar(c, n, opcAddStrCh)\n  of mAppendStrStr:\n    unused(n, dest)\n    genBinaryStmtVar(c, n, opcAddStrStr)\n  of mAppendSeqElem:\n    unused(n, dest)\n    genBinaryStmtVar(c, n, opcAddSeqElem)\n  of mParseExprToAst:\n    genUnaryABC(c, n, dest, opcParseExprToAst)\n  of mParseStmtToAst:\n    genUnaryABC(c, n, dest, opcParseStmtToAst)\n  of mTypeTrait:\n    let tmp = c.genx(n.sons[1])\n    if dest < 0: dest = c.getTemp(n.typ)\n    c.gABx(n, opcSetType, tmp, c.genType(n.sons[1].typ))\n    c.gABC(n, opcTypeTrait, dest, tmp)\n    c.freeTemp(tmp)\n  of mSlurp: genUnaryABC(c, n, dest, opcSlurp)\n  of mStaticExec: genBinaryABCD(c, n, dest, opcGorge)\n  of mNLen: genUnaryABI(c, n, dest, opcLenSeq)\n  of mGetImpl: genUnaryABC(c, n, dest, opcGetImpl)\n  of mNChild: genBinaryABC(c, n, dest, opcNChild)\n  of mNSetChild, mNDel:\n    unused(n, dest)\n    var\n      tmp1 = c.genx(n.sons[1])\n      tmp2 = c.genx(n.sons[2])\n      tmp3 = c.genx(n.sons[3])\n    c.gABC(n, if m == mNSetChild: opcNSetChild else: opcNDel, tmp1, tmp2, tmp3)\n    c.freeTemp(tmp1)\n    c.freeTemp(tmp2)\n    c.freeTemp(tmp3)\n  of mNAdd: genBinaryABC(c, n, dest, opcNAdd)\n  of mNAddMultiple: genBinaryABC(c, n, dest, opcNAddMultiple)\n  of mNKind: genUnaryABC(c, n, dest, opcNKind)\n  of mNIntVal: genUnaryABC(c, n, dest, opcNIntVal)\n  of mNFloatVal: genUnaryABC(c, n, dest, opcNFloatVal)\n  of mNSymbol: genUnaryABC(c, n, dest, opcNSymbol)\n  of mNIdent: genUnaryABC(c, n, dest, opcNIdent)\n  of mNGetType:\n    let tmp = c.genx(n.sons[1])\n    if dest < 0: dest = c.getTemp(n.typ)\n    let rc = case n[0].sym.name.s:\n      of \"getType\": 0\n      of \"typeKind\": 1\n      of \"getTypeInst\": 2\n      else: 3  # \"getTypeImpl\"\n    c.gABC(n, opcNGetType, dest, tmp, rc)\n    c.freeTemp(tmp)\n    #genUnaryABC(c, n, dest, opcNGetType)\n  of mNStrVal: genUnaryABC(c, n, dest, opcNStrVal)\n  of mNSetIntVal:\n    unused(n, dest)\n    genBinaryStmt(c, n, opcNSetIntVal)\n  of mNSetFloatVal:\n    unused(n, dest)\n    genBinaryStmt(c, n, opcNSetFloatVal)\n  of mNSetSymbol:\n    unused(n, dest)\n    genBinaryStmt(c, n, opcNSetSymbol)\n  of mNSetIdent:\n    unused(n, dest)\n    genBinaryStmt(c, n, opcNSetIdent)\n  of mNSetType:\n    unused(n, dest)\n    genBinaryStmt(c, n, opcNSetType)\n  of mNSetStrVal:\n    unused(n, dest)\n    genBinaryStmt(c, n, opcNSetStrVal)\n  of mNNewNimNode: genBinaryABC(c, n, dest, opcNNewNimNode)\n  of mNCopyNimNode: genUnaryABC(c, n, dest, opcNCopyNimNode)\n  of mNCopyNimTree: genUnaryABC(c, n, dest, opcNCopyNimTree)\n  of mNBindSym:\n    if n[1].kind in {nkClosedSymChoice, nkOpenSymChoice, nkSym}:\n      let idx = c.genLiteral(n[1])\n      if dest < 0: dest = c.getTemp(n.typ)\n      c.gABx(n, opcNBindSym, dest, idx)\n    else:\n      localError(n.info, \"invalid bindSym usage\")\n  of mStrToIdent: genUnaryABC(c, n, dest, opcStrToIdent)\n  of mIdentToStr: genUnaryABC(c, n, dest, opcIdentToStr)\n  of mEqIdent: genBinaryABC(c, n, dest, opcEqIdent)\n  of mEqNimrodNode: genBinaryABC(c, n, dest, opcEqNimrodNode)\n  of mSameNodeType: genBinaryABC(c, n, dest, opcSameNodeType)\n  of mNLineInfo: genUnaryABC(c, n, dest, opcNLineInfo)\n  of mNHint:\n    unused(n, dest)\n    genUnaryStmt(c, n, opcNHint)\n  of mNWarning:\n    unused(n, dest)\n    genUnaryStmt(c, n, opcNWarning)\n  of mNError:\n    if n.len <= 1:\n      # query error condition:\n      c.gABC(n, opcQueryErrorFlag, dest)\n    else:\n      # setter\n      unused(n, dest)\n      genBinaryStmt(c, n, opcNError)\n  of mNCallSite:\n    if dest < 0: dest = c.getTemp(n.typ)\n    c.gABC(n, opcCallSite, dest)\n  of mNGenSym: genBinaryABC(c, n, dest, opcGenSym)\n  of mMinI, mMaxI, mAbsF64, mMinF64, mMaxF64, mAbsI,\n     mDotDot:\n    c.genCall(n, dest)\n  of mExpandToAst:\n    if n.len != 2:\n      globalError(n.info, errGenerated, \"expandToAst requires 1 argument\")\n    let arg = n.sons[1]\n    if arg.kind in nkCallKinds:\n      #if arg[0].kind != nkSym or arg[0].sym.kind notin {skTemplate, skMacro}:\n      #      \"ExpandToAst: expanded symbol is no macro or template\"\n      if dest < 0: dest = c.getTemp(n.typ)\n      c.genCall(arg, dest)\n      # do not call clearDest(n, dest) here as getAst has a meta-type as such\n      # produces a value\n    else:\n      globalError(n.info, \"expandToAst requires a call expression\")\n  else:\n    # mGCref, mGCunref,\n    globalError(n.info, \"cannot generate code for: \" & $m)\n\nconst\n  atomicTypes = {tyBool, tyChar,\n    tyExpr, tyStmt, tyTypeDesc, tyStatic,\n    tyEnum,\n    tyOrdinal,\n    tyRange,\n    tyProc,\n    tyPointer, tyOpenArray,\n    tyString, tyCString,\n    tyInt, tyInt8, tyInt16, tyInt32, tyInt64,\n    tyFloat, tyFloat32, tyFloat64, tyFloat128,\n    tyUInt, tyUInt8, tyUInt16, tyUInt32, tyUInt64}\n\nproc fitsRegister*(t: PType): bool =\n  assert t != nil\n  t.skipTypes(abstractInst-{tyTypeDesc}).kind in {\n    tyRange, tyEnum, tyBool, tyInt..tyUInt64, tyChar}\n\nproc unneededIndirection(n: PNode): bool =\n  n.typ.skipTypes(abstractInst-{tyTypeDesc}).kind == tyRef\n\nproc canElimAddr(n: PNode): PNode =\n  case n.sons[0].kind\n  of nkObjUpConv, nkObjDownConv, nkChckRange, nkChckRangeF, nkChckRange64:\n    var m = n.sons[0].sons[0]\n    if m.kind in {nkDerefExpr, nkHiddenDeref}:\n      # addr ( nkConv ( deref ( x ) ) ) --> nkConv(x)\n      result = copyNode(n.sons[0])\n      result.add m.sons[0]\n  of nkHiddenStdConv, nkHiddenSubConv, nkConv:\n    var m = n.sons[0].sons[1]\n    if m.kind in {nkDerefExpr, nkHiddenDeref}:\n      # addr ( nkConv ( deref ( x ) ) ) --> nkConv(x)\n      result = copyNode(n.sons[0])\n      result.add m.sons[0]\n  else:\n    if n.sons[0].kind in {nkDerefExpr, nkHiddenDeref}:\n      # addr ( deref ( x )) --> x\n      result = n.sons[0].sons[0]\n\nproc genAddrDeref(c: PCtx; n: PNode; dest: var Dest; opc: Opcode;\n                  flags: TGenFlags) =\n  # a nop for certain types\n  let isAddr = opc in {opcAddrNode, opcAddrReg}\n  if isAddr and (let m = canElimAddr(n); m != nil):\n    gen(c, m, dest, flags)\n    return\n\n  let af = if n[0].kind in {nkBracketExpr, nkDotExpr, nkCheckedFieldExpr}: {gfAddrOf, gfFieldAccess}\n           else: {gfAddrOf}\n  let newflags = if isAddr: flags+af else: flags\n  # consider:\n  # proc foo(f: var ref int) =\n  #   f = new(int)\n  # proc blah() =\n  #   var x: ref int\n  #   foo x\n  #\n  # The type of 'f' is 'var ref int' and of 'x' is 'ref int'. Hence for\n  # nkAddr we must not use 'unneededIndirection', but for deref we use it.\n  if not isAddr and unneededIndirection(n.sons[0]):\n    gen(c, n.sons[0], dest, newflags)\n    if gfAddrOf notin flags and fitsRegister(n.typ):\n      c.gABC(n, opcNodeToReg, dest, dest)\n  elif isAddr and isGlobal(n.sons[0]):\n    gen(c, n.sons[0], dest, flags+af)\n  else:\n    let tmp = c.genx(n.sons[0], newflags)\n    if dest < 0: dest = c.getTemp(n.typ)\n    if not isAddr:\n      gABC(c, n, opc, dest, tmp)\n      assert n.typ != nil\n      if gfAddrOf notin flags and fitsRegister(n.typ):\n        c.gABC(n, opcNodeToReg, dest, dest)\n    elif c.prc.slots[tmp].kind >= slotTempUnknown:\n      gABC(c, n, opcAddrNode, dest, tmp)\n      # hack ahead; in order to fix bug #1781 we mark the temporary as\n      # permanent, so that it's not used for anything else:\n      c.prc.slots[tmp].kind = slotTempPerm\n      # XXX this is still a hack\n      #message(n.info, warnUser, \"suspicious opcode used\")\n    else:\n      gABC(c, n, opcAddrReg, dest, tmp)\n    c.freeTemp(tmp)\n\nproc whichAsgnOpc(n: PNode): Opcode =\n  case n.typ.skipTypes(abstractRange-{tyTypeDesc}).kind\n  of tyBool, tyChar, tyEnum, tyOrdinal, tyInt..tyInt64, tyUInt..tyUInt64:\n    opcAsgnInt\n  of tyString, tyCString:\n    opcAsgnStr\n  of tyFloat..tyFloat128:\n    opcAsgnFloat\n  of tyRef, tyNil, tyVar:\n    opcAsgnRef\n  else:\n    opcAsgnComplex\n\nproc whichAsgnOpc(n: PNode; opc: Opcode): Opcode = opc\n\nproc genAsgn(c: PCtx; dest: Dest; ri: PNode; requiresCopy: bool) =\n  let tmp = c.genx(ri)\n  assert dest >= 0\n  gABC(c, ri, whichAsgnOpc(ri), dest, tmp, 1-ord(requiresCopy))\n  c.freeTemp(tmp)\n\nproc setSlot(c: PCtx; v: PSym) =\n  # XXX generate type initialization here?\n  if v.position == 0:\n    if c.prc.maxSlots == 0: c.prc.maxSlots = 1\n    if c.prc.maxSlots >= high(TRegister):\n      globalError(v.info, \"cannot generate code; too many registers required\")\n    v.position = c.prc.maxSlots\n    c.prc.slots[v.position] = (inUse: true,\n        kind: if v.kind == skLet: slotFixedLet else: slotFixedVar)\n    inc c.prc.maxSlots\n\nproc cannotEval(n: PNode) {.noinline.} =\n  globalError(n.info, errGenerated, \"cannot evaluate at compile time: \" &\n    n.renderTree)\n\nproc isOwnedBy(a, b: PSym): bool =\n  var a = a.owner\n  while a != nil and a.kind != skModule:\n    if a == b: return true\n    a = a.owner\n\nproc getOwner(c: PCtx): PSym =\n  result = c.prc.sym\n  if result.isNil: result = c.module\n\nproc checkCanEval(c: PCtx; n: PNode) =\n  # we need to ensure that we don't evaluate 'x' here:\n  # proc foo() = var x ...\n  let s = n.sym\n  if {sfCompileTime, sfGlobal} <= s.flags: return\n  if s.kind in {skVar, skTemp, skLet, skParam, skResult} and\n      not s.isOwnedBy(c.prc.sym) and s.owner != c.module and c.mode != emRepl:\n    cannotEval(n)\n  elif s.kind in {skProc, skConverter, skMethod,\n                  skIterator} and sfForward in s.flags:\n    cannotEval(n)\n\nproc isTemp(c: PCtx; dest: Dest): bool =\n  result = dest >= 0 and c.prc.slots[dest].kind >= slotTempUnknown\n\ntemplate needsAdditionalCopy(n): untyped =\n  not c.isTemp(dest) and not fitsRegister(n.typ)\n\nproc preventFalseAlias(c: PCtx; n: PNode; opc: Opcode;\n                       dest, idx, value: TRegister) =\n  # opcLdObj et al really means \"load address\". We sometimes have to create a\n  # copy in order to not introduce false aliasing:\n  # mylocal = a.b  # needs a copy of the data!\n  assert n.typ != nil\n  if needsAdditionalCopy(n):\n    var cc = c.getTemp(n.typ)\n    c.gABC(n, whichAsgnOpc(n), cc, value, 0)\n    c.gABC(n, opc, dest, idx, cc)\n    c.freeTemp(cc)\n  else:\n    c.gABC(n, opc, dest, idx, value)\n\nproc genAsgn(c: PCtx; le, ri: PNode; requiresCopy: bool) =\n  case le.kind\n  of nkBracketExpr:\n    let dest = c.genx(le.sons[0], {gfAddrOf, gfFieldAccess})\n    let idx = c.genIndex(le.sons[1], le.sons[0].typ)\n    let tmp = c.genx(ri)\n    if le.sons[0].typ.skipTypes(abstractVarRange-{tyTypeDesc}).kind in {\n        tyString, tyCString}:\n      c.preventFalseAlias(le, opcWrStrIdx, dest, idx, tmp)\n    else:\n      c.preventFalseAlias(le, opcWrArr, dest, idx, tmp)\n    c.freeTemp(tmp)\n  of nkDotExpr, nkCheckedFieldExpr:\n    # XXX field checks here\n    let left = if le.kind == nkDotExpr: le else: le.sons[0]\n    let dest = c.genx(left.sons[0], {gfAddrOf, gfFieldAccess})\n    let idx = genField(left.sons[1])\n    let tmp = c.genx(ri)\n    c.preventFalseAlias(left, opcWrObj, dest, idx, tmp)\n    c.freeTemp(tmp)\n  of nkDerefExpr, nkHiddenDeref:\n    let dest = c.genx(le.sons[0], {gfAddrOf})\n    let tmp = c.genx(ri)\n    c.preventFalseAlias(le, opcWrDeref, dest, 0, tmp)\n    c.freeTemp(tmp)\n  of nkSym:\n    let s = le.sym\n    checkCanEval(c, le)\n    if s.isGlobal:\n      withTemp(tmp, le.typ):\n        c.gen(le, tmp, {gfAddrOf})\n        let val = c.genx(ri)\n        c.preventFalseAlias(le, opcWrDeref, tmp, 0, val)\n        c.freeTemp(val)\n    else:\n      if s.kind == skForVar: c.setSlot s\n      internalAssert s.position > 0 or (s.position == 0 and\n                                        s.kind in {skParam,skResult})\n      var dest: TRegister = s.position + ord(s.kind == skParam)\n      assert le.typ != nil\n      if needsAdditionalCopy(le) and s.kind in {skResult, skVar, skParam}:\n        var cc = c.getTemp(le.typ)\n        gen(c, ri, cc)\n        c.gABC(le, whichAsgnOpc(le), dest, cc, 1)\n        c.freeTemp(cc)\n      else:\n        gen(c, ri, dest)\n  else:\n    let dest = c.genx(le, {gfAddrOf})\n    genAsgn(c, dest, ri, requiresCopy)\n\nproc genTypeLit(c: PCtx; t: PType; dest: var Dest) =\n  var n = newNode(nkType)\n  n.typ = t\n  genLit(c, n, dest)\n\nproc importcSym(c: PCtx; info: TLineInfo; s: PSym) =\n  when hasFFI:\n    if allowFFI in c.features:\n      c.globals.add(importcSymbol(s))\n      s.position = c.globals.len\n    else:\n      localError(info, errGenerated, \"VM is not allowed to 'importc'\")\n  else:\n    localError(info, errGenerated,\n               \"cannot 'importc' variable at compile time\")\n\nproc getNullValue*(typ: PType, info: TLineInfo): PNode\n\nproc genGlobalInit(c: PCtx; n: PNode; s: PSym) =\n  c.globals.add(getNullValue(s.typ, n.info))\n  s.position = c.globals.len\n  # This is rather hard to support, due to the laziness of the VM code\n  # generator. See tests/compile/tmacro2 for why this is necessary:\n  #   var decls{.compileTime.}: seq[NimNode] = @[]\n  let dest = c.getTemp(s.typ)\n  c.gABx(n, opcLdGlobal, dest, s.position)\n  if s.ast != nil:\n    let tmp = c.genx(s.ast)\n    c.preventFalseAlias(n, opcWrDeref, dest, 0, tmp)\n    c.freeTemp(dest)\n    c.freeTemp(tmp)\n\nproc genRdVar(c: PCtx; n: PNode; dest: var Dest; flags: TGenFlags) =\n  let s = n.sym\n  if s.isGlobal:\n    if sfCompileTime in s.flags or c.mode == emRepl:\n      discard\n    elif s.position == 0:\n      cannotEval(n)\n    if s.position == 0:\n      if sfImportc in s.flags: c.importcSym(n.info, s)\n      else: genGlobalInit(c, n, s)\n    if dest < 0: dest = c.getTemp(n.typ)\n    assert s.typ != nil\n    if gfAddrOf notin flags and fitsRegister(s.typ):\n      var cc = c.getTemp(n.typ)\n      c.gABx(n, opcLdGlobal, cc, s.position)\n      c.gABC(n, opcNodeToReg, dest, cc)\n      c.freeTemp(cc)\n    elif {gfAddrOf, gfFieldAccess} * flags == {gfAddrOf}:\n      c.gABx(n, opcLdGlobalAddr, dest, s.position)\n    else:\n      c.gABx(n, opcLdGlobal, dest, s.position)\n  else:\n    if s.kind == skForVar and c.mode == emRepl: c.setSlot(s)\n    if s.position > 0 or (s.position == 0 and\n                          s.kind in {skParam,skResult}):\n      if dest < 0:\n        dest = s.position + ord(s.kind == skParam)\n        internalAssert(c.prc.slots[dest].kind < slotSomeTemp)\n      else:\n        # we need to generate an assignment:\n        genAsgn(c, dest, n, c.prc.slots[dest].kind >= slotSomeTemp)\n    else:\n      # see tests/t99bott for an example that triggers it:\n      cannotEval(n)\n\ntemplate needsRegLoad(): untyped =\n  gfAddrOf notin flags and fitsRegister(n.typ.skipTypes({tyVar}))\n\nproc genArrAccess2(c: PCtx; n: PNode; dest: var Dest; opc: Opcode;\n                   flags: TGenFlags) =\n  let a = c.genx(n.sons[0], flags)\n  let b = c.genIndex(n.sons[1], n.sons[0].typ)\n  if dest < 0: dest = c.getTemp(n.typ)\n  if needsRegLoad():\n    var cc = c.getTemp(n.typ)\n    c.gABC(n, opc, cc, a, b)\n    c.gABC(n, opcNodeToReg, dest, cc)\n    c.freeTemp(cc)\n  else:\n    #message(n.info, warnUser, \"argh\")\n    #echo \"FLAGS \", flags, \" \", fitsRegister(n.typ), \" \", typeToString(n.typ)\n    c.gABC(n, opc, dest, a, b)\n  c.freeTemp(a)\n  c.freeTemp(b)\n\nproc genObjAccess(c: PCtx; n: PNode; dest: var Dest; flags: TGenFlags) =\n  let a = c.genx(n.sons[0], flags)\n  let b = genField(n.sons[1])\n  if dest < 0: dest = c.getTemp(n.typ)\n  if needsRegLoad():\n    var cc = c.getTemp(n.typ)\n    c.gABC(n, opcLdObj, cc, a, b)\n    c.gABC(n, opcNodeToReg, dest, cc)\n    c.freeTemp(cc)\n  else:\n    c.gABC(n, opcLdObj, dest, a, b)\n  c.freeTemp(a)\n\nproc genCheckedObjAccess(c: PCtx; n: PNode; dest: var Dest; flags: TGenFlags) =\n  # XXX implement field checks!\n  genObjAccess(c, n.sons[0], dest, flags)\n\nproc genArrAccess(c: PCtx; n: PNode; dest: var Dest; flags: TGenFlags) =\n  let arrayType = n.sons[0].typ.skipTypes(abstractVarRange-{tyTypeDesc}).kind\n  if arrayType in {tyString, tyCString}:\n    genArrAccess2(c, n, dest, opcLdStrIdx, {})\n  elif arrayType == tyTypeDesc:\n    c.genTypeLit(n.typ, dest)\n  else:\n    genArrAccess2(c, n, dest, opcLdArr, flags)\n\nproc getNullValueAux(obj: PNode, result: PNode) =\n  case obj.kind\n  of nkRecList:\n    for i in countup(0, sonsLen(obj) - 1): getNullValueAux(obj.sons[i], result)\n  of nkRecCase:\n    getNullValueAux(obj.sons[0], result)\n    for i in countup(1, sonsLen(obj) - 1):\n      getNullValueAux(lastSon(obj.sons[i]), result)\n  of nkSym:\n    let field = newNodeI(nkExprColonExpr, result.info)\n    field.add(obj)\n    field.add(getNullValue(obj.sym.typ, result.info))\n    addSon(result, field)\n  else: globalError(result.info, \"cannot create null element for: \" & $obj)\n\nproc getNullValue(typ: PType, info: TLineInfo): PNode =\n  var t = skipTypes(typ, abstractRange-{tyTypeDesc})\n  result = emptyNode\n  case t.kind\n  of tyBool, tyEnum, tyChar, tyInt..tyInt64:\n    result = newNodeIT(nkIntLit, info, t)\n  of tyUInt..tyUInt64:\n    result = newNodeIT(nkUIntLit, info, t)\n  of tyFloat..tyFloat128:\n    result = newNodeIT(nkFloatLit, info, t)\n  of tyCString, tyString:\n    result = newNodeIT(nkStrLit, info, t)\n  of tyVar, tyPointer, tyPtr, tySequence, tyExpr,\n     tyStmt, tyTypeDesc, tyStatic, tyRef, tyNil:\n    result = newNodeIT(nkNilLit, info, t)\n  of tyProc:\n    if t.callConv != ccClosure:\n      result = newNodeIT(nkNilLit, info, t)\n    else:\n      result = newNodeIT(nkPar, info, t)\n      result.add(newNodeIT(nkNilLit, info, t))\n      result.add(newNodeIT(nkNilLit, info, t))\n  of tyObject:\n    result = newNodeIT(nkObjConstr, info, t)\n    result.add(newNodeIT(nkEmpty, info, t))\n    # initialize inherited fields:\n    var base = t.sons[0]\n    while base != nil:\n      getNullValueAux(skipTypes(base, skipPtrs).n, result)\n      base = base.sons[0]\n    getNullValueAux(t.n, result)\n  of tyArray:\n    result = newNodeIT(nkBracket, info, t)\n    for i in countup(0, int(lengthOrd(t)) - 1):\n      addSon(result, getNullValue(elemType(t), info))\n  of tyTuple:\n    result = newNodeIT(nkPar, info, t)\n    for i in countup(0, sonsLen(t) - 1):\n      addSon(result, getNullValue(t.sons[i], info))\n  of tySet:\n    result = newNodeIT(nkCurly, info, t)\n  else:\n    globalError(info, \"cannot create null element for: \" & $t.kind)\n\nproc ldNullOpcode(t: PType): Opcode =\n  assert t != nil\n  if fitsRegister(t): opcLdNullReg else: opcLdNull\n\nproc genVarSection(c: PCtx; n: PNode) =\n  for a in n:\n    if a.kind == nkCommentStmt: continue\n    #assert(a.sons[0].kind == nkSym) can happen for transformed vars\n    if a.kind == nkVarTuple:\n      for i in 0 .. a.len-3:\n        setSlot(c, a[i].sym)\n        checkCanEval(c, a[i])\n      c.gen(lowerTupleUnpacking(a, c.getOwner))\n    elif a.sons[0].kind == nkSym:\n      let s = a.sons[0].sym\n      checkCanEval(c, a.sons[0])\n      if s.isGlobal:\n        if s.position == 0:\n          if sfImportc in s.flags: c.importcSym(a.info, s)\n          else:\n            let sa = getNullValue(s.typ, a.info)\n            #if s.ast.isNil: getNullValue(s.typ, a.info)\n            #else: canonValue(s.ast)\n            assert sa.kind != nkCall\n            c.globals.add(sa)\n            s.position = c.globals.len\n        if a.sons[2].kind != nkEmpty:\n          let tmp = c.genx(a.sons[0], {gfAddrOf})\n          let val = c.genx(a.sons[2])\n          c.preventFalseAlias(a.sons[2], opcWrDeref, tmp, 0, val)\n          c.freeTemp(val)\n          c.freeTemp(tmp)\n      else:\n        setSlot(c, s)\n        if a.sons[2].kind == nkEmpty:\n          c.gABx(a, ldNullOpcode(s.typ), s.position, c.genType(s.typ))\n        else:\n          assert s.typ != nil\n          if not fitsRegister(s.typ):\n            c.gABx(a, ldNullOpcode(s.typ), s.position, c.genType(s.typ))\n          let le = a.sons[0]\n          assert le.typ != nil\n          if not fitsRegister(le.typ) and s.kind in {skResult, skVar, skParam}:\n            var cc = c.getTemp(le.typ)\n            gen(c, a.sons[2], cc)\n            c.gABC(le, whichAsgnOpc(le), s.position.TRegister, cc, 1)\n            c.freeTemp(cc)\n          else:\n            gen(c, a.sons[2], s.position.TRegister)\n    else:\n      # assign to a.sons[0]; happens for closures\n      if a.sons[2].kind == nkEmpty:\n        let tmp = genx(c, a.sons[0])\n        c.gABx(a, ldNullOpcode(a[0].typ), tmp, c.genType(a.sons[0].typ))\n        c.freeTemp(tmp)\n      else:\n        genAsgn(c, a.sons[0], a.sons[2], true)\n\nproc genArrayConstr(c: PCtx, n: PNode, dest: var Dest) =\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABx(n, opcLdNull, dest, c.genType(n.typ))\n\n  let intType = getSysType(tyInt)\n  let seqType = n.typ.skipTypes(abstractVar-{tyTypeDesc})\n  if seqType.kind == tySequence:\n    var tmp = c.getTemp(intType)\n    c.gABx(n, opcLdImmInt, tmp, n.len)\n    c.gABx(n, opcNewSeq, dest, c.genType(seqType))\n    c.gABx(n, opcNewSeq, tmp, 0)\n    c.freeTemp(tmp)\n\n  if n.len > 0:\n    var tmp = getTemp(c, intType)\n    c.gABx(n, opcLdNullReg, tmp, c.genType(intType))\n    for x in n:\n      let a = c.genx(x)\n      c.preventFalseAlias(n, whichAsgnOpc(x, opcWrArr), dest, tmp, a)\n      c.gABI(n, opcAddImmInt, tmp, tmp, 1)\n      c.freeTemp(a)\n    c.freeTemp(tmp)\n\nproc genSetConstr(c: PCtx, n: PNode, dest: var Dest) =\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABx(n, opcLdNull, dest, c.genType(n.typ))\n  for x in n:\n    if x.kind == nkRange:\n      let a = c.genx(x.sons[0])\n      let b = c.genx(x.sons[1])\n      c.gABC(n, opcInclRange, dest, a, b)\n      c.freeTemp(b)\n      c.freeTemp(a)\n    else:\n      let a = c.genx(x)\n      c.gABC(n, opcIncl, dest, a)\n      c.freeTemp(a)\n\nproc genObjConstr(c: PCtx, n: PNode, dest: var Dest) =\n  if dest < 0: dest = c.getTemp(n.typ)\n  let t = n.typ.skipTypes(abstractRange-{tyTypeDesc})\n  if t.kind == tyRef:\n    c.gABx(n, opcNew, dest, c.genType(t.sons[0]))\n  else:\n    c.gABx(n, opcLdNull, dest, c.genType(n.typ))\n  for i in 1.. <n.len:\n    let it = n.sons[i]\n    if it.kind == nkExprColonExpr and it.sons[0].kind == nkSym:\n      let idx = genField(it.sons[0])\n      let tmp = c.genx(it.sons[1])\n      c.preventFalseAlias(it.sons[1], whichAsgnOpc(it.sons[1], opcWrObj),\n                          dest, idx, tmp)\n      c.freeTemp(tmp)\n    else:\n      globalError(n.info, \"invalid object constructor\")\n\nproc genTupleConstr(c: PCtx, n: PNode, dest: var Dest) =\n  if dest < 0: dest = c.getTemp(n.typ)\n  c.gABx(n, opcLdNull, dest, c.genType(n.typ))\n  # XXX x = (x.old, 22)  produces wrong code ... stupid self assignments\n  for i in 0.. <n.len:\n    let it = n.sons[i]\n    if it.kind == nkExprColonExpr:\n      let idx = genField(it.sons[0])\n      let tmp = c.genx(it.sons[1])\n      c.preventFalseAlias(it.sons[1], whichAsgnOpc(it.sons[1], opcWrObj),\n                          dest, idx, tmp)\n      c.freeTemp(tmp)\n    else:\n      let tmp = c.genx(it)\n      c.preventFalseAlias(it, whichAsgnOpc(it, opcWrObj), dest, i.TRegister, tmp)\n      c.freeTemp(tmp)\n\nproc genProc*(c: PCtx; s: PSym): int\n\nproc gen(c: PCtx; n: PNode; dest: var Dest; flags: TGenFlags = {}) =\n  case n.kind\n  of nkSym:\n    let s = n.sym\n    checkCanEval(c, n)\n    case s.kind\n    of skVar, skForVar, skTemp, skLet, skParam, skResult:\n      genRdVar(c, n, dest, flags)\n    of skProc, skConverter, skMacro, skTemplate, skMethod, skIterator:\n      # 'skTemplate' is only allowed for 'getAst' support:\n      genLit(c, n, dest)\n    of skConst:\n      gen(c, s.ast, dest)\n    of skEnumField:\n      if dest < 0: dest = c.getTemp(n.typ)\n      if s.position >= low(int16) and s.position <= high(int16):\n        c.gABx(n, opcLdImmInt, dest, s.position)\n      else:\n        var lit = genLiteral(c, newIntNode(nkIntLit, s.position))\n        c.gABx(n, opcLdConst, dest, lit)\n    of skType:\n      genTypeLit(c, s.typ, dest)\n    of skGenericParam:\n      if c.prc.sym != nil and c.prc.sym.kind == skMacro:\n        genRdVar(c, n, dest, flags)\n      else:\n        globalError(n.info, errGenerated, \"cannot generate code for: \" & s.name.s)\n    else:\n      globalError(n.info, errGenerated, \"cannot generate code for: \" & s.name.s)\n  of nkCallKinds:\n    if n.sons[0].kind == nkSym:\n      let s = n.sons[0].sym\n      if s.magic != mNone:\n        genMagic(c, n, dest, s.magic)\n      elif matches(s, \"stdlib\", \"marshal\", \"to\"):\n        genMarshalLoad(c, n, dest)\n      elif matches(s, \"stdlib\", \"marshal\", \"$$\"):\n        genMarshalStore(c, n, dest)\n      else:\n        genCall(c, n, dest)\n        clearDest(c, n, dest)\n    else:\n      genCall(c, n, dest)\n      clearDest(c, n, dest)\n  of nkCharLit..nkInt64Lit:\n    if isInt16Lit(n):\n      if dest < 0: dest = c.getTemp(n.typ)\n      c.gABx(n, opcLdImmInt, dest, n.intVal.int)\n    else:\n      genLit(c, n, dest)\n  of nkUIntLit..pred(nkNilLit): genLit(c, n, dest)\n  of nkNilLit:\n    if not n.typ.isEmptyType: genLit(c, getNullValue(n.typ, n.info), dest)\n    else: unused(n, dest)\n  of nkAsgn, nkFastAsgn:\n    unused(n, dest)\n    genAsgn(c, n.sons[0], n.sons[1], n.kind == nkAsgn)\n  of nkDotExpr: genObjAccess(c, n, dest, flags)\n  of nkCheckedFieldExpr: genCheckedObjAccess(c, n, dest, flags)\n  of nkBracketExpr: genArrAccess(c, n, dest, flags)\n  of nkDerefExpr, nkHiddenDeref: genAddrDeref(c, n, dest, opcLdDeref, flags)\n  of nkAddr, nkHiddenAddr: genAddrDeref(c, n, dest, opcAddrNode, flags)\n  of nkIfStmt, nkIfExpr: genIf(c, n, dest)\n  of nkWhenStmt:\n      # This is \"when nimvm\" node. Chose the first branch.\n      gen(c, n.sons[0].sons[1], dest)\n  of nkCaseStmt: genCase(c, n, dest)\n  of nkWhileStmt:\n    unused(n, dest)\n    genWhile(c, n)\n  of nkBlockExpr, nkBlockStmt: genBlock(c, n, dest)\n  of nkReturnStmt:\n    unused(n, dest)\n    genReturn(c, n)\n  of nkRaiseStmt:\n    unused(n, dest)\n    genRaise(c, n)\n  of nkBreakStmt:\n    unused(n, dest)\n    genBreak(c, n)\n  of nkTryStmt: genTry(c, n, dest)\n  of nkStmtList:\n    #unused(n, dest)\n    # XXX Fix this bug properly, lexim triggers it\n    for x in n: gen(c, x)\n  of nkStmtListExpr:\n    let L = n.len-1\n    for i in 0 .. <L: gen(c, n.sons[i])\n    gen(c, n.sons[L], dest, flags)\n  of nkPragmaBlock:\n    gen(c, n.lastSon, dest, flags)\n  of nkDiscardStmt:\n    unused(n, dest)\n    gen(c, n.sons[0])\n  of nkHiddenStdConv, nkHiddenSubConv, nkConv:\n    genConv(c, n, n.sons[1], dest)\n  of nkObjDownConv:\n    genConv(c, n, n.sons[0], dest)\n  of nkVarSection, nkLetSection:\n    unused(n, dest)\n    genVarSection(c, n)\n  of declarativeDefs:\n    unused(n, dest)\n  of nkLambdaKinds:\n    #let s = n.sons[namePos].sym\n    #discard genProc(c, s)\n    genLit(c, newSymNode(n.sons[namePos].sym), dest)\n  of nkChckRangeF, nkChckRange64, nkChckRange:\n    let\n      tmp0 = c.genx(n.sons[0])\n      tmp1 = c.genx(n.sons[1])\n      tmp2 = c.genx(n.sons[2])\n    c.gABC(n, opcRangeChck, tmp0, tmp1, tmp2)\n    c.freeTemp(tmp1)\n    c.freeTemp(tmp2)\n    if dest >= 0:\n      gABC(c, n, whichAsgnOpc(n), dest, tmp0, 1)\n      c.freeTemp(tmp0)\n    else:\n      dest = tmp0\n  of nkEmpty, nkCommentStmt, nkTypeSection, nkConstSection, nkPragma,\n     nkTemplateDef, nkIncludeStmt, nkImportStmt, nkFromStmt:\n    unused(n, dest)\n  of nkStringToCString, nkCStringToString:\n    gen(c, n.sons[0], dest)\n  of nkBracket: genArrayConstr(c, n, dest)\n  of nkCurly: genSetConstr(c, n, dest)\n  of nkObjConstr: genObjConstr(c, n, dest)\n  of nkPar, nkClosure: genTupleConstr(c, n, dest)\n  of nkCast:\n    if allowCast in c.features:\n      genConv(c, n, n.sons[1], dest, opcCast)\n    else:\n      globalError(n.info, errGenerated, \"VM is not allowed to 'cast'\")\n  of nkTypeOfExpr:\n    genTypeLit(c, n.typ, dest)\n  else:\n    globalError(n.info, errGenerated, \"cannot generate VM code for \" & $n)\n\nproc removeLastEof(c: PCtx) =\n  let last = c.code.len-1\n  if last >= 0 and c.code[last].opcode == opcEof:\n    # overwrite last EOF:\n    assert c.code.len == c.debug.len\n    c.code.setLen(last)\n    c.debug.setLen(last)\n\nproc genStmt*(c: PCtx; n: PNode): int =\n  c.removeLastEof\n  result = c.code.len\n  var d: Dest = -1\n  c.gen(n, d)\n  c.gABC(n, opcEof)\n  if d >= 0:\n    globalError(n.info, errGenerated, \"VM problem: dest register is set\")\n\nproc genExpr*(c: PCtx; n: PNode, requiresValue = true): int =\n  c.removeLastEof\n  result = c.code.len\n  var d: Dest = -1\n  c.gen(n, d)\n  if d < 0:\n    if requiresValue:\n      globalError(n.info, errGenerated, \"VM problem: dest register is not set\")\n    d = 0\n  c.gABC(n, opcEof, d)\n\n  #echo renderTree(n)\n  #c.echoCode(result)\n\nproc genParams(c: PCtx; params: PNode) =\n  # res.sym.position is already 0\n  c.prc.slots[0] = (inUse: true, kind: slotFixedVar)\n  for i in 1.. <params.len:\n    c.prc.slots[i] = (inUse: true, kind: slotFixedLet)\n  c.prc.maxSlots = max(params.len, 1)\n\nproc finalJumpTarget(c: PCtx; pc, diff: int) =\n  internalAssert(-0x7fff < diff and diff < 0x7fff)\n  let oldInstr = c.code[pc]\n  # opcode and regA stay the same:\n  c.code[pc] = ((oldInstr.uint32 and 0xffff'u32).uint32 or\n                uint32(diff+wordExcess) shl 16'u32).TInstr\n\nproc genGenericParams(c: PCtx; gp: PNode) =\n  var base = c.prc.maxSlots\n  for i in 0.. <gp.len:\n    var param = gp.sons[i].sym\n    param.position = base + i # XXX: fix this earlier; make it consistent with templates\n    c.prc.slots[base + i] = (inUse: true, kind: slotFixedLet)\n  c.prc.maxSlots = base + gp.len\n\nproc optimizeJumps(c: PCtx; start: int) =\n  const maxIterations = 10\n  for i in start .. <c.code.len:\n    let opc = c.code[i].opcode\n    case opc\n    of opcTJmp, opcFJmp:\n      var reg = c.code[i].regA\n      var d = i + c.code[i].jmpDiff\n      for iters in countdown(maxIterations, 0):\n        case c.code[d].opcode\n        of opcJmp, opcJmpBack:\n          d = d + c.code[d].jmpDiff\n        of opcTJmp, opcFJmp:\n          if c.code[d].regA != reg: break\n          # tjmp x, 23\n          # ...\n          # tjmp x, 12\n          # -- we know 'x' is true, and so can jump to 12+13:\n          if c.code[d].opcode == opc:\n            d = d + c.code[d].jmpDiff\n          else:\n            # tjmp x, 23\n            # fjmp x, 22\n            # We know 'x' is true so skip to the next instruction:\n            d = d + 1\n        else: break\n      if d != i + c.code[i].jmpDiff:\n        c.finalJumpTarget(i, d - i)\n    of opcJmp, opcJmpBack:\n      var d = i + c.code[i].jmpDiff\n      var iters = maxIterations\n      while c.code[d].opcode == opcJmp and iters > 0:\n        d = d + c.code[d].jmpDiff\n        dec iters\n      if c.code[d].opcode == opcRet:\n        # optimize 'jmp to ret' to 'ret' here\n        c.code[i] = c.code[d]\n      elif d != i + c.code[i].jmpDiff:\n        c.finalJumpTarget(i, d - i)\n    else: discard\n\nproc dfa(c: PCtx; start: int) =\n  type RegSet = set[TRegister]\n  const\n    setRa = {\n      opcAsgnInt,\n      opcAsgnStr,\n      opcAsgnFloat,\n      opcAsgnRef,\n      opcAsgnComplex,\n      opcNodeToReg,\n      opcLdArr,\n      opcLdObj,\n      opcLdDeref,\n      opcLdStrIdx,\n      opcLenSeq,\n      opcLenStr,\n      opcCard,\n      opcLdConst,\n      opcAsgnConst,\n      opcLdGlobal,\n      opcLdGlobalAddr,\n      opcLdImmInt,\n    }\n    jumpForw = {opcJmp, opcJmpBack}\n    jumpCond = {opcTJmp, opcFJmp}\n    jumpRet = {opcRaise}\n\n  proc analyse(instr: TInstr): RegSet =\n\n\n  let n = c.code.len - start\n  var s = newSeq[RegSet](n)\n  var w = initIntSet()\n  for i in 0..n: w.incl i\n  while true:\n    var pc = 0\n    block choose:\n      for i in 0..n:\n        if w.contains(i):\n          pc = i\n          break choose\n      return\n    while pc <= n:\n      w.excl pc\n      let instr = c.code[pc+start]\n      let neww = analyse(instr)\n      var nextPc = pc+1\n      if instr.opcode in jumpForw:\n        nextPc = pc + c.code[pc].jmpDiff\n      else:\n        if instr.opcode in jumpCond:\n          let otherPc = pc + c.code[pc].jmpDiff\n          if neww < s[otherPc]:\n            w.incl otherPc\n            s[otherPc] = neww\n      if neww < s[nextPc]:\n        s[nextpc] = neww\n        pc = nextPc\n      else:\n        break\n\n\nproc genProc(c: PCtx; s: PSym): int =\n  var x = s.ast.sons[miscPos]\n  if x.kind == nkEmpty or x[0].kind == nkEmpty:\n    #if s.name.s == \"outterMacro\" or s.name.s == \"innerProc\":\n    #  echo \"GENERATING CODE FOR \", s.name.s\n    let last = c.code.len-1\n    var eofInstr: TInstr\n    if last >= 0 and c.code[last].opcode == opcEof:\n      eofInstr = c.code[last]\n      c.code.setLen(last)\n      c.info.setLen(last)\n    #c.removeLastEof\n    result = c.code.len+1 # skip the jump instruction\n    if x.kind == nkEmpty:\n      x = newTree(nkBracket, newIntNode(nkIntLit, result), ast.emptyNode)\n    else:\n      x.sons[0] = newIntNode(nkIntLit, result)\n    s.ast.sons[miscPos] = x\n    # thanks to the jmp we can add top level statements easily and also nest\n    # procs easily:\n    let body = s.getBody\n    let procStart = c.xjmp(body, opcJmp, 0)\n    var p = PProc(blocks: @[], sym: s)\n    let oldPrc = c.prc\n    c.prc = p\n    # iterate over the parameters and allocate space for them:\n    genParams(c, s.typ.n)\n\n    # allocate additional space for any generically bound parameters\n    if s.kind == skMacro and\n       sfImmediate notin s.flags and\n       s.ast[genericParamsPos].kind != nkEmpty:\n      genGenericParams(c, s.ast[genericParamsPos])\n\n    if tfCapturesEnv in s.typ.flags:\n      #let env = s.ast.sons[paramsPos].lastSon.sym\n      #assert env.position == 2\n      c.prc.slots[c.prc.maxSlots] = (inUse: true, kind: slotFixedLet)\n      inc c.prc.maxSlots\n    gen(c, body)\n    # generate final 'return' statement:\n    c.gABC(body, opcRet)\n    c.patch(procStart)\n    c.gABC(body, opcEof, eofInstr.regA)\n    c.optimizeJumps(result)\n    s.offset = c.prc.maxSlots\n    #if s.name.s == \"calc\":\n    #  echo renderTree(body)\n    #  c.echoCode(result)\n    c.prc = oldPrc\n  else:\n    c.prc.maxSlots = s.offset\n    result = x[0].intVal.int\n",
			"file": "Nim/nim/dfa.d",
			"file_size": 56197,
			"file_write_time": 131325966420000000,
			"settings":
			{
				"buffer_size": 56193,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#\n#\n#           The Nim Compiler\n#        (c) Copyright 2015 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## This module implements the 'implies' relation for guards.\n\nimport ast, astalgo, msgs, magicsys, nimsets, trees, types, renderer, idents,\n  saturate\n\nconst\n  someEq = {mEqI, mEqF64, mEqEnum, mEqCh, mEqB, mEqRef, mEqProc,\n    mEqUntracedRef, mEqStr, mEqSet, mEqCString}\n\n  # set excluded here as the semantics are vastly different:\n  someLe = {mLeI, mLeF64, mLeU, mLeU64, mLeEnum,\n            mLeCh, mLeB, mLePtr, mLeStr}\n  someLt = {mLtI, mLtF64, mLtU, mLtU64, mLtEnum,\n            mLtCh, mLtB, mLtPtr, mLtStr}\n\n  someLen = {mLengthOpenArray, mLengthStr, mLengthArray, mLengthSeq,\n             mXLenStr, mXLenSeq}\n\n  someIn = {mInRange, mInSet}\n\n  someHigh = {mHigh}\n  # we don't list unsigned here because wrap around semantics suck for\n  # proving anything:\n  someAdd = {mAddI, mAddF64, mSucc}\n  someSub = {mSubI, mSubF64, mPred}\n  someMul = {mMulI, mMulF64}\n  someDiv = {mDivI, mDivF64}\n  someMod = {mModI}\n  someMax = {mMaxI, mMaxF64}\n  someMin = {mMinI, mMinF64}\n  someBinaryOp = someAdd+someSub+someMul+someMax+someMin\n\nproc isValue(n: PNode): bool = n.kind in {nkCharLit..nkNilLit}\nproc isLocation(n: PNode): bool = not n.isValue\n\nproc isLet(n: PNode): bool =\n  if n.kind == nkSym:\n    if n.sym.kind in {skLet, skTemp, skForVar}:\n      result = true\n    elif n.sym.kind == skParam and skipTypes(n.sym.typ,\n                                             abstractInst).kind != tyVar:\n      result = true\n\nproc isVar(n: PNode): bool =\n  n.kind == nkSym and n.sym.kind in {skResult, skVar} and\n      {sfGlobal, sfAddrTaken} * n.sym.flags == {}\n\nproc isLetLocation(m: PNode, isApprox: bool): bool =\n  # consider: 'n[].kind' --> we really need to support 1 deref op even if this\n  # is technically wrong due to aliasing :-( We could introduce \"soft\" facts\n  # for this; this would still be very useful for warnings and also nicely\n  # solves the 'var' problems. For now we fix this by requiring much more\n  # restrictive expressions for the 'not nil' checking.\n  var n = m\n  var derefs = 0\n  while true:\n    case n.kind\n    of nkDotExpr, nkCheckedFieldExpr, nkObjUpConv, nkObjDownConv:\n      n = n.sons[0]\n    of nkDerefExpr, nkHiddenDeref:\n      n = n.sons[0]\n      inc derefs\n    of nkBracketExpr:\n      if isConstExpr(n.sons[1]) or isLet(n.sons[1]):\n        n = n.sons[0]\n      else: return\n    of nkHiddenStdConv, nkHiddenSubConv, nkConv:\n      n = n.sons[1]\n    else:\n      break\n  result = n.isLet and derefs <= ord(isApprox)\n  if not result and isApprox:\n    result = isVar(n)\n\nproc interestingCaseExpr*(m: PNode): bool = isLetLocation(m, true)\n\nlet\n  opLe = createMagic(\"<=\", mLeI)\n  opLt = createMagic(\"<\", mLtI)\n  opAnd = createMagic(\"and\", mAnd)\n  opOr = createMagic(\"or\", mOr)\n  opIsNil = createMagic(\"isnil\", mIsNil)\n  opEq = createMagic(\"==\", mEqI)\n  opAdd = createMagic(\"+\", mAddI)\n  opSub = createMagic(\"-\", mSubI)\n  opMul = createMagic(\"*\", mMulI)\n  opDiv = createMagic(\"div\", mDivI)\n  opLen = createMagic(\"len\", mLengthSeq)\n\nproc swapArgs(fact: PNode, newOp: PSym): PNode =\n  result = newNodeI(nkCall, fact.info, 3)\n  result.sons[0] = newSymNode(newOp)\n  result.sons[1] = fact.sons[2]\n  result.sons[2] = fact.sons[1]\n\nproc neg(n: PNode): PNode =\n  if n == nil: return nil\n  case n.getMagic\n  of mNot:\n    result = n.sons[1]\n  of someLt:\n    # not (a < b)  ==  a >= b  ==  b <= a\n    result = swapArgs(n, opLe)\n  of someLe:\n    result = swapArgs(n, opLt)\n  of mInSet:\n    if n.sons[1].kind != nkCurly: return nil\n    let t = n.sons[2].typ.skipTypes(abstractInst)\n    result = newNodeI(nkCall, n.info, 3)\n    result.sons[0] = n.sons[0]\n    result.sons[2] = n.sons[2]\n    if t.kind == tyEnum:\n      var s = newNodeIT(nkCurly, n.info, n.sons[1].typ)\n      for e in t.n:\n        let eAsNode = newIntNode(nkIntLit, e.sym.position)\n        if not inSet(n.sons[1], eAsNode): s.add eAsNode\n      result.sons[1] = s\n    elif t.kind notin {tyString, tySequence} and lengthOrd(t) < 1000:\n      result.sons[1] = complement(n.sons[1])\n    else:\n      # not ({2, 3, 4}.contains(x))   x != 2 and x != 3 and x != 4\n      # XXX todo\n      result = nil\n  of mOr:\n    # not (a or b) --> not a and not b\n    let\n      a = n.sons[1].neg\n      b = n.sons[2].neg\n    if a != nil and b != nil:\n      result = newNodeI(nkCall, n.info, 3)\n      result.sons[0] = newSymNode(opAnd)\n      result.sons[1] = a\n      result.sons[2] = b\n    elif a != nil:\n      result = a\n    elif b != nil:\n      result = b\n  else:\n    # leave  not (a == 4)  as it is\n    result = newNodeI(nkCall, n.info, 2)\n    result.sons[0] = newSymNode(opNot)\n    result.sons[1] = n\n\nproc buildCall(op: PSym; a: PNode): PNode =\n  result = newNodeI(nkCall, a.info, 2)\n  result.sons[0] = newSymNode(op)\n  result.sons[1] = a\n\nproc buildCall(op: PSym; a, b: PNode): PNode =\n  result = newNodeI(nkInfix, a.info, 3)\n  result.sons[0] = newSymNode(op)\n  result.sons[1] = a\n  result.sons[2] = b\n\nproc `|+|`(a, b: PNode): PNode =\n  result = copyNode(a)\n  if a.kind in {nkCharLit..nkUInt64Lit}: result.intVal = a.intVal |+| b.intVal\n  else: result.floatVal = a.floatVal + b.floatVal\n\nproc `|-|`(a, b: PNode): PNode =\n  result = copyNode(a)\n  if a.kind in {nkCharLit..nkUInt64Lit}: result.intVal = a.intVal |-| b.intVal\n  else: result.floatVal = a.floatVal - b.floatVal\n\nproc `|*|`(a, b: PNode): PNode =\n  result = copyNode(a)\n  if a.kind in {nkCharLit..nkUInt64Lit}: result.intVal = a.intVal |*| b.intVal\n  else: result.floatVal = a.floatVal * b.floatVal\n\nproc `|div|`(a, b: PNode): PNode =\n  result = copyNode(a)\n  if a.kind in {nkCharLit..nkUInt64Lit}: result.intVal = a.intVal div b.intVal\n  else: result.floatVal = a.floatVal / b.floatVal\n\nproc negate(a, b, res: PNode): PNode =\n  if b.kind in {nkCharLit..nkUInt64Lit} and b.intVal != low(BiggestInt):\n    var b = copyNode(b)\n    b.intVal = -b.intVal\n    if a.kind in {nkCharLit..nkUInt64Lit}:\n      b.intVal = b.intVal |+| a.intVal\n      result = b\n    else:\n      result = buildCall(opAdd, a, b)\n  elif b.kind in {nkFloatLit..nkFloat64Lit}:\n    var b = copyNode(b)\n    b.floatVal = -b.floatVal\n    result = buildCall(opAdd, a, b)\n  else:\n    result = res\n\nproc zero(): PNode = nkIntLit.newIntNode(0)\nproc one(): PNode = nkIntLit.newIntNode(1)\nproc minusOne(): PNode = nkIntLit.newIntNode(-1)\n\nproc lowBound*(x: PNode): PNode =\n  result = nkIntLit.newIntNode(firstOrd(x.typ))\n  result.info = x.info\n\nproc highBound*(x: PNode): PNode =\n  let typ = x.typ.skipTypes(abstractInst)\n  result = if typ.kind == tyArray:\n             nkIntLit.newIntNode(lastOrd(typ))\n           elif typ.kind == tySequence and x.kind == nkSym and\n               x.sym.kind == skConst:\n             nkIntLit.newIntNode(x.sym.ast.len-1)\n           else:\n             opAdd.buildCall(opLen.buildCall(x), minusOne())\n  result.info = x.info\n\nproc reassociation(n: PNode): PNode =\n  result = n\n  # (foo+5)+5 --> foo+10;  same for '*'\n  case result.getMagic\n  of someAdd:\n    if result[2].isValue and\n        result[1].getMagic in someAdd and result[1][2].isValue:\n      result = opAdd.buildCall(result[1][1], result[1][2] |+| result[2])\n      if result[2].intVal == 0:\n        result = result[1]\n  of someMul:\n    if result[2].isValue and\n        result[1].getMagic in someMul and result[1][2].isValue:\n      result = opMul.buildCall(result[1][1], result[1][2] |*| result[2])\n      if result[2].intVal == 1:\n        result = result[1]\n      elif result[2].intVal == 0:\n        result = zero()\n  else: discard\n\nproc pred(n: PNode): PNode =\n  if n.kind in {nkCharLit..nkUInt64Lit} and n.intVal != low(BiggestInt):\n    result = copyNode(n)\n    dec result.intVal\n  else:\n    result = n\n\nproc canon*(n: PNode): PNode =\n  # XXX for now only the new code in 'semparallel' uses this\n  if n.safeLen >= 1:\n    result = shallowCopy(n)\n    for i in 0 .. < n.len:\n      result.sons[i] = canon(n.sons[i])\n  elif n.kind == nkSym and n.sym.kind == skLet and\n      n.sym.ast.getMagic in (someEq + someAdd + someMul + someMin +\n      someMax + someHigh + {mUnaryLt} + someSub + someLen + someDiv):\n    result = n.sym.ast.copyTree\n  else:\n    result = n\n  case result.getMagic\n  of someEq, someAdd, someMul, someMin, someMax:\n    # these are symmetric; put value as last:\n    if result.sons[1].isValue and not result.sons[2].isValue:\n      result = swapArgs(result, result.sons[0].sym)\n      # (4 + foo) + 2 --> (foo + 4) + 2\n  of someHigh:\n    # high == len+(-1)\n    result = opAdd.buildCall(opLen.buildCall(result[1]), minusOne())\n  of mUnaryLt:\n    result = buildCall(opAdd, result[1], minusOne())\n  of someSub:\n    # x - 4  -->  x + (-4)\n    result = negate(result[1], result[2], result)\n  of someLen:\n    result.sons[0] = opLen.newSymNode\n  of someLt:\n    # x < y  same as x <= y-1:\n    let y = n[2].canon\n    let p = pred(y)\n    let minus = if p != y: p else: opAdd.buildCall(y, minusOne()).canon\n    result = opLe.buildCall(n[1].canon, minus)\n  else: discard\n\n  result = skipConv(result)\n  result = reassociation(result)\n  # most important rule: (x-4) <= a.len -->  x <= a.len+4\n  case result.getMagic\n  of someLe:\n    let x = result[1]\n    let y = result[2]\n    if x.kind in nkCallKinds and x.len == 3 and x[2].isValue and\n        isLetLocation(x[1], true):\n      case x.getMagic\n      of someSub:\n        result = buildCall(result[0].sym, x[1],\n                           reassociation(opAdd.buildCall(y, x[2])))\n      of someAdd:\n        # Rule A:\n        let plus = negate(y, x[2], nil).reassociation\n        if plus != nil: result = buildCall(result[0].sym, x[1], plus)\n      else: discard\n    elif y.kind in nkCallKinds and y.len == 3 and y[2].isValue and\n        isLetLocation(y[1], true):\n      # a.len < x-3\n      case y.getMagic\n      of someSub:\n        result = buildCall(result[0].sym, y[1],\n                           reassociation(opAdd.buildCall(x, y[2])))\n      of someAdd:\n        let plus = negate(x, y[2], nil).reassociation\n        # ensure that Rule A will not trigger afterwards with the\n        # additional 'not isLetLocation' constraint:\n        if plus != nil and not isLetLocation(x, true):\n          result = buildCall(result[0].sym, plus, y[1])\n      else: discard\n    elif x.isValue and y.getMagic in someAdd and y[2].isValue:\n      # 0 <= a.len + 3\n      # -3 <= a.len\n      result.sons[1] = x |-| y[2]\n      result.sons[2] = y[1]\n    elif x.isValue and y.getMagic in someSub and y[2].isValue:\n      # 0 <= a.len - 3\n      # 3 <= a.len\n      result.sons[1] = x |+| y[2]\n      result.sons[2] = y[1]\n  else: discard\n\nproc `+@`*(a: PNode; b: BiggestInt): PNode =\n  canon(if b != 0: opAdd.buildCall(a, nkIntLit.newIntNode(b)) else: a)\n\nproc usefulFact(n: PNode): PNode =\n  case n.getMagic\n  of someEq:\n    if skipConv(n.sons[2]).kind == nkNilLit and (\n        isLetLocation(n.sons[1], false) or isVar(n.sons[1])):\n      result = opIsNil.buildCall(n.sons[1])\n    else:\n      if isLetLocation(n.sons[1], true) or isLetLocation(n.sons[2], true):\n        # XXX algebraic simplifications!  'i-1 < a.len' --> 'i < a.len+1'\n        result = n\n  of someLe+someLt:\n    if isLetLocation(n.sons[1], true) or isLetLocation(n.sons[2], true):\n      # XXX algebraic simplifications!  'i-1 < a.len' --> 'i < a.len+1'\n      result = n\n    elif n[1].getMagic in someLen or n[2].getMagic in someLen:\n      # XXX Rethink this whole idea of 'usefulFact' for semparallel\n      result = n\n  of mIsNil:\n    if isLetLocation(n.sons[1], false) or isVar(n.sons[1]):\n      result = n\n  of someIn:\n    if isLetLocation(n.sons[1], true):\n      result = n\n  of mAnd:\n    let\n      a = usefulFact(n.sons[1])\n      b = usefulFact(n.sons[2])\n    if a != nil and b != nil:\n      result = newNodeI(nkCall, n.info, 3)\n      result.sons[0] = newSymNode(opAnd)\n      result.sons[1] = a\n      result.sons[2] = b\n    elif a != nil:\n      result = a\n    elif b != nil:\n      result = b\n  of mNot:\n    let a = usefulFact(n.sons[1])\n    if a != nil:\n      result = a.neg\n  of mOr:\n    # 'or' sucks! (p.isNil or q.isNil) --> hard to do anything\n    # with that knowledge...\n    # DeMorgan helps a little though:\n    #   not a or not b --> not (a and b)\n    #  (x == 3) or (y == 2)  ---> not ( not (x==3) and not (y == 2))\n    #  not (x != 3 and y != 2)\n    let\n      a = usefulFact(n.sons[1]).neg\n      b = usefulFact(n.sons[2]).neg\n    if a != nil and b != nil:\n      result = newNodeI(nkCall, n.info, 3)\n      result.sons[0] = newSymNode(opAnd)\n      result.sons[1] = a\n      result.sons[2] = b\n      result = result.neg\n  elif n.kind == nkSym and n.sym.kind == skLet:\n    # consider:\n    #   let a = 2 < x\n    #   if a:\n    #     ...\n    # We make can easily replace 'a' by '2 < x' here:\n    if n.sym.ast != nil:\n      result = usefulFact(n.sym.ast)\n  elif n.kind == nkStmtListExpr:\n    result = usefulFact(n.lastSon)\n\ntype\n  TModel* = seq[PNode] # the \"knowledge base\"\n\nproc addFact*(m: var TModel, nn: PNode) =\n  let n = usefulFact(nn)\n  if n != nil: m.add n\n\nproc addFactNeg*(m: var TModel, n: PNode) =\n  let n = n.neg\n  if n != nil: addFact(m, n)\n\nproc canonOpr(opr: PSym): PSym =\n  case opr.magic\n  of someEq: result = opEq\n  of someLe: result = opLe\n  of someLt: result = opLt\n  of someLen: result = opLen\n  of someAdd: result = opAdd\n  of someSub: result = opSub\n  of someMul: result = opMul\n  of someDiv: result = opDiv\n  else: result = opr\n\nproc sameTree*(a, b: PNode): bool =\n  result = false\n  if a == b:\n    result = true\n  elif a != nil and b != nil and a.kind == b.kind:\n    case a.kind\n    of nkSym:\n      result = a.sym == b.sym\n      if not result and a.sym.magic != mNone:\n        result = a.sym.magic == b.sym.magic or canonOpr(a.sym) == canonOpr(b.sym)\n    of nkIdent: result = a.ident.id == b.ident.id\n    of nkCharLit..nkInt64Lit: result = a.intVal == b.intVal\n    of nkFloatLit..nkFloat64Lit: result = a.floatVal == b.floatVal\n    of nkStrLit..nkTripleStrLit: result = a.strVal == b.strVal\n    of nkType: result = a.typ == b.typ\n    of nkEmpty, nkNilLit: result = true\n    else:\n      if sonsLen(a) == sonsLen(b):\n        for i in countup(0, sonsLen(a) - 1):\n          if not sameTree(a.sons[i], b.sons[i]): return\n        result = true\n\nproc hasSubTree(n, x: PNode): bool =\n  if n.sameTree(x): result = true\n  else:\n    for i in 0..safeLen(n)-1:\n      if hasSubTree(n.sons[i], x): return true\n\nproc invalidateFacts*(m: var TModel, n: PNode) =\n  # We are able to guard local vars (as opposed to 'let' variables)!\n  # 'while p != nil: f(p); p = p.next'\n  # This is actually quite easy to do:\n  # Re-assignments (incl. pass to a 'var' param) trigger an invalidation\n  # of every fact that contains 'v'.\n  #\n  #   if x < 4:\n  #     if y < 5\n  #       x = unknown()\n  #       # we invalidate 'x' here but it's known that x >= 4\n  #       # for the else anyway\n  #   else:\n  #     echo x\n  #\n  # The same mechanism could be used for more complex data stored on the heap;\n  # procs that 'write: []' cannot invalidate 'n.kind' for instance. In fact, we\n  # could CSE these expressions then and help C's optimizer.\n  for i in 0..high(m):\n    if m[i] != nil and m[i].hasSubTree(n): m[i] = nil\n\nproc valuesUnequal(a, b: PNode): bool =\n  if a.isValue and b.isValue:\n    result = not sameValue(a, b)\n\nproc impliesEq(fact, eq: PNode): TImplication =\n  let (loc, val) = if isLocation(eq.sons[1]): (1, 2) else: (2, 1)\n\n  case fact.sons[0].sym.magic\n  of someEq:\n    if sameTree(fact.sons[1], eq.sons[loc]):\n      # this is not correct; consider:  a == b;  a == 1 --> unknown!\n      if sameTree(fact.sons[2], eq.sons[val]): result = impYes\n      elif valuesUnequal(fact.sons[2], eq.sons[val]): result = impNo\n    elif sameTree(fact.sons[2], eq.sons[loc]):\n      if sameTree(fact.sons[1], eq.sons[val]): result = impYes\n      elif valuesUnequal(fact.sons[1], eq.sons[val]): result = impNo\n  of mInSet:\n    # remember: mInSet is 'contains' so the set comes first!\n    if sameTree(fact.sons[2], eq.sons[loc]) and isValue(eq.sons[val]):\n      if inSet(fact.sons[1], eq.sons[val]): result = impYes\n      else: result = impNo\n  of mNot, mOr, mAnd: internalError(eq.info, \"impliesEq\")\n  else: discard\n\nproc leImpliesIn(x, c, aSet: PNode): TImplication =\n  if c.kind in {nkCharLit..nkUInt64Lit}:\n    # fact:  x <= 4;  question x in {56}?\n    # --> true if every value <= 4 is in the set {56}\n    #\n    var value = newIntNode(c.kind, firstOrd(x.typ))\n    # don't iterate too often:\n    if c.intVal - value.intVal < 1000:\n      var i, pos, neg: int\n      while value.intVal <= c.intVal:\n        if inSet(aSet, value): inc pos\n        else: inc neg\n        inc i; inc value.intVal\n      if pos == i: result = impYes\n      elif neg == i: result = impNo\n\nproc geImpliesIn(x, c, aSet: PNode): TImplication =\n  if c.kind in {nkCharLit..nkUInt64Lit}:\n    # fact:  x >= 4;  question x in {56}?\n    # --> true iff every value >= 4 is in the set {56}\n    #\n    var value = newIntNode(c.kind, c.intVal)\n    let max = lastOrd(x.typ)\n    # don't iterate too often:\n    if max - value.intVal < 1000:\n      var i, pos, neg: int\n      while value.intVal <= max:\n        if inSet(aSet, value): inc pos\n        else: inc neg\n        inc i; inc value.intVal\n      if pos == i: result = impYes\n      elif neg == i: result = impNo\n\nproc compareSets(a, b: PNode): TImplication =\n  if equalSets(a, b): result = impYes\n  elif intersectSets(a, b).len == 0: result = impNo\n\nproc impliesIn(fact, loc, aSet: PNode): TImplication =\n  case fact.sons[0].sym.magic\n  of someEq:\n    if sameTree(fact.sons[1], loc):\n      if inSet(aSet, fact.sons[2]): result = impYes\n      else: result = impNo\n    elif sameTree(fact.sons[2], loc):\n      if inSet(aSet, fact.sons[1]): result = impYes\n      else: result = impNo\n  of mInSet:\n    if sameTree(fact.sons[2], loc):\n      result = compareSets(fact.sons[1], aSet)\n  of someLe:\n    if sameTree(fact.sons[1], loc):\n      result = leImpliesIn(fact.sons[1], fact.sons[2], aSet)\n    elif sameTree(fact.sons[2], loc):\n      result = geImpliesIn(fact.sons[2], fact.sons[1], aSet)\n  of someLt:\n    if sameTree(fact.sons[1], loc):\n      result = leImpliesIn(fact.sons[1], fact.sons[2].pred, aSet)\n    elif sameTree(fact.sons[2], loc):\n      # 4 < x  -->  3 <= x\n      result = geImpliesIn(fact.sons[2], fact.sons[1].pred, aSet)\n  of mNot, mOr, mAnd: internalError(loc.info, \"impliesIn\")\n  else: discard\n\nproc valueIsNil(n: PNode): TImplication =\n  if n.kind == nkNilLit: impYes\n  elif n.kind in {nkStrLit..nkTripleStrLit, nkBracket, nkObjConstr}: impNo\n  else: impUnknown\n\nproc impliesIsNil(fact, eq: PNode): TImplication =\n  case fact.sons[0].sym.magic\n  of mIsNil:\n    if sameTree(fact.sons[1], eq.sons[1]):\n      result = impYes\n  of someEq:\n    if sameTree(fact.sons[1], eq.sons[1]):\n      result = valueIsNil(fact.sons[2].skipConv)\n    elif sameTree(fact.sons[2], eq.sons[1]):\n      result = valueIsNil(fact.sons[1].skipConv)\n  of mNot, mOr, mAnd: internalError(eq.info, \"impliesIsNil\")\n  else: discard\n\nproc impliesGe(fact, x, c: PNode): TImplication =\n  internalAssert isLocation(x)\n  case fact.sons[0].sym.magic\n  of someEq:\n    if sameTree(fact.sons[1], x):\n      if isValue(fact.sons[2]) and isValue(c):\n        # fact:  x = 4;  question x >= 56? --> true iff 4 >= 56\n        if leValue(c, fact.sons[2]): result = impYes\n        else: result = impNo\n    elif sameTree(fact.sons[2], x):\n      if isValue(fact.sons[1]) and isValue(c):\n        if leValue(c, fact.sons[1]): result = impYes\n        else: result = impNo\n  of someLt:\n    if sameTree(fact.sons[1], x):\n      if isValue(fact.sons[2]) and isValue(c):\n        # fact:  x < 4;  question N <= x? --> false iff N <= 4\n        if leValue(fact.sons[2], c): result = impNo\n        # fact:  x < 4;  question 2 <= x? --> we don't know\n    elif sameTree(fact.sons[2], x):\n      # fact: 3 < x; question: N-1 < x ?  --> true iff N-1 <= 3\n      if isValue(fact.sons[1]) and isValue(c):\n        if leValue(c.pred, fact.sons[1]): result = impYes\n  of someLe:\n    if sameTree(fact.sons[1], x):\n      if isValue(fact.sons[2]) and isValue(c):\n        # fact:  x <= 4;  question x >= 56? --> false iff 4 <= 56\n        if leValue(fact.sons[2], c): result = impNo\n        # fact:  x <= 4;  question x >= 2? --> we don't know\n    elif sameTree(fact.sons[2], x):\n      # fact: 3 <= x; question: x >= 2 ?  --> true iff 2 <= 3\n      if isValue(fact.sons[1]) and isValue(c):\n        if leValue(c, fact.sons[1]): result = impYes\n  of mNot, mOr, mAnd: internalError(x.info, \"impliesGe\")\n  else: discard\n\nproc impliesLe(fact, x, c: PNode): TImplication =\n  if not isLocation(x):\n    return impliesGe(fact, c, x)\n  case fact.sons[0].sym.magic\n  of someEq:\n    if sameTree(fact.sons[1], x):\n      if isValue(fact.sons[2]) and isValue(c):\n        # fact:  x = 4;  question x <= 56? --> true iff 4 <= 56\n        if leValue(fact.sons[2], c): result = impYes\n        else: result = impNo\n    elif sameTree(fact.sons[2], x):\n      if isValue(fact.sons[1]) and isValue(c):\n        if leValue(fact.sons[1], c): result = impYes\n        else: result = impNo\n  of someLt:\n    if sameTree(fact.sons[1], x):\n      if isValue(fact.sons[2]) and isValue(c):\n        # fact:  x < 4;  question x <= N? --> true iff N-1 <= 4\n        if leValue(fact.sons[2], c.pred): result = impYes\n        # fact:  x < 4;  question x <= 2? --> we don't know\n    elif sameTree(fact.sons[2], x):\n      # fact: 3 < x; question: x <= 1 ?  --> false iff 1 <= 3\n      if isValue(fact.sons[1]) and isValue(c):\n        if leValue(c, fact.sons[1]): result = impNo\n\n  of someLe:\n    if sameTree(fact.sons[1], x):\n      if isValue(fact.sons[2]) and isValue(c):\n        # fact:  x <= 4;  question x <= 56? --> true iff 4 <= 56\n        if leValue(fact.sons[2], c): result = impYes\n        # fact:  x <= 4;  question x <= 2? --> we don't know\n\n    elif sameTree(fact.sons[2], x):\n      # fact: 3 <= x; question: x <= 2 ?  --> false iff 2 < 3\n      if isValue(fact.sons[1]) and isValue(c):\n        if leValue(c, fact.sons[1].pred): result = impNo\n\n  of mNot, mOr, mAnd: internalError(x.info, \"impliesLe\")\n  else: discard\n\nproc impliesLt(fact, x, c: PNode): TImplication =\n  # x < 3  same as x <= 2:\n  let p = c.pred\n  if p != c:\n    result = impliesLe(fact, x, p)\n  else:\n    # 4 < x  same as 3 <= x\n    let q = x.pred\n    if q != x:\n      result = impliesLe(fact, q, c)\n\nproc `~`(x: TImplication): TImplication =\n  case x\n  of impUnknown: impUnknown\n  of impNo: impYes\n  of impYes: impNo\n\nproc factImplies(fact, prop: PNode): TImplication =\n  case fact.getMagic\n  of mNot:\n    # Consider:\n    # enum nkBinary, nkTernary, nkStr\n    # fact:      not (k <= nkBinary)\n    # question:  k in {nkStr}\n    # --> 'not' for facts is entirely different than 'not' for questions!\n    # it's provably wrong if every value > 4 is in the set {56}\n    # That's because we compute the implication and  'a -> not b' cannot\n    # be treated the same as 'not a -> b'\n\n    #  (not a) -> b  compute as  not (a -> b) ???\n    #  == not a or not b == not (a and b)\n    let arg = fact.sons[1]\n    case arg.getMagic\n    of mIsNil, mEqRef:\n      return ~factImplies(arg, prop)\n    of mAnd:\n      # not (a and b)  means  not a or not b:\n      # a or b --> both need to imply 'prop'\n      let a = factImplies(arg.sons[1], prop)\n      let b = factImplies(arg.sons[2], prop)\n      if a == b: return ~a\n      return impUnknown\n    else:\n      return impUnknown\n  of mAnd:\n    result = factImplies(fact.sons[1], prop)\n    if result != impUnknown: return result\n    return factImplies(fact.sons[2], prop)\n  else: discard\n\n  case prop.sons[0].sym.magic\n  of mNot: result = ~fact.factImplies(prop.sons[1])\n  of mIsNil: result = impliesIsNil(fact, prop)\n  of someEq: result = impliesEq(fact, prop)\n  of someLe: result = impliesLe(fact, prop.sons[1], prop.sons[2])\n  of someLt: result = impliesLt(fact, prop.sons[1], prop.sons[2])\n  of mInSet: result = impliesIn(fact, prop.sons[2], prop.sons[1])\n  else: result = impUnknown\n\nproc doesImply*(facts: TModel, prop: PNode): TImplication =\n  assert prop.kind in nkCallKinds\n  for f in facts:\n    # facts can be invalidated, in which case they are 'nil':\n    if not f.isNil:\n      result = f.factImplies(prop)\n      if result != impUnknown: return\n\nproc impliesNotNil*(facts: TModel, arg: PNode): TImplication =\n  result = doesImply(facts, opIsNil.buildCall(arg).neg)\n\nproc simpleSlice*(a, b: PNode): BiggestInt =\n  # returns 'c' if a..b matches (i+c)..(i+c), -1 otherwise. (i)..(i) is matched\n  # as if it is (i+0)..(i+0).\n  if guards.sameTree(a, b):\n    if a.getMagic in someAdd and a[2].kind in {nkCharLit..nkUInt64Lit}:\n      result = a[2].intVal\n    else:\n      result = 0\n  else:\n    result = -1\n\n\ntemplate isMul(x): untyped = x.getMagic in someMul\ntemplate isDiv(x): untyped = x.getMagic in someDiv\ntemplate isAdd(x): untyped = x.getMagic in someAdd\ntemplate isSub(x): untyped = x.getMagic in someSub\ntemplate isVal(x): untyped = x.kind in {nkCharLit..nkUInt64Lit}\ntemplate isIntVal(x, y): untyped = x.intVal == y\n\nimport macros\n\nmacro `=~`(x: PNode, pat: untyped): bool =\n  proc m(x, pat, conds: NimNode) =\n    case pat.kind\n    of nnkInfix:\n      case $pat[0]\n      of \"*\": conds.add getAst(isMul(x))\n      of \"/\": conds.add getAst(isDiv(x))\n      of \"+\": conds.add getAst(isAdd(x))\n      of \"-\": conds.add getAst(isSub(x))\n      else:\n        error(\"invalid pattern\")\n      m(newTree(nnkBracketExpr, x, newLit(1)), pat[1], conds)\n      m(newTree(nnkBracketExpr, x, newLit(2)), pat[2], conds)\n    of nnkPar:\n      if pat.len == 1:\n        m(x, pat[0], conds)\n      else:\n        error(\"invalid pattern\")\n    of nnkIdent:\n      let c = newTree(nnkStmtListExpr, newLetStmt(pat, x))\n      conds.add c\n      # XXX why is this 'isVal(pat)' and not 'isVal(x)'?\n      if ($pat)[^1] == 'c': c.add(getAst(isVal(x)))\n      else: c.add bindSym\"true\"\n    of nnkIntLit:\n      conds.add(getAst(isIntVal(x, pat.intVal)))\n    else:\n      error(\"invalid pattern\")\n\n  var conds = newTree(nnkBracket)\n  m(x, pat, conds)\n  result = nestList(!\"and\", conds)\n\n\nproc isMinusOne(n: PNode): bool =\n  n.kind in {nkCharLit..nkUInt64Lit} and n.intVal == -1\n\nproc pleViaModel(model: TModel; aa, bb: PNode): TImplication\n\nproc ple(m: TModel; a, b: PNode): TImplication =\n  template `<=?`(a,b): untyped = ple(m,a,b) == impYes\n  template `>=?`(a,b): untyped = ple(m, nkIntLit.newIntNode(b), a) == impYes\n\n  #   0 <= 3\n  if a.isValue and b.isValue:\n    return if leValue(a, b): impYes else: impNo\n\n  # use type information too:  x <= 4  iff  high(x) <= 4\n  if b.isValue and a.typ != nil and a.typ.isOrdinalType:\n    if lastOrd(a.typ) <= b.intVal: return impYes\n  # 3 <= x   iff  low(x) <= 3\n  if a.isValue and b.typ != nil and b.typ.isOrdinalType:\n    if firstOrd(b.typ) <= a.intVal: return impYes\n\n  # x <= x\n  if sameTree(a, b): return impYes\n\n  # 0 <= x.len\n  if b.getMagic in someLen and a.isValue:\n    if a.intVal <= 0: return impYes\n\n  #   x <= y+c  if 0 <= c and x <= y\n  #   x <= y+(-c)  if c <= 0  and y >= x\n  if b.getMagic in someAdd and zero() <=? b[2] and a <=? b[1]: return impYes\n\n  #   x+c <= y  if c <= 0 and x <= y\n  if a.getMagic in someAdd and a[2] <=? zero() and a[1] <=? b: return impYes\n\n  #   x <= y*c  if  1 <= c and x <= y  and 0 <= y\n  if b.getMagic in someMul:\n    if a <=? b[1] and one() <=? b[2] and zero() <=? b[1]: return impYes\n\n\n  if a.getMagic in someMul and a[2].isValue and a[1].getMagic in someDiv and\n      a[1][2].isValue:\n    # simplify   (x div 4) * 2 <= y   to  x div (c div d)  <= y\n    if ple(m, buildCall(opDiv, a[1][1], `|div|`(a[1][2], a[2])), b) == impYes:\n      return impYes\n\n  # x*3 + x == x*4. It follows that:\n  # x*3 + y <= x*4  if  y <= x  and 3 <= 4\n  if a =~ x*dc + y and b =~ x2*ec:\n    if sameTree(x, x2):\n      let ec1 = opAdd.buildCall(ec, minusOne())\n      if x >=? 1 and ec >=? 1 and dc >=? 1 and dc <=? ec1 and y <=? x:\n        return impYes\n  elif a =~ x*dc and b =~ x2*ec + y:\n    #echo \"BUG cam ehrer e \", a, \" <=? \", b\n    if sameTree(x, x2):\n      let ec1 = opAdd.buildCall(ec, minusOne())\n      if x >=? 1 and ec >=? 1 and dc >=? 1 and dc <=? ec1 and y <=? zero():\n        return impYes\n\n  #  x+c <= x+d  if c <= d. Same for *, - etc.\n  if a.getMagic in someBinaryOp and a.getMagic == b.getMagic:\n    if sameTree(a[1], b[1]) and a[2] <=? b[2]: return impYes\n    elif sameTree(a[2], b[2]) and a[1] <=? b[1]: return impYes\n\n  #   x div c <= y   if   1 <= c  and  0 <= y  and x <= y:\n  if a.getMagic in someDiv:\n    if one() <=? a[2] and zero() <=? b and a[1] <=? b: return impYes\n\n    #  x div c <= x div d  if d <= c\n    if b.getMagic in someDiv:\n      if sameTree(a[1], b[1]) and b[2] <=? a[2]: return impYes\n\n    # x div z <= x - 1   if  z <= x\n    if a[2].isValue and b.getMagic in someAdd and b[2].isMinusOne:\n      if a[2] <=? a[1] and sameTree(a[1], b[1]): return impYes\n\n  # slightly subtle:\n  # x <= max(y, z)  iff x <= y or x <= z\n  # note that 'x <= max(x, z)' is a special case of the above rule\n  if b.getMagic in someMax:\n    if a <=? b[1] or a <=? b[2]: return impYes\n\n  # min(x, y) <= z  iff x <= z or y <= z\n  if a.getMagic in someMin:\n    if a[1] <=? b or a[2] <=? b: return impYes\n\n  # use the knowledge base:\n  return pleViaModel(m, a, b)\n  #return doesImply(m, opLe.buildCall(a, b))\n\ntype TReplacements = seq[tuple[a,b: PNode]]\n\nproc replaceSubTree(n, x, by: PNode): PNode =\n  if sameTree(n, x):\n    result = by\n  elif hasSubTree(n, x):\n    result = shallowCopy(n)\n    for i in 0 .. safeLen(n)-1:\n      result.sons[i] = replaceSubTree(n.sons[i], x, by)\n  else:\n    result = n\n\nproc applyReplacements(n: PNode; rep: TReplacements): PNode =\n  result = n\n  for x in rep: result = result.replaceSubTree(x.a, x.b)\n\nproc pleViaModelRec(m: var TModel; a, b: PNode): TImplication =\n  # now check for inferrable facts: a <= b and b <= c  implies a <= c\n  for i in 0..m.high:\n    let fact = m[i]\n    if fact != nil and fact.getMagic in someLe:\n      # mark as used:\n      m[i] = nil\n      # i <= len-100\n      # i <=? len-1\n      # --> true  if  (len-100) <= (len-1)\n      let x = fact[1]\n      let y = fact[2]\n      if sameTree(x, a) and y.getMagic in someAdd and b.getMagic in someAdd and\n         sameTree(y[1], b[1]):\n        if ple(m, b[2], y[2]) == impYes:\n          return impYes\n\n      # x <= y implies a <= b  if  a <= x and y <= b\n      if ple(m, a, x) == impYes:\n        if ple(m, y, b) == impYes:\n          return impYes\n        #if pleViaModelRec(m, y, b): return impYes\n      # fact:  16 <= i\n      #         x    y\n      # question: i <= 15? no!\n      result = impliesLe(fact, a, b)\n      if result != impUnknown:\n        return result\n      when false:\n        # given: x <= y;  y==a;  x <= a this means: a <= b  if  x <= b\n        if sameTree(y, a):\n          result = ple(m, b, x)\n          if result != impUnknown:\n            return result\n\nproc pleViaModel(model: TModel; aa, bb: PNode): TImplication =\n  # compute replacements:\n  var replacements: TReplacements = @[]\n  for fact in model:\n    if fact != nil and fact.getMagic in someEq:\n      let a = fact[1]\n      let b = fact[2]\n      if a.kind == nkSym: replacements.add((a,b))\n      else: replacements.add((b,a))\n  var m: TModel\n  var a = aa\n  var b = bb\n  if replacements.len > 0:\n    m = @[]\n    # make the other facts consistent:\n    for fact in model:\n      if fact != nil and fact.getMagic notin someEq:\n        # XXX 'canon' should not be necessary here, but it is\n        m.add applyReplacements(fact, replacements).canon\n    a = applyReplacements(aa, replacements)\n    b = applyReplacements(bb, replacements)\n  else:\n    # we have to make a copy here, because the model will be modified:\n    m = model\n  result = pleViaModelRec(m, a, b)\n\nproc proveLe*(m: TModel; a, b: PNode): TImplication =\n  let x = canon(opLe.buildCall(a, b))\n  #echo \"ROOT \", renderTree(x[1]), \" <=? \", renderTree(x[2])\n  result = ple(m, x[1], x[2])\n  if result == impUnknown:\n    # try an alternative:  a <= b  iff  not (b < a)  iff  not (b+1 <= a):\n    let y = canon(opLe.buildCall(opAdd.buildCall(b, one()), a))\n    result = ~ple(m, y[1], y[2])\n\nproc addFactLe*(m: var TModel; a, b: PNode) =\n  m.add canon(opLe.buildCall(a, b))\n\nproc settype(n: PNode): PType =\n  result = newType(tySet, n.typ.owner)\n  addSonSkipIntLit(result, n.typ)\n\nproc buildOf(it, loc: PNode): PNode =\n  var s = newNodeI(nkCurly, it.info, it.len-1)\n  s.typ = settype(loc)\n  for i in 0..it.len-2: s.sons[i] = it.sons[i]\n  result = newNodeI(nkCall, it.info, 3)\n  result.sons[0] = newSymNode(opContains)\n  result.sons[1] = s\n  result.sons[2] = loc\n\nproc buildElse(n: PNode): PNode =\n  var s = newNodeIT(nkCurly, n.info, settype(n.sons[0]))\n  for i in 1..n.len-2:\n    let branch = n.sons[i]\n    assert branch.kind == nkOfBranch\n    for j in 0..branch.len-2:\n      s.add(branch.sons[j])\n  result = newNodeI(nkCall, n.info, 3)\n  result.sons[0] = newSymNode(opContains)\n  result.sons[1] = s\n  result.sons[2] = n.sons[0]\n\nproc addDiscriminantFact*(m: var TModel, n: PNode) =\n  var fact = newNodeI(nkCall, n.info, 3)\n  fact.sons[0] = newSymNode(opEq)\n  fact.sons[1] = n.sons[0]\n  fact.sons[2] = n.sons[1]\n  m.add fact\n\nproc addAsgnFact*(m: var TModel, key, value: PNode) =\n  var fact = newNodeI(nkCall, key.info, 3)\n  fact.sons[0] = newSymNode(opEq)\n  fact.sons[1] = key\n  fact.sons[2] = value\n  m.add fact\n\nproc sameSubexprs*(m: TModel; a, b: PNode): bool =\n  # This should be used to check whether two *path expressions* refer to the\n  # same memory location according to 'm'. This is tricky:\n  # lock a[i].guard:\n  #   ...\n  #   access a[i].guarded\n  #\n  # Here a[i] is the same as a[i] iff 'i' and 'a' are not changed via '...'.\n  # However, nil checking requires exactly the same mechanism! But for now\n  # we simply use sameTree and live with the unsoundness of the analysis.\n  var check = newNodeI(nkCall, a.info, 3)\n  check.sons[0] = newSymNode(opEq)\n  check.sons[1] = a\n  check.sons[2] = b\n  result = m.doesImply(check) == impYes\n\nproc addCaseBranchFacts*(m: var TModel, n: PNode, i: int) =\n  let branch = n.sons[i]\n  if branch.kind == nkOfBranch:\n    m.add buildOf(branch, n.sons[0])\n  else:\n    m.add n.buildElse.neg\n\nproc buildProperFieldCheck(access, check: PNode): PNode =\n  if check.sons[1].kind == nkCurly:\n    result = copyTree(check)\n    if access.kind == nkDotExpr:\n      var a = copyTree(access)\n      a.sons[1] = check.sons[2]\n      result.sons[2] = a\n      # 'access.kind != nkDotExpr' can happen for object constructors\n      # which we don't check yet\n  else:\n    # it is some 'not'\n    assert check.getMagic == mNot\n    result = buildProperFieldCheck(access, check.sons[1]).neg\n\nproc checkFieldAccess*(m: TModel, n: PNode) =\n  for i in 1..n.len-1:\n    let check = buildProperFieldCheck(n.sons[0], n.sons[i])\n    if check != nil and m.doesImply(check) != impYes:\n      message(n.info, warnProveField, renderTree(n.sons[0])); break\n",
			"file": "Nim/nim/guards.d",
			"file_size": 34752,
			"file_write_time": 131395314580000000,
			"settings":
			{
				"buffer_size": 34752,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/dinrus/dev/DINRUS",
		"/D/dinrus/dev/DINRUS/DRC"
	],
	"file_history":
	[
		"/D/dinrus/dev/DINRUS/Base/base/stdrus.d",
		"/D/dinrus/dev/DINRUS/Base/base/sys/WinProcess.d",
		"/D/dinrus/dev/DINRUS/Base000/import/tpl/stream.d",
		"/D/dinrus/dev/DINRUS/Base/import/tpl/stream.d",
		"/D/dinrus/dev/DINRUS/Base/import/sys/WinIfaces.d",
		"/D/dinrus/dev/DINRUS/Base000/base/tpl/stream.d",
		"/D/dinrus/dev/DINRUS/Base/base/tpl/stream.d",
		"/D/dinrus/dev/DINRUS/Base/base/sys/WinIfaces.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/DND.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/DC.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Dialog.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/DirDialog.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Display.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/DisplayChangedEvent.d",
		"/D/dinrus/dev/DINRUS/DinrusGTK/gtkD/atk/Action.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Document.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/EraseEvent.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Event.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/DbGrid.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Clipboard.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/CloseEvent.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Colour.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ColourDialog.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ComboBox.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/CommandEvent.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/common.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Config.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ContextMenuEvent.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Control.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Cursor.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/DataFormat.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/DataObject.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/CalendarCtrl.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Caret.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/CheckBox.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ChildFocusEvent.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Choice.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ChoiceDialog.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ClientData.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/BitmapButton.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/BoxSizer.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Brush.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Button.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ActivateEvent.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/App.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ArrayInt.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ArrayString.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/ArtProvider.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Bitmap.d",
		"/D/dinrus/dev/DINRUS/Base/Exe/drbuild.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/Accelerator.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/aui/DockArt.d",
		"/D/dinrus/dev/DINRUS/DinrusWX/import/wxd/aui/FrameManager.d",
		"/D/dinrus/dev/DINRUS/DinrusGTK/src/atk/Action.d",
		"/D/dinrus/dev/DINRUS/DinrusCommon/DinrusCommon.cbp",
		"/D/dinrus/dev/DINRUS/DinrusConc/DinrusConc.cbp",
		"/D/dinrus/dev/DINRUS/DinrusDbi/DinrusDbi.cbp",
		"/D/dinrus/dev/DINRUS/DinrusTango/DinrusTango.cbp",
		"/D/dinrus/dev/DINRUS/DinrusWin32/DinrusWin32.cbp",
		"/D/dinrus/dev/DINRUS/postbuild.bat",
		"/E/LLVM/LDC/ddmd/access.d",
		"/E/LLVM/LDC/ddmd/aggregate.d",
		"/E/LLVM/LDC/ddmd/root/aav.d",
		"/E/LLVM/LDC/ddmd/root/array.d",
		"/E/LLVM/LDC/ir/iraggr.cpp"
	],
	"find":
	{
		"height": 23.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"();\n"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Base/import/stdrus.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 48104,
						"regions":
						{
						},
						"selection":
						[
							[
								37796,
								37796
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 21498.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "DRC/src/SettingsLoader.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11231,
						"regions":
						{
						},
						"selection":
						[
							[
								1,
								1
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4950.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Nim/nim/dfa.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 56193,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 25785.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "Nim/nim/guards.d",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 34752,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/D/D.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 12915.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 27.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "obzor.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 213.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
