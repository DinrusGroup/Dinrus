module sys.WinProcess;
import cidrus, stdrus, tpl.stream;

alias ППоток ПотокПроцессов;
export class ППоток : Поток 
{


    /** Первый инициализационный шаг: this, 
	*   с последующим пустом процесса, основанного на результате.
	*/
 private
{ 
    private:
    
        /** Хэндл данного процесса */
        ук пхэндл;
        
        /** Значение на выходе */
        бцел выхзнач;
    
        /** Входной пайп */
        ук вхПайпЧтен, вхПайпЗап;
        
        /** Выходной пайп */
        ук выхПайпЧтен, выхПайпЗап;


 проц иниц1()
    {
        читаемый(да);
        записываемый(да);
        сканируемый(нет);
        
            БЕЗАТРЫ ба;
            ба.длина = БЕЗАТРЫ.sizeof;
            ба.наследДескр = 1;
            СоздайПайп(&вхПайпЧтен, &вхПайпЗап, &ба, 0);
            СоздайПайп(&выхПайпЧтен, &выхПайпЗап, &ба, 0);
        
    }
	
	    /** Вторая часть инициализации */
    проц иниц2()
    {
        открыт(да);
    }
    
}

export:
    
    /** Use cidrus.система */
    this(ткст команда)
    {
        иниц1();
        
            ИНФОСТАРТА инфоСтарта;
            инфоСтарта.размер = ИНФОСТАРТА.sizeof;
            инфоСтарта.стдвво = вхПайпЧтен;
            инфоСтарта.стдвыв = выхПайпЗап;
            инфоСтарта.стдош = выхПайпЗап;
            инфоСтарта.флаги = 256;
            
            ИНФОПРОЦ инфоПроц;
            
            СоздайПроцесс(null, stdrus.вЮ16(команда), null, null,
                           1, cast(ПФлагСоздПроц) 0, null, null, &инфоСтарта, &инфоПроц);
            ЗакройДескр(вхПайпЧтен);
            ЗакройДескр(выхПайпЗап);
            ЗакройДескр(инфоПроц.нить);
            пхэндл = инфоПроц.процесс;
        
        
        иниц2();
    }
    


    override т_мера читайБлок(ук буфер, т_мера размер)
    {
            бцел rd;
            if (!ЧитайФайл(выхПайпЧтен, буфер, размер, &rd, null)) {
                читатьдоКФ(да);
                return 0;
            } else {
                читатьдоКФ(нет);
            }
            return rd;
        
    }
    
    override т_мера пишиБлок(ук буфер, т_мера размер)
    {
            бцел wt;
            if (!ПишиФайл(выхПайпЧтен, буфер, размер, &wt, null)) {
                читатьдоКФ(да);
                return 0;
            } else {
                читатьдоКФ(нет);
            }
            return wt;
        
    }
    
    override бдол сместись(дол смещение, ППозКурсора кгде)
    {
        throw new Исключение("Смещение в ППотоках невозможно");
    }
    
    /** Закрыть процесс, вернуть результат */
    проц закрой()
    {
        if (открыт()) {
            открыт(нет);
			бцел *выхзнач;
			ДайКодВыходаПроцесса(пхэндл, выхзнач);
              ЗакройДескр(пхэндл);
             ЗакройДескр(вхПайпЗап);
               ЗакройДескр(выхПайпЧтен);
			 this.выхзнач = cast(бцел) выхзнач;
            
        }
    }
    
        /** Получить значение выхода */
        бцел значВыхода()
        {
            return выхзнач;
        }  
    

    
}

/** Exception to be thrown when a command called dies */
class ИсклУгасшегоПроцесса : Исключение {

    this(ткст smsg)
    {
        super(smsg);
    }
}

export extern(C):
/** cidrus.система + гарантированный успех */
проц сисИлиАборт(ткст кмнд)
{
    цел рез;
    слейфл(cidrus.стдвых); слейфл(cidrus.стдош);
    рез = cidrus.система(кмнд);
    if (рез)  // CyberShadow 2007.02.22: Display a message before exiting
    {
        цел p = кмнд.найди(' ');
        if(p!=-1) кмнд=кмнд[0..p];
        скажифнс("Команда " ~ кмнд ~ " завершилась с кодом выхода ", рез, ", программа прерывается.");
        throw new ИсклУгасшегоПроцесса("Команда не удалась, последует выход.");
    }
}

/** cidrus.система + output */
цел скажиИСис(ткст кмнд)
{
    скажифнс("+ %s", кмнд);
    слейфл(cidrus.стдвых); слейфл(cidrus.стдош);
    return cidrus.система(кмнд);
}

/** сисИлиАборт + output */
проц скажиСисАборт(ткст кмнд)
{
    скажифнс("+ %s", кмнд);
    сисИлиАборт(кмнд);
}

/** cidrus.система + use a response file */
цел сисРеспонс(ткст кмнд, ткст рфлаг, ткст рфайл, бул удалитьРФайл)
{
    цел ret;
    ткст[] элемс = разбей(кмнд, " ");
    
    /* the output is элемс past 1 joined with \n */
    ткст resp = объедини(элемс[1..$], "\n");
    пишиФайл(рфайл, resp);
    
    слейфл(cidrus.стдвых); слейфл(cidrus.стдош);
    ret = cidrus.система(элемс[0] ~ " " ~ рфлаг ~ рфайл);
    
    if (удалитьРФайл) удалиФайл(рфайл);
    
    return ret;
}

/** systemResponse + guarantee success */
проц сисРИлиАборт(ткст кмнд, ткст рфлаг, ткст рфайл, бул удалитьРФайл)
{
    цел рез;
    рез = сисРеспонс(кмнд, рфлаг, рфайл, удалитьРФайл);
    if (рез)  // CyberShadow 2007.02.22: Display a message before exiting
    {
        цел p = кмнд.найди(' ');
        if(p!=-1) кмнд=кмнд[0..p];
        скажифнс("Команда " ~ кмнд ~ " завершилась с кодом ", рез, ", прерывание программы.");
        throw new ИсклУгасшегоПроцесса("Неудачная команда, аборт.");
    }
}

/** systemResponse + output */
цел скажиИСисР(ткст кмнд, ткст рфлаг, ткст рфайл, бул удалитьРФайл)
{
    скажифнс("+ %s", кмнд);
    return сисРеспонс(кмнд, рфлаг, рфайл, удалитьРФайл);
}

/** systemROrDie + output */
проц скажиСисРАборт(ткст кмнд, ткст рфлаг, ткст рфайл, бул удалитьРФайл)
{
    скажифнс("+ %s", кмнд);
    сисРИлиАборт(кмнд, рфлаг, рфайл, удалитьРФайл);
}
