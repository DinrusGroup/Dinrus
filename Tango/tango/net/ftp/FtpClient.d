/**
 * Author:          Lester L. Martin II
 *                  UWB, bobef
 * Copyright:       (c) Lester L. Martin II
 *                  UWB, bobef
 * Based upon prior FtpClient.d 
 * License:         BSD стиль: $(LICENSE)
 * Initial release:  August 8, 2008  
 */

module net.ftp.FtpClient;

private 
{
    import net.ftp.Telnet;
    import text.Util;
    import time.Clock;
    import text.Regex: Regex;
    import time.chrono.Gregorian;
    import Array;
    import net.device.Socket;
    import io.device.Conduit;
    import io.device.Array;
    import io.device.File;

    import Text = text.Util;
    import Ascii = text.Ascii;
    import Целое = text.convert.Integer;
    import Timestamp = text.convert.TimeStamp;
}

/******************************************************************************
 An FTP ход delegate.
 
 You may need в_ добавь the restart позиция в_ this, and use SIZE в_ determine
 percentage completion.  This only represents the число of байты
 transferred.
 
 Параметры:
 поз =                 the current смещение преобр_в the поток
 ******************************************************************************/
alias проц delegate(in т_мера поз) ХодФтп;

/******************************************************************************
 The форматируй of данные перемести.
 ******************************************************************************/
enum ПФорматФтп 
{
    /**********************************************************************
     Indicates ASCII NON PRINT форматируй (строка ending conversion в_ CRLF.)
     **********************************************************************/
    аски,
    /**********************************************************************
     Indicates IMAGE форматируй (8 bit binary octets.)
     **********************************************************************/
    образ,
}

/******************************************************************************
 A АдресФтп structure that содержит все 
 that is needed в_ access a СоединениеФтп; Contributed by Bobef
 
 Since: 0.99.8
 ******************************************************************************/
struct АдресФтп 
{
    static АдресФтп* opCall(ткст ткт) {
        if(ткт.length == 0)
            return пусто;
        try {
            auto ret = new АдресФтп;
            //удали ftp://
            auto i = locatePattern(ткт, "ftp://");
            if(i == 0)
                ткт = ткт[6 .. $];

            //check for ник and/or пароль пользователь[:пароль]@
            i = locatePrior(ткт, '@');
            if(i != ткт.length) {
                ткст up = ткт[0 .. i];
                ткт = ткт[i + 1 .. $];
                i = locate(up, ':');
                if(i != up.length) {
                    ret.пользователь = up[0 .. i];
                    ret.пароль = up[i + 1 .. $];
                } else
                    ret.пользователь = up;
            }

            //check for порт
            i = locatePrior(ткт, ':');
            if(i != ткт.length) {
                ret.порт = cast(бцел) Целое.toLong(ткт[i + 1 .. $]);
                ткт = ткт[0 .. i];
            }

            //check any directories after the adress
            i = locate(ткт, '/');
            if(i != ткт.length)
                ret.дир = ткт[i + 1 .. $];

            //the rest should be the адрес
            ret.адрес = ткт[0 .. i];
            if(ret.адрес.length == 0)
                return пусто;

            return ret;

        } catch(Объект o) {
            return пусто;
        }
    }

    ткст адрес;
    ткст дир;
    ткст пользователь = "anonymous";
    ткст пароль = "anonymous@anonymous";
    бцел порт = 21;
}

/******************************************************************************
 A сервер ответ, consisting of a код and a potentially multi-строка 
 сообщение.
 ******************************************************************************/
struct ОтветФтп 
{
    /**********************************************************************
     The ответ код.
     
     The digits in the ответ код can be used в_ determine статус
     programatically.
     
     First Digit (статус):
     1xx =             a positive, but preliminary, reply
     2xx =             a positive reply indicating completion
     3xx =             a positive reply indicating incomplete статус
     4xx =             a temporary negative reply
     5xx =             a permanent negative reply
     
     сукунда Digit (субъект):
     x0x =             condition based on syntax
     x1x =             informational
     x2x =             connection
     x3x =             authentication/process
     x5x =             файл system
     **********************************************************************/
    сим[3] код = "000";

    /*********************************************************************
     The сообщение из_ the сервер.
     
     With some responses, the сообщение may contain parseable information.
     For example, this is да of the 257 ответ.
     **********************************************************************/
    ткст сообщение = пусто;
}

/******************************************************************************
 Active or пассивное connection режим.
 ******************************************************************************/
enum ПТипСоединенияФтп 
{
    /**********************************************************************
     Active - сервер connects в_ клиент on открой порт.
     **********************************************************************/
    активное,
    /**********************************************************************
     Passive - сервер listens for a connection из_ the клиент.
     **********************************************************************/
    пассивное,
}

/******************************************************************************
 Detail about the данные connection.
 
 This is used в_ properly шли PORT and PASV commands.
 ******************************************************************************/
struct ДеталиПодключенияФтп 
{
    /**********************************************************************
     The тип в_ be used.
     **********************************************************************/
    ПТипСоединенияФтп тип = ПТипСоединенияФтп.пассивное;

    /**********************************************************************
     The адрес в_ give the сервер.
     **********************************************************************/
    адрес адрес = пусто;

    /**********************************************************************
     The адрес в_ actually слушай on.
     **********************************************************************/
    адрес слушай = пусто;
}

/******************************************************************************
 A supported feature of an FTP сервер.
 ******************************************************************************/
struct ЭлтФтп 
{
    /**********************************************************************
     The команда which is supported, e.g. SIZE.
     **********************************************************************/
    ткст команда = пусто;
    /**********************************************************************
     Параметры for this команда; e.g. факты for MLST.
     **********************************************************************/
    ткст params = пусто;
}

/******************************************************************************
 The тип of a файл in an FTP listing.
 ******************************************************************************/
enum ПТипФайлаФтп 
{
    /**********************************************************************
     An неизвестное файл or тип (no тип fact.)
     **********************************************************************/
    неизвестное,
    /**********************************************************************
     A regular файл, or similar.
     **********************************************************************/
    файл,
    /**********************************************************************
     The current дир (e.g. ., but not necessarily.)
     **********************************************************************/
    тдир,
    /**********************************************************************
     A предок дир (usually "..".)
     **********************************************************************/
    пдир,
    /**********************************************************************
     Any другой тип of дир.
     **********************************************************************/
    Пап,
    /**********************************************************************
     другой тип of файл.  Consult the "тип" fact.
     **********************************************************************/
    другой,
}

/******************************************************************************
 Information about a файл in an FTP listing.
 ******************************************************************************/
struct ИнфОФайлеФтп 
{
    /**********************************************************************
     The имяф.
     **********************************************************************/
    ткст имя = пусто;
    /**********************************************************************
     Its тип.
     **********************************************************************/
    ПТипФайлаФтп тип = ПТипФайлаФтп.неизвестное;
    /**********************************************************************
     Size in байты (8 bit octets), or бдол.max if not available.
     Since: 0.99.8
     **********************************************************************/
    бдол размер = бдол.max;
    /**********************************************************************
     Modification время, if available.
     **********************************************************************/
    Время modify = Время.макс;
    /**********************************************************************
     Creation время, if available (not often.)
     **********************************************************************/
    Время создай = Время.макс;
    /**********************************************************************
     The файл's mime тип, if known.
     **********************************************************************/
    ткст mime = пусто;
    /***********************************************************************
     An associative Массив of все факты returned by the сервер, lowercased.
     ***********************************************************************/
    ткст[ткст] факты;
}

/*******************************************************************************
 Changed location Since: 0.99.8
 Documentation Pending
 *******************************************************************************/
class ИсклФтп: Исключение 
{
    сим[3] responseCode_ = "000";

    /***********************************************************************
     Construct an ИсклФтп based on a сообщение and код.
     
     Параметры:
     сообщение =         the исключение сообщение
     код =            the код (5xx for фатал ошибки)
     ***********************************************************************/
    this(ткст сообщение, сим[3] код = "420") {
        this.responseCode_[] = код;
        super(сообщение);
    }

    /***********************************************************************
     Construct an ИсклФтп based on a ответ.
     
     Параметры:
     r =               the сервер ответ
     ***********************************************************************/
    this(ОтветФтп r) {
        this.responseCode_[] = r.код;
        super(r.сообщение);
    }

    /***********************************************************************
     A ткст representation of the ошибка.
     ***********************************************************************/
    ткст вТкст() {
        ткст буфер = new сим[this.сооб.length + 4];

        буфер[0 .. 3] = this.responseCode_;
        буфер[3] = ' ';
        буфер[4 .. буфер.length] = this.сооб;

        return буфер;
    }
}

/*******************************************************************************
 Seriously изменён Since: 0.99.8
 Documentation pending
 *******************************************************************************/
class СоединениеФтп: Telnet 
{

    ЭлтФтп[] supportedFeatures_ = пусто;
    ДеталиПодключенияФтп inf_;
    т_мера restartPos_ = 0;
    ткст currFile_ = "";
    Сокет dataСОКЕТ_;
    ИнтервалВремени timeout_ = ИнтервалВремени.изМиллисек(5000);

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    public ИнтервалВремени таймаут() {
        return timeout_;
    }

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    public проц таймаут(ИнтервалВремени t) {
        timeout_ = t;
    }

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    public ИнтервалВремени времяШатдауна() {
        return timeout_ + timeout_;
    }

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    public ЭлтФтп[] поддерживаемыеВозможности() {
        if(supportedFeatures_ !is пусто) {
            return supportedFeatures_;
        }
        дайВозможности();
        return supportedFeatures_;
    }

    /***********************************************************************
     Changed Since: 0.99.8
     ***********************************************************************/
    проц исключение(ткст сообщение) {
        throw new ИсклФтп(сообщение);
    }

    /***********************************************************************
     Changed Since: 0.99.8
     ***********************************************************************/
    проц исключение(ОтветФтп fr) {
        исключение(fr.сообщение);
    }

    public this() {

    }

    public this(ткст имя_хоста, ткст ник = "anonymous",
            ткст пароль = "anonymous@anonymous", бцел порт = 21) {
        this.подключись(имя_хоста, ник, пароль, порт);
    }

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    public this(АдресФтп fad) {
        подключись(fad);
    }

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    public проц подключись(АдресФтп fad) {
        this.подключись(fad.адрес, fad.пользователь, fad.пароль, fad.порт);
    }

    /************************************************************************
     Changed Since: 0.99.8
     ************************************************************************/
    public проц подключись(ткст имя_хоста, ткст ник = "anonymous",
            ткст пароль = "anonymous@anonymous", бцел порт = 21)
    in {
        // We definitely need a имя_хоста and порт.
        assert(имя_хоста.length > 0);
        assert(порт > 0);
    }
    body {

        if(сокет_ !is пусто) {
            сокет_.закрой();
        }

        this.найдиДоступныйСервер(имя_хоста, порт);

        scope(failure) {
            закрой();
        }

        читайОтвет("220");

        if(ник.length == 0) {
            return;
        }

        шлиКоманду("USER", ник);
        ОтветФтп ответ = читайОтвет();

        if(ответ.код == "331") {
            шлиКоманду("PASS", пароль);
            ответ = читайОтвет();
        }

        if(ответ.код != "230" && ответ.код != "202") {
            исключение(ответ);
        }
    }

    public проц закрой() {
        //сделай sure no открой данные connection and if открой данные connection then затуши
        if(dataСОКЕТ_ !is пусто)
            this.завершиКомандуДанных(dataСОКЕТ_);
        if(сокет_ !is пусто) {
            try {
                шлиКоманду("QUIT");
                читайОтвет("221");
            } catch(ИсклФтп) {

            }

            сокет_.закрой();

            delete supportedFeatures_;
            delete сокет_;
        }
    }

    public проц устПассив() {
        inf_.тип = ПТипСоединенияФтп.пассивное;

        delete inf_.адрес;
        delete inf_.слушай;
    }

    public проц устАктив(ткст ИП, бкрат порт, ткст ип_прослушки = пусто,
            бкрат порт_прослушки = 0)
    in {
        assert(ИП.length > 0);
        assert(порт > 0);
    }
    body {
        inf_.тип = ПТипСоединенияФтп.активное;
        inf_.адрес = new АдресИПв4(ИП, порт);

        // A local-sопрe порт?
        if(порт_прослушки == 0)
            порт_прослушки = порт;

        // Any specific ИП в_ слушай on?
        if(ип_прослушки == пусто)
            inf_.слушай = new АдресИПв4(АдресИПв4.АДР_ЛЮБОЙ, порт_прослушки);
        else
            inf_.слушай = new АдресИПв4(ип_прослушки, порт_прослушки);
    }

    public проц cd(ткст Пап)
    in {
        assert(Пап.length > 0);
    }
    body {
        шлиКоманду("CWD", Пап);
        читайОтвет("250");
    }

    public проц cdup() {
        шлиКоманду("CDUP");
        ОтветФтп fr = читайОтвет();
        if(fr.код == "200" || fr.код == "250")
            return;
        else
            исключение(fr);
    }

    public ткст текрабпап() {
        шлиКоманду("PWD");
        auto ответ = читайОтвет("257");

        return разбор257(ответ);
    }

    public проц chmod(ткст путь, цел режим)
    in {
        assert(путь.length > 0);
        assert(режим >= 0 && (режим >> 16) == 0);
    }
    body {
        ткст врем = "000";
        // Convert our octal parameter в_ a ткст.
        Целое.форматируй(врем, cast(дол) режим, "o");
        шлиКоманду("SITE CHMOD", врем, путь);
        читайОтвет("200");
    }

    public проц del(ткст путь)
    in {
        assert(путь.length > 0);
    }
    body {
        шлиКоманду("DELE", путь);
        auto ответ = читайОтвет("250");

        //Try it as a дир, then...?
        if(ответ.код != "250")
            rm(путь);
    }

    public проц rm(ткст путь)
    in {
        assert(путь.length > 0);
    }
    body {
        шлиКоманду("RMD", путь);
        читайОтвет("250");
    }

    public проц переименуй(ткст old_path, ткст new_path)
    in {
        assert(old_path.length > 0);
        assert(new_path.length > 0);
    }
    body {
        // Rename из_... переименуй в_.  Pretty simple.
        шлиКоманду("RNFR", old_path);
        читайОтвет("350");

        шлиКоманду("RNTO", new_path);
        читайОтвет("250");
    }

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    цел exist(ткст файл) {
        try {
            auto fi = дайИнфОФайле(файл);
            if(fi.тип == ПТипФайлаФтп.файл) {
                return 1;
            } else if(fi.тип == ПТипФайлаФтп.пап || fi.тип == ПТипФайлаФтп.тдир || fi.тип == ПТипФайлаФтп.пдир) {
                return 2;
            }
        } catch(ИсклФтп o) {
            if(o.responseCode_ != "501") {
                return 0;
            }
        }
        return 0;
    }

    public т_мера размер(ткст путь, ПФорматФтп форматируй = ПФорматФтп.образ)
    in {
        assert(путь.length > 0);
    }
    body {
        тип(форматируй);

        шлиКоманду("SIZE", путь);
        auto ответ = this.читайОтвет("213");

        // Only try в_ разбор the numeric байты of the ответ.
        т_мера end_pos = 0;
        while(end_pos < ответ.сообщение.length) {
            if(ответ.сообщение[end_pos] < '0' || ответ.сообщение[end_pos] > '9')
                break;
            end_pos++;
        }

        return cast(цел) Целое.разбор((ответ.сообщение[0 .. end_pos]));
    }

    public проц тип(ПФорматФтп форматируй) {
        if(форматируй == ПФорматФтп.аски)
            шлиКоманду("TYPE", "A");
        else
            шлиКоманду("TYPE", "I");

        читайОтвет("200");
    }

    /***********************************************************************
     добавьed Since: 0.99.8
     ***********************************************************************/
    Время изменён(ткст файл)
    in {
        assert(файл.length > 0);
    }
    body {
        this.шлиКоманду("MDTM", файл);
        auto ответ = this.читайОтвет("213");

        // The whole ответ should be a значврем.
        return this.разборВремзнач(ответ.сообщение);
    }

    protected Время разборВремзнач(ткст значврем) {
        if(значврем.length < 14)
            throw new ИсклФтп("CLIENT: Unable в_ разбор значврем", "501");

        return Gregorian.generic.воВремя(
                Целое.atoi(значврем[0 .. 4]),
                Целое.atoi(значврем[4 .. 6]), 
                Целое.atoi(значврем[6 .. 8]),
                Целое.atoi(значврем[8 .. 10]),
                Целое.atoi(значврем[10 .. 12]),
                Целое.atoi(значврем[12 .. 14]));
    }

    public проц noop() {
        this.шлиКоманду("NOOP");
        this.читайОтвет("200");
    }

    public ткст mkdir(ткст путь)
    in {
        assert(путь.length > 0);
    }
    body {
        this.шлиКоманду("MKD", путь);
        auto ответ = this.читайОтвет("257");

        return this.разбор257(ответ);
    }

    public проц дайВозможности() {
        this.шлиКоманду("FEAT");
        auto ответ = this.читайОтвет();

        // 221 means FEAT is supported, and a список follows.  Otherwise we don't know...
        if(ответ.код != "211")
            delete supportedFeatures_;
        else {
            ткст[] lines = Text.splitLines(ответ.сообщение);

            // There are two ещё lines than features, but we also have FEAT.
            supportedFeatures_ = new ЭлтФтп[lines.length - 1];
            supportedFeatures_[0].команда = "FEAT";

            for(т_мера i = 1; i < lines.length - 1; i++) {
                т_мера поз = Text.locate(lines[i], ' ');

                supportedFeatures_[i].команда = lines[i][0 .. поз];
                if(поз < lines[i].length - 1)
                    supportedFeatures_[i].params = lines[i][поз + 1 .. lines[i].length];
            }

            delete lines;
        }
    }

    public проц шлиКоманду(ткст команда, ткст[] параметры...) {

        ткст СОКЕТCommand = команда;

        // Отправка the команда, параметры, and then a CRLF.

        foreach(ткст param; параметры) {
            СОКЕТCommand ~= " " ~ param;

        }

        СОКЕТCommand ~= "\r\n";

        debug(FtpDebug) {
            Стдвыв.форматнс("[шлиКоманду] Отправкаing команда '{0}'",
                    СОКЕТCommand);
        }
        отправьДанные(СОКЕТCommand);
    }

    public ОтветФтп читайОтвет(ткст ожидаемый_код) {
        debug(FtpDebug) {
            Стдвыв.форматнс("[читайОтвет] Expected Response {0}",
                    ожидаемый_код)();
        }
        auto ответ = читайОтвет();
        debug(FtpDebug) {
            Стдвыв.форматнс("[читайОтвет] Actual Response {0}", ответ.код)();
        }

        if(ответ.код != ожидаемый_код)
            исключение(ответ);

        return ответ;
    }

    public ОтветФтп читайОтвет() {
        assert(this.сокет_ !is пусто);

        // Pick a время at which we stop reading.  It can't take too дол, but it could take a bit for the whole ответ.
        Время end_time = Часы.сейчас + ИнтервалВремени.изМиллисек(2500) * 10;

        ОтветФтп ответ;
        ткст single_line = пусто;

        // Danger, Will Robinson, don't fall преобр_в an endless loop из_ a malicious сервер.
        while(Часы.сейчас < end_time) {
            single_line = this.читайСтроку();

            // This is the first строка.
            if(ответ.сообщение.length == 0) {
                // The first строка must have a код and then a пространство or hyphen.
                // #1
                // Response might be exactly 4 chars e.g. '230-'
                // (see ftp-stud.fht-esslingen.de or ftp.sunfreeware.com)
                if(single_line.length < 4) {
                    ответ.код[] = "500";
                    break;
                }

                // The код is the first three characters.
                ответ.код[] = single_line[0 .. 3];
                ответ.сообщение = single_line[4 .. single_line.length];
            }
            // This is either an extra строка, or the последний строка.
            else {
                ответ.сообщение ~= "\n";

                // If the строка starts like "123-", that is not часть of the ответ сообщение.
                if(single_line.length > 4 && single_line[0 .. 3] == ответ.код)
                    ответ.сообщение ~= single_line[4 .. single_line.length];
                // If it starts with a пространство, that isn't either.
                else if(single_line.length > 2 && single_line[0] == ' ')
                    ответ.сообщение ~= single_line[1 .. single_line.length];
                else
                    ответ.сообщение ~= single_line;
            }

            // We're готово if the строка starts like "123 ".  Otherwise we're not.
            // #1
            // Response might be exactly 4 chars e.g. '220 '
            // (see ftp.knoppix.nl)
            if(single_line.length >= 4 && single_line[0 .. 3] == ответ.код && single_line[3] == ' ')
                break;
        }

        return ответ;
    }

    protected ткст разбор257(ОтветФтп ответ) {
        ткст путь = new сим[ответ.сообщение.length];
        т_мера поз = 1, длин = 0;

        // Since it should be quoted, it есть в_ be at least 3 characters in length.
        if(ответ.сообщение.length <= 2)
            исключение(ответ);

        //assert (ответ.сообщение[0] == '"');

        // Trapse through the ответ...
        while(поз < ответ.сообщение.length) {
            if(ответ.сообщение[поз] == '"') {
                // #2
                // Is it the последний character?
                if(поз + 1 == ответ.сообщение.length)
                    // then we are готово
                    break;

                // An escaped quote, keep going.  Нет alarm.
                if(ответ.сообщение[++поз] == '"')
                    путь[длин++] = ответ.сообщение[поз];
                else
                    break;
            } else
                путь[длин++] = ответ.сообщение[поз];

            поз++;
        }

        // Okay, готово!  That wasn't too hard.
        путь.length = длин;
        return путь;
    }

    /*******************************************************************************
     Get a данные сокет из_ the сервер.
     
     This Отправкаs PASV/PORT as necessary.
     
     Возвращает:             the данные сокет or a listener
     Changed Since: 0.99.8
     *******************************************************************************/
    protected Сокет дайСокетДанных() {
        //сделай sure no открой данные connection and if открой данные connection then затуши
        if(dataСОКЕТ_ !is пусто)
            this.завершиКомандуДанных(dataСОКЕТ_);

        // What тип are we using?
        switch(this.inf_.тип) {
            default:
                исключение("неизвестное connection тип");

            // Passive is complicated.  Дескр it in другой member.
            case ПТипСоединенияФтп.пассивное:
                return this.подключисьПассивно();

            // Active is simpler, but not as fool-proof.
            case ПТипСоединенияФтп.активное:
                АдресИПв4 data_Addr = cast(АдресИПв4) this.inf_.адрес;

                // Start listening.
                Сокет listener = new Сокет;
                listener.свяжи(this.inf_.слушай);
                listener.сокет.слушай(32);

                // Use EPRT if we know it's supported.
                if(this.поддерживается_ли("EPRT")) {
                    сим[64] врем =void;

                    this.шлиКоманду("EPRT", Text.выкладка(врем, "|1|%0|%1|",
                            data_Addr.вТкстАдреса, data_Addr.вТкстПорта));
                    // this.шлиКоманду("EPRT", форматируй("|1|%s|%s|", data_Addr.вТкстАдреса(), data_Addr.вТкстПорта()));
                    this.читайОтвет("200");
                } else {
                    цел h1, h2, h3, h4, p1, p2;
                    h1 = (data_Addr.адр() >> 24) % 256;
                    h2 = (data_Addr.адр() >> 16) % 256;
                    h3 = (data_Addr.адр() >> 8_) % 256;
                    h4 = (data_Addr.адр() >> 0_) % 256;
                    p1 = (data_Addr.порт() >> 8_) % 256;
                    p2 = (data_Addr.порт() >> 0_) % 256;

                    // low overhead метод в_ форматируй a numerical ткст
                    сим[64] врем =void;
                    сим[20] foo =void;
                    auto ткт = Text.выкладка(врем, "%0,%1,%2,%3,%4,%5",
                                    Целое.форматируй(foo[0 .. 3], h1), 
                                    Целое.форматируй(foo[3 .. 6], h2), 
                                    Целое.форматируй(foo[6 .. 9], h3), 
                                    Целое.форматируй(foo[9 .. 12], h4), 
                                    Целое.форматируй(foo[12 .. 15], p1), 
                                    Целое.форматируй(foo[15 .. 18], p2));

                    // This formatting is weird.
                    // this.шлиКоманду("PORT", форматируй("%d,%d,%d,%d,%d,%d", h1, h2, h3, h4, p1, p2));

                    this.шлиКоманду("PORT", ткт);
                    this.читайОтвет("200");
                }

                return listener;
        }
    }

    /*******************************************************************************
     Отправка a PASV and initiate a connection.
     
     Возвращает:             a подключен сокет
     Changed Since: 0.99.8
     *******************************************************************************/
    public Сокет подключисьПассивно() {
        адрес connect_to = пусто;

        // SPSV, which is just a порт число.
        if(this.поддерживается_ли("SPSV")) {
            this.шлиКоманду("SPSV");
            auto ответ = this.читайОтвет("227");

            // Connecting в_ the same хост.
            АдресИПв4
                    remote = cast(АдресИПв4) this.сокет_.сокет.удалённыйАдрес();
            assert(remote !is пусто);

            бцел адрес = remote.адр();
            бцел порт = cast(цел) Целое.разбор(((ответ.сообщение)));

            connect_to = new АдресИПв4(адрес, cast(бкрат) порт);
        }
        // Extended пассивное режим (ИП v6, etc.)
        else if(this.поддерживается_ли("EPSV")) {
            this.шлиКоманду("EPSV");
            auto ответ = this.читайОтвет("229");

            // Try в_ pull out the (possibly not parenthesized) адрес.
            auto r = Regex(`\([^0-9][^0-9][^0-9](\d+)[^0-9]\)`);
            if(!r.тест(ответ.сообщение[0 .. найди(ответ.сообщение, '\n')]))
                throw new ИсклФтп("CLIENT: Unable в_ разбор адрес", "501");

            АдресИПв4
                    remote = cast(АдресИПв4) this.сокет_.сокет.удалённыйАдрес();
            assert(remote !is пусто);

            бцел адрес = remote.адр();
            бцел порт = cast(цел) Целое.разбор(((r.match(1))));

            connect_to = new АдресИПв4(адрес, cast(бкрат) порт);
        } else {
            this.шлиКоманду("PASV");
            auto ответ = this.читайОтвет("227");

            // Try в_ pull out the (possibly not parenthesized) адрес.
            auto r = Regex(`(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)(,\s*(\d+))?`);
            if(!r.тест(ответ.сообщение[0 .. найди(ответ.сообщение, '\n')]))
                throw new ИсклФтп("CLIENT: Unable в_ разбор адрес", "501");

            // Сейчас помести it преобр_в something std.сокет will understand.
            ткст адрес = r.match(1) ~ "." ~ r.match(2) ~ "." ~ r.match(3) ~ "." ~ r.match(4);
            бцел порт = (((cast(цел) Целое.разбор(r.match(5))) << 8) + (r.match(7).
                           length > 0 ? cast(цел) Целое.разбор(r.match(7)) : 0));

            // Okay, we've got it!
            connect_to = new АдресИПв4(адрес, порт);
        }

        scope(exit)
            delete connect_to;

        // This will throw an исключение if it cannot подключись.
        auto сок = new Сокет;
        сок.подключись(connect_to);
        return сок;
    }

    /*
     Сокет сок = new Сокет();
     сок.подключись(connect_to);
     return сок;
     */

    public бул поддерживается(ткст команда)
    in {
        assert(команда.length > 0);
    }
    body {
        if(this.supportedFeatures_.length == 0)
            return да;

        // Search through the список for the feature.
        foreach(ЭлтФтп feat; this.supportedFeatures_) {
            if(Ascii.icompare(feat.команда, команда) == 0)
                return да;
        }

        return нет;
    }

    public бул поддерживается_ли(ткст команда) {
        if(this.supportedFeatures_.length == 0)
            return нет;

        return this.поддерживается(команда);
    }

    /*******************************************************************************
     Prepare a данные сокет for use.
     
     This modifies the сокет in some cases.
     
     Параметры:
     данные =            the данные listener сокет
     Changed Since: 0.99.8
     ********************************************************************************/
    protected проц подготовьСокетДанных(ref Сокет данные) {
        switch(this.inf_.тип) {
            default:
                исключение("неизвестное connection тип");

            case ПТипСоединенияФтп.активное:
                Беркли new_data;

                scope установи = new НаборСокетов;

                // At end_time, we bail.
                Время end_time = Часы.сейчас + this.таймаут;

                while(Часы.сейчас < end_time) {
                    установи.сбрось();
                    установи.добавь(данные.сокет);

                    // Can we прими yet?
                    цел код = установи.выбери(установи, пусто, пусто, таймаут.micros);
                    if(код == -1 || код == 0)
                        break;

                    данные.сокет.прими(new_data);
                    break;
                }

            if(new_data.сок is new_data.сок.init)
               throw new ИсклФтп("CLIENT: No connection из_ сервер", "420");

            // We don't need the listener anymore.
            данные.глуши.открепи;

            // This is the actual сокет.
            данные.сокет.сок = new_data.сок;
            break;

            case ПТипСоединенияФтп.пассивное:
            break;
        }
    }

    /*****************************************************************************
     Changed Since: 0.99.8
     *****************************************************************************/
    public проц завершиКомандуДанных(Сокет данные) {
        // Close the сокет.  This tells the сервер we're готово (EOF.)
        данные.закрой();
        данные.открепи();

        // We shouldn't получи a 250 in Поток режим.
        ОтветФтп r = читайОтвет();
        if(!(r.код == "226" || r.код == "420"))
            исключение("Bad финиш");

    }

    /*****************************************************************************
     Changed Since: 0.99.8
     *****************************************************************************/
    public Сокет обработайКомандуДанных(ткст команда, ткст[] параметры...) {
        // Create a connection.
        Сокет данные = this.дайСокетДанных();
        scope(failure) {
            // Close the сокет, whether we were listening or not.
            данные.закрой();
        }

        // Tell the сервер about it.
        this.шлиКоманду(команда, параметры);

        // We should always получи a 150/125 ответ.
        auto ответ = this.читайОтвет();
        if(ответ.код != "150" && ответ.код != "125")
            исключение(ответ);

        // We might need в_ do this for активное connections.
        this.подготовьСокетДанных(данные);

        return данные;
    }

    public ИнфОФайлеФтп[] ls(ткст путь = "")
    // default в_ current Пап
    in {
        assert(путь.length == 0 || путь[путь.length - 1] != '/');
    }
    body {
        ИнфОФайлеФтп[] Пап;

        // We'll try MLSD (which is so much better) first... but it may краш.
        бул mlsd_success = нет;
        Сокет данные = пусто;

        // Try it if it could/might/maybe is supported.
        if(this.поддерживается("MLST")) {
            mlsd_success = да;

            // Since this is a данные команда, обработайКомандуДанных handles
            // checking the ответ... just catch its Исключение.
            try {
                if(путь.length > 0)
                    данные = this.обработайКомандуДанных("MLSD", путь);
                else
                    данные = this.обработайКомандуДанных("MLSD");
            } catch(ИсклФтп)
                mlsd_success = нет;
        }

        // If it passed, разбор away!
        if(mlsd_success) {
            auto listing = new Массив(256, 65536);
            this.читайПоток(данные, listing);
            this.завершиКомандуДанных(данные);

            // Each строка is something in that дир.
            ткст[] lines = Text.splitLines(cast(ткст) listing.срез());
            scope(exit)
                delete lines;

            foreach(ткст строка; lines) {
                if(строка.length == 0)
                    continue;
                // Parse each строка exactly like MLST does.
                try {
                    ИнфОФайлеФтп инфо = this.разборСтрокиМлст(строка);
                    if(инфо.имя.length > 0)
                        Пап ~= инфо;
                } catch(ИсклФтп) {
                    return this.шлиКомандуСписок(путь);
                }
            }

            return Пап;
        }
        // Fall back в_ LIST.
        else
            return this.шлиКомандуСписок(путь);
    }

    /*****************************************************************************
     Changed Since: 0.99.8
     *****************************************************************************/
    protected проц читайПоток(Сокет данные, ИПотокВывода поток,
            ХодФтп ход = пусто)
    in {
        assert(данные !is пусто);
        assert(поток !is пусто);
    }
    body {
        // Набор up a НаборСокетов so we can use выбери() - it's pretty efficient.
        scope установи = new НаборСокетов;

        // At end_time, we bail.
        Время end_time = Часы.сейчас + this.таймаут;

        // This is the буфер the поток данные is stored in.
        ббайт[8 * 1024] буф;
        цел buf_size = 0;

        бул completed = нет;
        т_мера поз;
        while(Часы.сейчас < end_time) {
            установи.сбрось();
            установи.добавь(данные.сокет);

            // Can we читай yet, can we читай yet?
            цел код = установи.выбери(установи, пусто, пусто, таймаут.micros);
            if(код == -1 || код == 0)
                break;

            buf_size = данные.сокет.принять(буф);
            if(buf_size == данные.сокет.ERROR)
                break;

            if(buf_size == 0) {
                completed = да;
                break;
            }

            поток.пиши(буф[0 .. buf_size]);

            поз += buf_size;
            if(ход !is пусто)
                ход(поз);

            // Give it ещё время as дол as данные is going through.
            end_time = Часы.сейчас + this.таймаут;
        }

        // Dопр все the данные получи Приёмd?
        if(!completed)
            throw new ИсклФтп("CLIENT: Timeout when reading данные", "420");
    }

    /*****************************************************************************
     Changed Since: 0.99.8
     *****************************************************************************/
    protected проц шлиВПоток(Сокет данные, ИПотокВвода поток,
            ХодФтп ход = пусто)
    in {
        assert(данные !is пусто);
        assert(поток !is пусто);
    }
    body {
        // Набор up a НаборСокетов so we can use выбери() - it's pretty efficient.
        scope установи = new НаборСокетов;

        // At end_time, we bail.
        Время end_time = Часы.сейчас + this.таймаут;

        // This is the буфер the поток данные is stored in.
        ббайт[8 * 1024] буф;
        т_мера buf_size = 0, buf_pos = 0;
        цел delta = 0;

        т_мера поз = 0;
        бул completed = нет;
        while(!completed && Часы.сейчас < end_time) {
            установи.сбрось();
            установи.добавь(данные.сокет);

            // Can we пиши yet, can we пиши yet?
            цел код = установи.выбери(пусто, установи, пусто, таймаут.micros);
            if(код == -1 || код == 0)
                break;

            if(buf_size - buf_pos <= 0) {
                if((buf_size = поток.читай(буф)) is поток.Кф)
                    buf_size = 0 , completed = да;
                buf_pos = 0;
            }

            // Отправка the chunk (or as much of it as possible!)
            delta = данные.сокет.шли(буф[buf_pos .. buf_size]);
            if(delta == данные.сокет.ERROR)
                break;

            buf_pos += delta;

            поз += delta;
            if(ход !is пусто)
                ход(поз);

            // Give it ещё время as дол as данные is going through.
            if(delta != 0)
                end_time = Часы.сейчас + this.таймаут;
        }

        // Dопр все the данные получи sent?
        if(!completed)
            throw new ИсклФтп("CLIENT: Timeout when Отправкаing данные", "420");
    }

    protected ИнфОФайлеФтп[] шлиКомандуСписок(ткст путь) {
        ИнфОФайлеФтп[] Пап;
        Сокет данные = пусто;

        if(путь.length > 0)
            данные = this.обработайКомандуДанных("LIST", путь);
        else
            данные = this.обработайКомандуДанных("LIST");

        // Чтен in the stupопр non-standardized ответ.
        auto listing = new Массив(256, 65536);
        this.читайПоток(данные, listing);
        this.завершиКомандуДанных(данные);

        // разбей out the lines.  Most of the время, it's one-в_-one.
        ткст[] lines = Text.splitLines(cast(ткст) listing.срез());
        scope(exit)
            delete lines;

        foreach(ткст строка; lines) {
            if(строка.length == 0)
                continue;
            // If there are no пробелы, or if there's only one... пропусти the строка.
            // This is probably like a "total 8" строка.
            if(Text.locate(строка, ' ') == Text.locatePrior(строка, ' '))
                continue;

            // Сейчас разбор the строка, or try в_.
            ИнфОФайлеФтп инфо = this.разборСтрокиСписка(строка);
            if(инфо.имя.length > 0)
                Пап ~= инфо;
        }

        return Пап;
    }

    protected ИнфОФайлеФтп разборСтрокиСписка(ткст строка) {
        ИнфОФайлеФтп инфо;
        т_мера поз = 0;

        // Convenience function в_ разбор a word из_ the строка.
        ткст parse_word() {
            т_мера старт = 0, конец = 0;

            // SkИП пробел before.
            while(поз < строка.length && строка[поз] == ' ')
                поз++;

            старт = поз;
            while(поз < строка.length && строка[поз] != ' ')
                поз++;
            конец = поз;

            // SkИП пробел after.
            while(поз < строка.length && строка[поз] == ' ')
                поз++;

            return строка[старт .. конец];
        }

        // We have в_ sniff this... :/.
        switch(!Text.содержит("0123456789", строка[0])) {
            // Not a число; this is ЮНИКС форматируй.
            case да:
                // The строка must be at least 20 characters дол.
                if(строка.length < 20)
                    return инфо;

                // The first character tells us what it is.
                if(строка[0] == 'd')
                    инфо.тип = ПТипФайлаФтп.пап;
                // #3
                // Might be a link Запись - добавьitional тест down below
                else if(строка[0] == 'l')
                    инфо.тип = ПТипФайлаФтп.другой;
                else if(строка[0] == '-')
                    инфо.тип = ПТипФайлаФтп.файл;
                else
                    инфо.тип = ПТипФайлаФтп.неизвестное;

                // Parse out the режим... rwxrwxrwx = 777.
                ткст unix_mode = "0000".dup;
                проц read_mode(цел цифра) {
                    for(поз = 1 + цифра * 3; поз <= 3 + цифра * 3; поз++) {
                        if(строка[поз] == 'r')
                            unix_mode[цифра + 1] |= 4;
                        else if(строка[поз] == 'w')
                            unix_mode[цифра + 1] |= 2;
                        else if(строка[поз] == 'x')
                            unix_mode[цифра + 1] |= 1;
                    }
                }

                // This makes it easier, huh?
                read_mode(0);
                read_mode(1);
                read_mode(2);

                инфо.факты["ЮНИКС.режим"] = unix_mode;

                // #4
                // Not only разбор lines like
                //    drwxrwxr-x    2 10490    100          4096 May 20  2005 Acrobat
                //    lrwxrwxrwx    1 корень     другой           7 Sep 21  2007 Broker.link -> Acrobat
                //    -rwxrwxr-x    1 filelib  100           468 Nov  1  1999 Web_Users_Click_Here.html
                // but also разбор lines like 
                //    d--x--x--x   2 staff        512 Sep 24  2000 dev
                // (see ftp.sunfreeware.com)

                // Links, хозяин.  These are hard в_ translate в_ MLST факты.
                parse_word();
                parse_word();

                // Group or размер in байты
                ткст group_or_size = parse_word();
                т_мера oldpos = поз;

                // Size in байты or месяц
                ткст size_or_month = parse_word();

                if(!Text.содержит("0123456789", size_or_month[0])) {
                    // Oops, no размер here - go back в_ previous column
                    поз = oldpos;
                    инфо.размер = cast(бдол) Целое.разбор(group_or_size);
                } else
                    инфо.размер = cast(бдол) Целое.разбор(size_or_month);

                // Make sure we still have enough пространство.
                if(поз + 13 >= строка.length)
                    return инфо;

                // Not parsing дата for сейчас.  It's too weird (последний 12 месяцы, etc.)
                поз += 13;

                инфо.имя = строка[поз .. строка.length];
                // #3
                // Might be a link Запись - добавьitional тест here
                if(инфо.тип == ПТипФайлаФтп.другой) {
                    // Is имя like 'имя -> /some/другой/путь'?
                    т_мера pos2 = Text.locatePattern(инфо.имя, " -> ");
                    if(pos2 != инфо.имя.length) {
                        // It is a link - разбей преобр_в мишень and имя
                        инфо.факты["мишень"] = инфо.имя[pos2 + 4 .. инфо.имя.length];
                        инфо.имя = инфо.имя[0 .. pos2];
                        инфо.факты["тип"] = "link";
                    }
                }
            break;

            // A число; this is DOS форматируй.
            case нет:
                // We need some данные here, в_ разбор.
                if(строка.length < 18)
                    return инфо;

                // The order is 1 MM, 2 DD, 3 YY, 4 HH, 5 MM, 6 P
                auto r = Regex(`(\d\d)-(\d\d)-(\d\d)\s+(\d\d):(\d\d)(A|P)M`);
                // #5
                // wrong тест
                if(!r.тест(строка))
                    return инфо;

                if(Timestamp.dostime(r.match(0), инфо.modify) is 0)
                    инфо.modify = Время.макс;

                поз = r.match(0).length;
                delete r;

                // This will either be <Пап>, or a число.
                ткст dir_or_size = parse_word();

                if(dir_or_size.length < 0)
                    return инфо;
                else if(dir_or_size[0] == '<')
                    инфо.тип = ПТипФайлаФтп.пап;
                else {
                    // #5
                    // It is a файл
                    инфо.размер = cast(бдол) Целое.разбор((dir_or_size));
                    инфо.тип = ПТипФайлаФтп.файл;
                }

                инфо.имя = строка[поз .. строка.length];
            break;

            // Something else, not supported.
            default:
                throw new ИсклФтп("CLIENT: Unsupported LIST форматируй", "501");
        }

        // Try в_ fix the тип?
        if(инфо.имя == ".")
            инфо.тип = ПТипФайлаФтп.тдир;
        else if(инфо.имя == "..")
            инфо.тип = ПТипФайлаФтп.пдир;

        return инфо;
    }

    protected ИнфОФайлеФтп разборСтрокиМлст(ткст строка) {
        ИнфОФайлеФтп инфо;

        // After this loop, filename_pos will be location of пространство + 1.
        т_мера filename_pos = 0;
        while(filename_pos < строка.length && строка[filename_pos++] != ' ')
            continue;

        if(filename_pos == строка.length)
            throw new ИсклФтп("CLIENT: Bad syntax in MLSx ответ", "501");
        /*{
         инфо.имя = "";
         return инфо;
         }*/

        инфо.имя = строка[filename_pos .. строка.length];

        // Everything else is frosting on top.
        if(filename_pos > 1) {
            ткст[]
                    temp_facts = Text.delimit(строка[0 .. filename_pos - 1], ";");

            // Go through each fact and разбор them преобр_в the Массив.
            foreach(ткст fact; temp_facts) {
                цел поз = Text.locate(fact, '=');
                if(поз == fact.length)
                    continue;

                инфо.факты[Ascii.toLower(fact[0 .. поз])] = fact[поз + 1 .. fact.length];
            }

            // Do we have a тип?
            if("тип" in инфо.факты) {
                // Some reflection might be nice here.
                switch(Ascii.toLower(инфо.факты["тип"])) {
                    case "файл":
                        инфо.тип = ПТипФайлаФтп.файл;
                    break;

                    case "тдир":
                        инфо.тип = ПТипФайлаФтп.тдир;
                    break;

                    case "пдир":
                        инфо.тип = ПТипФайлаФтп.пдир;
                    break;

                    case "Пап":
                        инфо.тип = ПТипФайлаФтп.пап;
                    break;

                    default:
                        инфо.тип = ПТипФайлаФтп.другой;
                }
            }

            // Size, mime, etc...
            if("размер" in инфо.факты)
                инфо.размер = cast(бдол) Целое.разбор((инфо.факты["размер"]));
            if("media-тип" in инфо.факты)
                инфо.mime = инфо.факты["media-тип"];

            // And the two dates.
            if("modify" in инфо.факты)
                инфо.modify = this.разборВремзнач(инфо.факты["modify"]);
            if("создай" in инфо.факты)
                инфо.создай = this.разборВремзнач(инфо.факты["создай"]);
        }

        return инфо;
    }

    public ИнфОФайлеФтп дайИнфОФайле(ткст путь)
    in {
        assert(путь.length > 0);
    }
    body {
        // Start assuming the MLST dопрn't work.
        бул mlst_success = нет;
        ОтветФтп ответ;
        auto inf = ls(путь);
        if(inf.length == 1)
            return inf[0];
        else {
            debug(FtpUnitTest) {
                Стдвыв("In дайИнфОФайле.").нс.слей;
            }
            {
                // Отправка a список команда.  This may список the contents of a дир, even.
                ИнфОФайлеФтп[] temp = this.шлиКомандуСписок(путь);

                // If there wasn't at least one строка, the файл dопрn't exist?
                // We should have already handled that.
                if(temp.length < 1)
                    throw new ИсклФтп(
                            "CLIENT: Bad LIST ответ из_ сервер", "501");

                // If there are multИПle lines, try в_ return the correct one.
                if(temp.length != 1)
                    foreach(ИнфОФайлеФтп инфо; temp) {
                        if(инфо.тип == ПТипФайлаФтп.тдир)
                            return инфо;
                    }

                // Okay then, the first строка.  Наилучший we can do?
                return temp[0];
            }
        }
    }

    public проц помести(ткст путь, ткст локальн_файл,
            ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.образ)
    in {
        assert(путь.length > 0);
        assert(локальн_файл.length > 0);
    }
    body {
        // Open the файл for reading...
        auto файл = new Файл(локальн_файл);
        scope(exit) {
            файл.открепи();
            delete файл;
        }

        // Seek в_ the correct place, if specified.
        if(this.restartPos_ > 0) {
            файл.сместись(this.restartPos_);
            this.restartPos_ = 0;
        } else {
            // Размести пространство for the файл, if we need в_.
            //this.размести(файл.length);
        }

        // Сейчас that it's открой, we do what we always do.
        this.помести(путь, файл, ход, форматируй);
    }

    /********************************************************************************
     Store данные из_ a поток on the сервер.
     
     Calling this function will change the current данные перемести форматируй.
     
     Параметры:
     путь =            the путь в_ the remote файл
     поток =          данные в_ сохрани, or пусто for a blank файл
     ход =        a delegate в_ вызов with ход information
     форматируй =          what форматируй в_ шли the данные in
     ********************************************************************************/
    public проц помести(ткст путь, ИПотокВвода поток = пусто,
            ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.образ)
    in {
        assert(путь.length > 0);
    }
    body {
        // Change в_ the specified форматируй.
        this.тип(форматируй);

        // Okay сервер, we want в_ сохрани something...
        Сокет данные = this.обработайКомандуДанных("STOR", путь);

        // Отправка the поток over the сокет!
        if(поток !is пусто)
            this.шлиВПоток(данные, поток, ход);

        this.завершиКомандуДанных(данные);
    }

    /********************************************************************************
     Append данные в_ a файл on the сервер.
     
     Calling this function will change the current данные перемести форматируй.
     
     Параметры:
     путь =            the путь в_ the remote файл
     поток =          данные в_ добавь в_ the файл
     ход =        a delegate в_ вызов with ход information
     форматируй =          what форматируй в_ шли the данные in
     ********************************************************************************/
    public проц добавь(ткст путь, ИПотокВвода поток,
            ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.образ)
    in {
        assert(путь.length > 0);
        assert(поток !is пусто);
    }
    body {
        // Change в_ the specified форматируй.
        this.тип(форматируй);

        // Okay сервер, we want в_ сохрани something...
        Сокет данные = this.обработайКомандуДанных("APPE", путь);

        // Отправка the поток over the сокет!
        this.шлиВПоток(данные, поток, ход);

        this.завершиКомандуДанных(данные);
    }

    /*********************************************************************************
     Seek в_ a байт смещение for the следщ перемести.
     
     Параметры:
     смещение =          the число of байты в_ сместись forward
     **********************************************************************************/
    public проц рестартСик(т_мера смещение) {
        сим[16] врем;
        this.шлиКоманду("REST", Целое.форматируй(врем, cast(дол) смещение));
        this.читайОтвет("350");

        // Набор this for later use.
        this.restartPos_ = смещение;
    }

    /**********************************************************************************
     Размести пространство for a файл.
     
     After calling this, добавь() or помести() should be the следщ команда.
     
     Параметры:
     байты =           the число of байты в_ размести
     ***********************************************************************************/
    public проц размести(дол байты)
    in {
        assert(байты > 0);
    }
    body {
        сим[16] врем;
        this.шлиКоманду("ALLO", Целое.форматируй(врем, байты));
        auto ответ = this.читайОтвет();

        // For our purposes 200 and 202 are Всё fine.
        if(ответ.код != "200" && ответ.код != "202")
            исключение(ответ);
    }

    /**********************************************************************************
     Retrieve a remote файл's contents преобр_в a local файл.
     
     Calling this function will change the current данные перемести форматируй.
     
     Параметры:
     путь =            the путь в_ the remote файл
     локальн_файл =      the путь в_ the local файл
     ход =        a delegate в_ вызов with ход information
     форматируй =          what форматируй в_ читай the данные in
     **********************************************************************************/
    public проц получи(ткст путь, ткст локальн_файл,
            ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.образ)
    in {
        assert(путь.length > 0);
        assert(локальн_файл.length > 0);
    }
    body {
        Файл файл = пусто;

        // We may either создай a new файл...
        if(this.restartPos_ == 0)
            файл = new Файл(локальн_файл, Файл.ЧитЗапСозд);
        // Or открой an existing файл, and сместись в_ the specified позиция (читай: not конец, necessarily.)
        else {
            файл = new Файл(локальн_файл, Файл.ReadWriteExisting);
            файл.сместись(this.restartPos_);

            this.restartPos_ = 0;
        }

        scope(exit) {
            файл.открепи();
            delete файл;
        }

        // Сейчас that it's открой, we do what we always do.
        this.получи(путь, файл, ход, форматируй);
    }

    /*********************************************************************************
     Enable UTF8 on servers that don't use this as default. Might need some work
     *********************************************************************************/
    public проц активируйУТФ8() {
        шлиКоманду("OPTS UTF8 ON");
        читайОтвет("200");
    }

    /**********************************************************************************
     Retrieve a remote файл's contents преобр_в a local файл.
     
     Calling this function will change the current данные перемести форматируй.
     
     Параметры:
     путь =            the путь в_ the remote файл
     поток =          поток в_ пиши the данные в_
     ход =        a delegate в_ вызов with ход information
     форматируй =          what форматируй в_ читай the данные in
     ***********************************************************************************/
    public проц получи(ткст путь, ИПотокВывода поток,
            ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.образ)
    in {
        assert(путь.length > 0);
        assert(поток !is пусто);
    }
    body {
        // Change в_ the specified форматируй.
        this.тип(форматируй);

        // Okay сервер, we want в_ получи this файл...
        Сокет данные = this.обработайКомандуДанных("RETR", путь);

        // Чтен the поток in из_ the сокет!
        this.читайПоток(данные, поток, ход);

        this.завершиКомандуДанных(данные);
    }

    /*****************************************************************************
     добавьed Since: 0.99.8
     *****************************************************************************/
    public ИПотокВвода ввод(ткст путь) {
        тип(ПФорматФтп.образ);
        dataСОКЕТ_ = this.обработайКомандуДанных("RETR", путь);
        return dataСОКЕТ_;
    }

    /*****************************************************************************
     добавьed Since: 0.99.8
     *****************************************************************************/
    public ИПотокВывода вывод(ткст путь) {
        тип(ПФорматФтп.образ); 
        dataСОКЕТ_ = this.обработайКомандуДанных("STOR", путь);
        return dataСОКЕТ_;
    }
}
