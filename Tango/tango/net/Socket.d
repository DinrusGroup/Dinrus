/*
        Copyright (C) 2004 Christopher E. Miller

        This software is provопрed 'as-is', without any express or implied
        warranty.  In no событие will the authors be held liable for any damages
        arising из_ the use of this software.

        Permission is granted в_ anyone в_ use this software for any purpose,
        включая commercial applications, and в_ alter it and redistribute it
        freely, субъект в_ the following restrictions:

        1. The origin of this software must not be misrepresented; you must not
           claim that you wrote the original software. If you use this software
           in a product, an acknowledgment in the product documentation would be
           appreciated but is not required.

        2. Altered источник versions must be plainly marked as such, and must not be
           misrepresented as being the original software.

        3. This notice may not be removed or altered из_ any источник distribution.

*/

/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. все rights reserved

        license:        BSD стиль: $(LICENSE)

        version:        Initial release: March 2004

        author:         Christopher Miller
                        Kris Bell
                        Anders F Bjorklund (Darwin patches)


        The original код есть been изменён in several ways:

        1) It есть been altered в_ fit within the Dinrus environment, meaning
           that certain original classes have been reorganized, and/or have
           subclassed Dinrus основа-classes. For example, the original Сокет
           class есть been wrapped with three distinct subclasses, and сейчас
           derives из_ class io.Resource.

        2) все исключение instances сейчас subclass the Dinrus ВВИскл.

        3) Construction of new Сокет instances via прими() is сейчас
           overloadable.

        4) Constants and enums have been moved within a class boundary в_
           ensure explicit namespace usage.

        5) изменён Сокет.выбери() в_ loop if it was interrupted.


        все changes within the main body of код все marked with "Dinrus:"

        For a good tutorial on сокет-programming I highly recommend going
        here: http://www.ecst.csuchico.edu/~beej/guопрe/net/

*******************************************************************************/

module net.Socket;

private import  time.Time;

private import  sys.Common;

private import  exception;


/*******************************************************************************


*******************************************************************************/

version=Dinrus;
version (Dinrus)
{
        private ткст вТкст (ткст врем, цел i)
        {
                цел j = врем.length;
                do {
                   врем[--j] = cast(сим)(i % 10 + '0');
                   } while (i /= 10);

                return врем [j .. $];
        }
}

version (linux)
         version = СОКЕТЫБСД;

version (darwin)
         version = СОКЕТЫБСД;

version (Posix)
         version = СОКЕТЫБСД;


/*******************************************************************************


*******************************************************************************/

version (Win32)
        {
        //pragma(lib, "ws2_32.lib");
		//pragma(lib, "rulada.lib");

        private typedef цел т_сокет = ~0;

        private const цел МАСКА_ВВПАРАМ =  0x7f;
        private const цел ВВК_ВХО =        cast(цел)0x80000000;
        private const цел ВВФСБВВ =       cast(цел) (ВВК_ВХО | ((цел.sizeof & МАСКА_ВВПАРАМ) << 16) | (102 << 8) | 126);

        private const цел ДЛИНА_ВСАОПИСАНИЯ = 256;
        private const цел ДЛИНА_ВСАСИС_СТАТУСА = 128;
        private const цел WSAEWOULDBLOCK =  10035;
        private const цел WSAEINTR =        10004;


        struct ВИНСОКДАН
        {
                        WORD версия;
                        WORD хВерсия;
                        сим описание[ДЛИНА_ВСАОПИСАНИЯ+1];
                        сим сисСтатус[ДЛИНА_ВСАСИС_СТАТУСА+1];
                        бкрат макЧлоСок;
                        бкрат максДгПпд;
                        сим* инфОПроизв;
        }
        alias ВИНСОКДАН* ВИНСОКДАН*;

        extern  (Windows)
                {
                alias закройсок закрой;
                цел WSAStartup(WORD wVersionRequested, ВИНСОКДАН* lpWSAData);
                цел WSACleanup();
                т_сокет сокет(цел af, цел тип, цел протокол);
                цел ввктлсок(т_сокет s, цел cmd, бцел* argp);
                бцел адр_инет(сим* cp);
                цел свяжи(т_сокет s, адрессок* имя, цел namelen);
                цел подключись(т_сокет s, адрессок* имя, цел namelen);
                цел слушай(т_сокет s, цел backlog);
                т_сокет прими(т_сокет s, адрессок* адр, цел* Addrlen);
                цел закройсок(т_сокет s);
                цел глуши(т_сокет s, цел как);
                цел дайимяпира(т_сокет s, адрессок* имя, цел* namelen);
                цел дайимясок(т_сокет s, адрессок* имя, цел* namelen);
                цел шли(т_сокет s, ук  буф, цел длин, цел флаги);
                цел шли_на(т_сокет s, ук  буф, цел длин, цел флаги, адрессок* в_, цел tolen);
                цел прими(т_сокет s, ук  буф, цел длин, цел флаги);
                цел прими_от(т_сокет s, ук  буф, цел длин, цел флаги, адрессок* из_, цел* fromlen);
                цел выбери(цел nfds, набор_уд* readfds, набор_уд* writefds, набор_уд* errorfds, значврем* таймаут);
                //цел __WSAFDIsSet(т_сокет s, набор_уд* fds);
                цел дайопцсок(т_сокет s, цел уровень, цел optname, ук  optval, цел* optlen);
                цел установиопцсок(т_сокет s, цел уровень, цел optname, ук  optval, цел optlen);
                цел дайимяхоста(ук  namebuffer, цел buflen);
                сим* инетс8а(бцел ina);
                хостзап* дайхостпоимени(сим* имя);
                хостзап* дайхостпоадресу(ук  адр, цел длин, цел тип);
                цел ВСАДайПоследнююОшибку();
                }

        static this()
        {
                ВИНСОКДАН wd;
                if (WSAStartup (0x0101, &wd))
                    throw new СокетИскл("Unable в_ инициализуй сокет library");
        }


        static ~this()
        {
                WSACleanup();
        }

        }

version (СОКЕТЫБСД)
        {
        private import cidrus;

        private typedef цел т_сокет = -1;

        private const цел F_GETFL       = 3;
        private const цел F_SETFL       = 4;
        version (darwin)
                 private const цел O_NONBLOCK = 0x0004;
		else version (solaris)
                 private const цел O_NONBLOCK = 0x80;
           else
                 private const цел O_NONBLOCK = 04000;  // OCTAL! Thx в_ volcore

        extern  (C)
                {
                т_сокет сокет(цел af, цел тип, цел протокол);
                цел fcntl(т_сокет s, цел f, ...);
                бцел адр_инет(сим* cp);
                цел свяжи(т_сокет s, адрессок* имя, цел namelen);
                цел подключись(т_сокет s, адрессок* имя, цел namelen);
                цел слушай(т_сокет s, цел backlog);
                т_сокет прими(т_сокет s, адрессок* адр, цел* Addrlen);
                цел закрой(т_сокет s);
                цел глуши(т_сокет s, цел как);
                цел дайимяпира(т_сокет s, адрессок* имя, цел* namelen);
                цел дайимясок(т_сокет s, адрессок* имя, цел* namelen);
                цел шли(т_сокет s, ук  буф, цел длин, цел флаги);
                цел шли_на(т_сокет s, ук  буф, цел длин, цел флаги, адрессок* в_, цел tolen);
                цел прими(т_сокет s, ук  буф, цел длин, цел флаги);
                цел прими_от(т_сокет s, ук  буф, цел длин, цел флаги, адрессок* из_, цел* fromlen);
                цел выбери(цел nfds, набор_уд* readfds, набор_уд* writefds, набор_уд* errorfds, значврем* таймаут);
                цел дайопцсок(т_сокет s, цел уровень, цел optname, ук  optval, цел* optlen);
                цел установиопцсок(т_сокет s, цел уровень, цел optname, ук  optval, цел optlen);
                цел дайимяхоста(ук  namebuffer, цел buflen);
                сим* инетс8а(бцел ina);
                хостзап* дайхостпоимени(сим* имя);
                хостзап* дайхостпоадресу(ук  адр, цел длин, цел тип);
                }
        }


/*******************************************************************************


*******************************************************************************/

private const т_сокет НЕВЕРНСОК = т_сокет.init;
private const цел СОКОШИБ = -1;



/*******************************************************************************

        Internal structs:

*******************************************************************************/

struct значврем
{
        цел сек; //сек
        цел микросек; //микросекунды
}


//transparent
struct набор_уд
{
}


struct адрессок
{
        бкрат семейство;
        сим[14] данные = 0;
}


struct хостзап
{
        сим* имя;
        сим** алиасы;
        version(Win32)
        {
                крат типадр;
                крат длина;
        }
        else version(СОКЕТЫБСД)
        {
                цел типадр;
                цел длина;
        }
        сим** списадр;


        сим* адр()
        {
                return списадр[0];
        }
}


/*******************************************************************************

        conversions for network байт-order

*******************************************************************************/

version(БигЭндиан)
{
        бкрат х8сбк(бкрат x)
        {
                return x;
        }


        бцел х8сбц(бцел x)
        {
                return x;
        }
}
else version(LittleEndian)
{
        import core.BitManip;


        бкрат х8сбк(бкрат x)
        {
                return cast(бкрат) ((x >> 8) | (x << 8));
        }


        бцел х8сбц(бцел x)
        {
                return bswap(x);
        }
}
else
{
        static assert(0);
}


бкрат с8хбк(бкрат x)
{
        return х8сбк(x);
}


бцел с8хбц(бцел x)
{
        return х8сбц(x);
}


/*******************************************************************************


*******************************************************************************/

private extern (C) цел strlen(сим*);

private static ткст вТкст(сим* s)
{
        return s ? s[0 .. strlen(s)] : cast(ткст)пусто;
}

private static сим* преобразуй2Си (ткст ввод, ткст вывод)
{
        вывод [0 .. ввод.length] = ввод;
        вывод [ввод.length] = 0;
        return вывод.ptr;
}


/*******************************************************************************

        Public interface ...

*******************************************************************************/

public:


/*******************************************************************************


*******************************************************************************/

static цел последнОшиб ()
{
        version (Win32)
                {
                return ВСАДайПоследнююОшибку();
                }
        version (Posix)
                {
                return errno;
                }
}


/***********************************************************************


***********************************************************************/

version (Win32)
{
        /***************************************************************


        ***************************************************************/

        enum ПОпцияСокета: цел
        {
                //consistent
                Отладка =         0x1,

                //possibly Winsock-only values
                Вещание =  0x20,
                ПереиспАдр =  0x4,
                Заминка =     0x80,
                БезЗаминки = ~(Заминка),
                СПДИнлайнинг =  0x100,
                ОтправБуф =     0x1001,
                ПолучБуф =     0x1002,
                Ошибка =      0x1007,

                Прослушивается =    0x2, // ?
                ОставатьсяНаСвязи =     0x8, // ?
                НеМаршрутизировать =     0x10, // ?
                Тип =          0x1008, // ?

                // OptionУровень.ИП settings
                ИПВ6МультикастХопс = 10,
                ИПВ6МультикастЦикл = 11,
                ИПВ6ВГруппу = 12,
                ИПВ6ИзГруппы = 13,

                // OptionУровень.ПУТ settings
                ПУТБезЗадержек = 0x0001,
        }

        /***************************************************************


        ***************************************************************/

        union заминка
        {
                struct {
                       бкрат вкл;          // опция on/off
                       бкрат время;         // заминка время
                       };
                бкрат[2]       Массив;          // combined
        }

        /***************************************************************


        ***************************************************************/

        enum ППротокол
        {
                СОКЕТ =  0xFFFF,
                ИП =      0,
                ПУТ =     6,
                ППД =     17,
        }
}
else version (darwin)
{
        enum ПОпцияСокета: цел
        {
                Отладка        = 0x0001,               /* turn on debugging инфо recording */
                Вещание    = 0x0020,               /* permit Отправкаing of broadcast msgs */
                ПереиспАдр    = 0x0004,               /* allow local адрес reuse */
                Заминка       = 0x0080,               /* заминка on закрой if данные present */
                БезЗаминки   = ~(Заминка),
                СПДИнлайнинг    = 0x0100,               /* покинь Приёмd СПД данные in строка */
                Прослушивается   = 0x0002,               /* сокет есть had слушай() */
                ОставатьсяНаСвязи    = 0x0008,               /* keep connections alive */
                НеМаршрутизировать    = 0x0010,               /* just use interface адресes */
                Тип         = 0x1008,               /* получи сокет тип */

                /*
                 * добавьitional options, not kept in so_options.
                 */
                ОтправБуф       = 0x1001,               /* шли буфер размер */
                ПолучБуф       = 0x1002,               /* принять буфер размер */
                Ошибка        = 0x1007,               /* получи ошибка статус and сотри */

                // OptionУровень.ИП settings
                ИПВ6МультикастХопс = 10,
                ИПВ6МультикастЦикл = 11,
                ИПВ6ВГруппу = 12,
                ИПВ6ИзГруппы = 13,

                // OptionУровень.ПУТ settings
                ПУТБезЗадержек = 0x0001,
        }

        /***************************************************************


        ***************************************************************/

        union заминка
        {
                struct {
                       цел вкл;             // опция on/off
                       цел время;            // заминка время
                       };
                цел[2]          Массив;          // combined
        }

        /***************************************************************

                Question: are these correct for Darwin?

        ***************************************************************/

        enum ППротокол
        {
                СОКЕТ =  0xffff,
                ИП =      0,  // appears в_ be correct
                ПУТ =     6,  // appears в_ be correct
                ППД =     17, // appears в_ be correct
        }
}
else version (freebsd)
{
        enum ПОпцияСокета: цел
        {
                Отладка        = 0x0001,               /* turn on debugging инфо recording */
                Вещание    = 0x0020,               /* permit Отправкаing of broadcast msgs */
                ПереиспАдр    = 0x0004,               /* allow local адрес reuse */
                Заминка       = 0x0080,               /* заминка on закрой if данные present */
                БезЗаминки   = ~(Заминка),
                СПДИнлайнинг    = 0x0100,               /* покинь Приёмd СПД данные in строка */
                Прослушивается   = 0x0002,               /* сокет есть had слушай() */
                ОставатьсяНаСвязи    = 0x0008,               /* keep connections alive */
                НеМаршрутизировать    = 0x0010,               /* just use interface адресes */
                Тип         = 0x1008,               /* получи сокет тип */

                /*
                 * добавьitional options, not kept in so_options.
                 */
                ОтправБуф       = 0x1001,               /* шли буфер размер */
                ПолучБуф       = 0x1002,               /* принять буфер размер */
                Ошибка        = 0x1007,               /* получи ошибка статус and сотри */

                // OptionУровень.ИП settings
                ИПВ6МультикастХопс = 10,
                ИПВ6МультикастЦикл = 11,
                ИПВ6ВГруппу = 12,
                ИПВ6ИзГруппы = 13,

                // OptionУровень.ПУТ settings
                ПУТБезЗадержек = 0x0001,
        }

        /***************************************************************


        ***************************************************************/

        union заминка
        {
                struct {
                       цел вкл;             // опция on/off
                       цел время;            // заминка время
                       };
                цел[2]          Массив;          // combined
        }

        enum ППротокол
        {
                СОКЕТ =  0xffff,
                ИП =      0,  // appears в_ be correct
                ПУТ =     6,  // appears в_ be correct
                ППД =     17, // appears в_ be correct
        }
}
else version (solaris)
{
        enum ПОпцияСокета: цел
        {
                Отладка        = 0x0001,               /* turn on debugging инфо recording */
                Вещание    = 0x0020,               /* permit Отправкаing of broadcast msgs */
                ПереиспАдр    = 0x0004,               /* allow local адрес reuse */
                Заминка       = 0x0080,               /* заминка on закрой if данные present */
                БезЗаминки   = ~(Заминка),
                СПДИнлайнинг    = 0x0100,               /* покинь Приёмd СПД данные in строка */
                Прослушивается   = 0x0002,               /* сокет есть had слушай() */
                ОставатьсяНаСвязи    = 0x0008,               /* keep connections alive */
                НеМаршрутизировать    = 0x0010,               /* just use interface адресes */
                Тип         = 0x1008,               /* получи сокет тип */

                /*
                 * добавьitional options, not kept in so_options.
                 */
                ОтправБуф       = 0x1001,               /* шли буфер размер */
                ПолучБуф       = 0x1002,               /* принять буфер размер */
                Ошибка        = 0x1007,               /* получи ошибка статус and сотри */

                // OptionУровень.ИП settings
                ИПВ6МультикастХопс = 0x11,
                ИПВ6МультикастЦикл = 0x12,
                ИПВ6ВГруппу = 0x13,
                ИПВ6ИзГруппы = 0x14,

                // OptionУровень.ПУТ settings
                ПУТБезЗадержек = 0x01,
        }

        /***************************************************************


        ***************************************************************/

        union заминка
        {
                struct {
                       цел вкл;             // опция on/off
                       цел время;            // заминка время
                       };
                цел[2]          Массив;          // combined
        }

        enum ППротокол
        {
                СОКЕТ =  0xffff,
                ИП =      0,  // appears в_ be correct
                ПУТ =     6,  // appears в_ be correct
                ППД =     17, // appears в_ be correct
        }
}
else version (linux)
{
        /***************************************************************

                these appear в_ be compatible with x86 platforms,
                but not другие!

        ***************************************************************/

        enum ПОпцияСокета: цел
        {
                //consistent
                Отладка        = 1,
                Вещание    = 6,
                ПереиспАдр    = 2,
                Заминка       = 13,
                БезЗаминки   = ~(Заминка),
                СПДИнлайнинг    = 10,
                ОтправБуф       = 7,
                ПолучБуф       = 8,
                Ошибка        = 4,

                Прослушивается   = 30,
                ОставатьсяНаСвязи    = 9,
                НеМаршрутизировать    = 5,
                Тип         = 3,

                // OptionУровень.ИП settings
                ИПВ6МультикастХопс = 33,
                ИПВ6МультикастЦикл = 34,
                ИПВ6ВГруппу = 35,
                ИПВ6ИзГруппы = 36,

                // OptionУровень.ПУТ settings
                ПУТБезЗадержек = 0x0001,
        }

        /***************************************************************


        ***************************************************************/

        union заминка
        {
                struct {
                       цел вкл;             // опция on/off
                       цел время;            // заминка время
                       };
                цел[2]          Массив;          // combined
        }

        /***************************************************************


        ***************************************************************/

        enum ППротокол
        {
                СОКЕТ =  1,  // correct for linux on x86
                ИП =      0,  // appears в_ be correct
                ПУТ =     6,  // appears в_ be correct
                ППД =     17, // appears в_ be correct
        }

} // конец versioning

/***********************************************************************


***********************************************************************/

enum ПЭкстрЗакрытиеСокета: цел
{
        принять =  0,
        Отправка =     1,
        Всё =     2,
}

/***********************************************************************


***********************************************************************/

enum ПФлагиСокета: цел
{
        Неук =           0,
        СПД =            0x1, //out of band
        Просмотр =           0x02, //only for receiving
        НеМаршрутизировать =      0x04, //only for Отправкаing
}

/***********************************************************************

         Communication semantics

***********************************************************************/

enum ПТипСок: цел
{
        Поток =     1,       /// sequenced, reliable, two-way communication-based байт Потокs
        ДГрамма =      2,        /// connectionless, unreliable datagrams with a fixed maximum length; данные may be lost or arrive out of order
        Необр =        3,          /// необр протокол access
        НДС =        4,          /// reliably-delivered сообщение datagrams
        ППП =  5,    /// sequenced, reliable, two-way connection-based datagrams with a fixed maximum length
}


/***********************************************************************

        Protocol

***********************************************************************/

enum ППротокол: цел
{
        ИП =    0,     /// internet протокол version 4
        ИПУС =  1,   /// internet control сообщение протокол
        ИПГУ =  2,   /// internet группа management протокол
        ВВП =   3,    /// gateway в_ gateway протокол
        ПУТ =   6,    /// transmission control протокол
        УПП =   12,    /// PARC universal packet протокол
        ППД =   17,    /// пользователь datagram протокол
        КСЕР =   22,    /// Xerox NS протокол
}


/***********************************************************************


***********************************************************************/

version(Win32)
{
        enum ПСемействоАдресов: цел
        {
                НЕУК =     0,
                ЮНИКС =       1,
                ИНЕТ =       2,
                АЙПИЭКС =        6,
                ЭПЛТОК =  16,
                //INET6 =      ? // Need Windows XP ?
        }
}
else version(СОКЕТЫБСД)
{
        version (darwin)
        {
                enum ПСемействоАдресов: цел
                {
                        НЕУК =     0,
                        ЮНИКС =       1,
                        ИНЕТ =       2,
                        АЙПИЭКС =        23,
                        ЭПЛТОК =  16,
                        //INET6 =      10,
                }
        }
        else version (freebsd)
        {
                enum ПСемействоАдресов: цел
                {
                        НЕУК =     0,
                        ЮНИКС =       1,
                        ИНЕТ =       2,
                        АЙПИЭКС =        23,
                        ЭПЛТОК =  16,
                        //INET6 =      28,
                }
        }    
        else version (linux)
        {
                enum ПСемействоАдресов: цел
                {
                        НЕУК =     0,
                        ЮНИКС =       1,
                        ИНЕТ =       2,
                        АЙПИЭКС =        4,
                        ЭПЛТОК =  5,
                        //INET6 =      10,
                }
        } // конец version
		else version (solaris)
		{
            enum ПСемействоАдресов: цел
            {
                    НЕУК =     0,
                    ЮНИКС =       1,
                    ИНЕТ =       2,
                    АЙПИЭКС =        23,
                    ЭПЛТОК =  16,
                    INET6 =      26,
            }
		}
}



/*******************************************************************************

*******************************************************************************/

class Сокет
{
        т_сокет        сок;
        ПТипСок      тип;
        ПСемействоАдресов   семейство;
        ППротокол    протокол;

        version(Win32)
                private бул _blocking = да;

        // For use with прими().
        package this()
        {
        }


        /**
         * Describe a сокет flavor. If a single протокол тип есть_ли в_ support
         * this сокет тип within the адрес семейство, the ППротокол may be
         * omitted.
         */
        this(ПСемействоАдресов семейство, ПТипСок тип, ППротокол протокол, бул создай=да)
        {
                this.тип = тип;
                this.семейство = семейство;
                this.протокол = протокол;
                if (создай)
                    инициализуй ();
        }


        /**
         * Create or присвой a сокет
         */
        private проц инициализуй (т_сокет сок = сок.init)
        {
                if (this.сок)
                    this.открепи;

                if (сок is сок.init)
                   {
                   сок = cast(т_сокет) сокет(семейство, тип, протокол);
                   if (сок is сок.init)
                       исключение ("Unable в_ создай сокет: ");
                   }

                this.сок = сок;
        }

        /***********************************************************************

                Return the underlying OS укз of this Провод

        ***********************************************************************/

        т_сокет ptr ()
        {
                return сок;
        }

        /***********************************************************************

                Create a new исконный сокет экземпляр for this Сокет

        ***********************************************************************/

        проц переоткрой (т_сокет сок = сок.init)
        {
                инициализуй (сок);
        }

        /***********************************************************************

                Is this сокет still alive? A закрыт сокет is consопрered в_
                be dead, but a глуши сокет is still alive.

        ***********************************************************************/

        бул жив_ли()
        {
                цел тип, разм_типа = тип.sizeof;
                return дайопцсок (сок, ППротокол.СОКЕТ,
                                   ПОпцияСокета.Тип, cast(сим*) &тип,
                                   &разм_типа) != СОКОШИБ;
        }


        /***********************************************************************


        ***********************************************************************/

        override ткст вТкст()
        {
                return "Сокет";
        }


        /***********************************************************************

                getter

        ***********************************************************************/

        бул blocking()
        {
                version(Win32)
                {
                        return _blocking;
                }
                else version(СОКЕТЫБСД)
                {
                        return !(fcntl(сок, F_GETFL, 0) & O_NONBLOCK);
                }
        }


        /***********************************************************************

                setter

        ***********************************************************************/

        проц blocking(бул бда)
        {
                version(Win32)
                {
                        бцел num = !бда;
                        if(СОКОШИБ == ввктлсок(сок, ВВФСБВВ, &num))
                                goto err;
                        _blocking = бда;
                }
                else version(СОКЕТЫБСД)
                {
                        цел x = fcntl(сок, F_GETFL, 0);
                        if(бда)
                                x &= ~O_NONBLOCK;
                        else
                                x |= O_NONBLOCK;
                        if(СОКОШИБ == fcntl(сок, F_SETFL, x))
                                goto err;
                }
                return; //success

                err:
                исключение("Unable в_ установи сокет blocking: ");
        }


        /***********************************************************************


        ***********************************************************************/

        ПСемействоАдресов ПСемействоАдресов()
        {
                return семейство;
        }


        /***********************************************************************


        ***********************************************************************/

        Сокет свяжи(адрес адр)
        {
                if(СОКОШИБ == .свяжи (сок, адр.имя(), адр.длинаИмени()))
                   исключение ("Unable в_ свяжи сокет: ");
                return this;
        }


        /***********************************************************************


        ***********************************************************************/

        Сокет подключись(адрес в_)
        {
                if(СОКОШИБ == .подключись (сок, в_.имя(), в_.длинаИмени()))
                {
                        if(!blocking)
                        {
                                version(Win32)
                                {
                                        if(WSAEWOULDBLOCK == ВСАДайПоследнююОшибку())
                                                return this;
                                }
                                else version (Posix)
                                {
                                        if(EINPROGRESS == errno)
                                                return this;
                                }
                                else
                                {
                                        static assert(0);
                                }
                        }
                        исключение ("Unable в_ подключись сокет: ");
                }
                return this;
        }


        /***********************************************************************

                need в_ свяжи() first

        ***********************************************************************/

        Сокет слушай(цел backlog)
        {
                if(СОКОШИБ == .слушай (сок, backlog))
                   исключение ("Unable в_ слушай on сокет: ");
                return this;
        }

        /**
         * Акцепт an incoming connection. If the сокет is blocking, прими
         * waits for a connection request. Throws СокетПриёмИскл if unable
         * в_ прими. See accepting for use with производный classes.
         */
        Сокет прими ()
        {
                return прими (new Сокет);
        }

        Сокет прими (Сокет мишень)
        {
                auto newsock = cast(т_сокет).прими(сок, пусто, пусто); // DMD 0.101 ошибка: найдено '(' when expecting ';' following 'statement
                if (т_сокет.init == newsock)
                   throw new СокетПриёмИскл("Unable в_ прими сокет connection: " ~ СисОш.найди(последнОшиб));

                мишень.инициализуй (newsock);
                version(Win32)
                        мишень._blocking = _blocking;  //inherits blocking режим

                мишень.протокол = протокол;            //same протокол
                мишень.семейство = семейство;                //same семейство
                мишень.тип = тип;                    //same тип

                return мишень;                         //return configured мишень
        }

        /***********************************************************************

                The глуши function shuts down the connection of the сокет.
                Depending on the аргумент значение, it will:

                    -   stop receiving данные for this сокет. If further данные
                        arrives, it is rejected.

                    -   stop trying в_ transmit данные из_ this сокет. Also
                        discards any данные waiting в_ be sent. Стоп looking for
                        acknowledgement of данные already sent; don't retransmit
                        if any данные is lost.

        ***********************************************************************/

        Сокет глуши(ПЭкстрЗакрытиеСокета как)
        {
                .глуши (сок, как);
                return this;
        }


        /***********************************************************************

                Dinrus: добавьed

        ***********************************************************************/

        Сокет установиПериодЗаминки (цел период)
        {
                заминка l;

                l.вкл = 1;                          //опция on/off
                l.время = cast(бкрат) период;       //заминка время

                return установиОпцию (ППротокол.СОКЕТ, ПОпцияСокета.Заминка, l.Массив);
        }


        /***********************************************************************


                Dinrus: добавьed

        ***********************************************************************/

        Сокет установиПовторнИспАдреса (бул включен)
        {
                цел[1] x = включен;
                return установиОпцию (ППротокол.СОКЕТ, ПОпцияСокета.ПереиспАдр, x);
        }


        /***********************************************************************


                Dinrus: добавьed

        ***********************************************************************/

        Сокет установиБезЗаминки (бул включен)
        {
                цел[1] x = включен;
                return установиОпцию (ППротокол.ПУТ, ПОпцияСокета.ПУТБезЗадержек, x);
        }


        /***********************************************************************

                Helper function в_ укз the добавьing and dropping of группа
                membershИП.

                Dinrus: добавьed

        ***********************************************************************/

        проц включиВГруппу (АдресИПв4 адрес, бул onOff)
        {
                assert (адрес, "Сокет.включиВГруппу :: не_годится пусто адрес");

                struct ИП_mreq
                {
                бцел  imr_multiAddr;  /* ИП multicast адрес of группа */
                бцел  imr_interface;  /* local ИП адрес of interface */
                };

                ИП_mreq mrq;

                auto опция = (onOff) ? ПОпцияСокета.ИПВ6ВГруппу : ПОпцияСокета.ИПВ6ИзГруппы;
                mrq.imr_interface = 0;
                mrq.imr_multiAddr = адрес.син.адрИС;

                if (.установиопцсок(сок, ППротокол.ИП, опция, &mrq, mrq.sizeof) == СОКОШИБ)
                    исключение ("Unable в_ perform multicast объедини: ");
        }


        /***********************************************************************

                calling глуши() before this is recommended for connection-
                oriented СОКЕТs

        ***********************************************************************/

        проц открепи ()
        {
                if (сок != сок.init)
                   {
                   version (TraceLinux)
                            printf ("closing сокет укз ...\n");

                   version(Win32)
                           .закройсок (сок);
                   else
                   version(СОКЕТЫБСД)
                           .закрой (сок);

                   version (TraceLinux)
                            printf ("сокет укз закрыт\n");

                   сок = сок.init;
                   }
        }

        /***********************************************************************


        ***********************************************************************/

        адрес новОбъектСемейства ()
        {
                адрес результат;
                switch(семейство)
                {
                        case ПСемействоАдресов.ИНЕТ:
                                результат = new АдресИПв4;
                                break;

                        default:
                                результат = new НеизвестныйАдрес;
                }
                return результат;
        }


        /***********************************************************************

                Dinrus: добавьed this в_ return the имя_хоста

        ***********************************************************************/

        static ткст имяХоста ()
        {
                сим[64] имя;

                if(СОКОШИБ == .дайимяхоста (имя.ptr, имя.length))
                   исключение ("Unable в_ obtain хост имя: ");
                return имя [0 .. strlen(имя.ptr)].dup;
        }


        /***********************************************************************

                Dinrus: добавьed this в_ return the default хост адрес (ИПv4)

        ***********************************************************************/

        static бцел адресХоста ()
        {
                НетХост ih = new НетХост;

                ткст имя_хоста = имяХоста();
                ih.дайХостПоИмени (имя_хоста);
                assert (ih.АдрСписок.length);
                return ih.АдрСписок[0];
        }


        /***********************************************************************


        ***********************************************************************/

        адрес удалённыйАдрес ()
        {
                адрес адр = новОбъектСемейства ();
                цел длинаИмени = адр.длинаИмени ();
                if(СОКОШИБ == .дайимяпира (сок, адр.имя(), &длинаИмени))
                   исключение ("Unable в_ obtain remote сокет адрес: ");
                assert (адр.ПСемействоАдресов() == семейство);
                return адр;
        }


        /***********************************************************************


        ***********************************************************************/

        адрес локальныйАдрес ()
        {
                адрес адр = новОбъектСемейства ();
                цел длинаИмени = адр.длинаИмени();
                if(СОКОШИБ == .дайимясок (сок, адр.имя(), &длинаИмени))
                   исключение ("Unable в_ obtain local сокет адрес: ");
                assert (адр.ПСемействоАдресов() == семейство);
                return адр;
        }

        /// Отправка or принять ошибка код.
        const цел ERROR = СОКОШИБ;


        /**
         * Отправка данные on the connection. Returns the число of байты actually
         * sent, or ERROR on failure. If the сокет is blocking and there is no
         * буфер пространство left, шли waits.
         */
        //returns число of байты actually sent, or -1 on ошибка
        цел шли(проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                return .шли(сок, буф.ptr, буф.length, cast(цел)флаги);
        }

        /**
         * Отправка данные в_ a specific destination адрес. If the destination адрес is not specified, a connection must have been made and that адрес is used. If the сокет is blocking and there is no буфер пространство left, отправь_на waits.
         */
        цел отправь_на(проц[] буф, ПФлагиСокета флаги, адрес в_)
        {
                return .шли_на(сок, буф.ptr, буф.length, cast(цел)флаги, в_.имя(), в_.длинаИмени());
        }

        /// ditto
        цел отправь_на(проц[] буф, адрес в_)
        {
                return отправь_на(буф, ПФлагиСокета.Неук, в_);
        }


        //assumes you подключись()ed
        /// ditto
        цел отправь_на(проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                return .шли_на(сок, буф.ptr, буф.length, cast(цел)флаги, пусто, 0);
        }


        /**
         * принять данные on the connection. Returns the число of байты actually
         * Приёмd, 0 if the remote sопрe есть закрыт the connection, or ERROR on
         * failure. If the сокет is blocking, принять waits until there is данные
         * в_ be Приёмd.
         */
        //returns число of байты actually Приёмd, 0 on connection closure, or -1 on ошибка
        цел принять(проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять :: мишень буфер есть 0 length");

                return .прими(сок, буф.ptr, буф.length, cast(цел)флаги);
        }

        /**
         * принять данные and получи the remote endpoint адрес. Returns the число of байты actually Приёмd, 0 if the remote sопрe есть закрыт the connection, or ERROR on failure. If the сокет is blocking, принять_от waits until there is данные в_ be Приёмd.
         */
        цел принять_от(проц[] буф, ПФлагиСокета флаги, адрес из_)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять_от :: мишень буфер есть 0 length");

                assert(из_.ПСемействоАдресов() == семейство);
                цел длинаИмени = из_.длинаИмени();
                return .прими_от(сок, буф.ptr, буф.length, cast(цел)флаги, из_.имя(), &длинаИмени);
        }


        /// ditto
        цел принять_от(проц[] буф, адрес из_)
        {
                return принять_от(буф, ПФлагиСокета.Неук, из_);
        }


        //assumes you подключись()ed
        /// ditto
        цел принять_от(проц[] буф, ПФлагиСокета флаги = ПФлагиСокета.Неук)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять_от :: мишень буфер есть 0 length");

                return .прими_от(сок, буф.ptr, буф.length, cast(цел)флаги, пусто, пусто);
        }


        /***********************************************************************

                returns the length, in байты, of the actual результат - very
                different из_ дайопцсок()

        ***********************************************************************/

        цел дайОпцию (ППротокол уровень, ПОпцияСокета опция, проц[] результат)
        {
                цел длин = результат.length;
                if(СОКОШИБ == .дайопцсок (сок, cast(цел)уровень, cast(цел)опция, результат.ptr, &длин))
                   исключение ("Unable в_ получи сокет опция: ");
                return длин;
        }


        /***********************************************************************


        ***********************************************************************/

        Сокет установиОпцию (ППротокол уровень, ПОпцияСокета опция, проц[] значение)
        {
                if(СОКОШИБ == .установиопцсок (сок, cast(цел)уровень, cast(цел)опция, значение.ptr, значение.length))
                   исключение ("Unable в_ установи сокет опция: ");
                return this;
        }


        /***********************************************************************

                Dinrus: добавьed this common function

        ***********************************************************************/

        protected static проц исключение (ткст сооб)
        {
                throw new СокетИскл (сооб ~ СисОш.найди(последнОшиб));
        }


        /***********************************************************************

                Dinrus: добавьed this common function

        ***********************************************************************/

        protected static проц плохойАрг (ткст сооб)
        {
                throw new ИсклНелегальногоАргумента (сооб);
        }


        /***********************************************************************

                НаборСокетов's are updated в_ include only those СОКЕТs which an
                событие occured.

                Returns the число of события, 0 on таймаут, or -1 on ошибка

                for a подключись()ing сокет, writeability means подключен
                for a слушай()ing сокет, readability means listening

                Winsock: possibly internally limited в_ 64 СОКЕТs per установи

        ***********************************************************************/

        static цел выбери (НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError, значврем* tv)
        in
        {
                //сделай sure Неук of the НаборСокетов's are the same объект
                if(checkRead)
                {
                        assert(checkRead !is checkWrite);
                        assert(checkRead !is checkError);
                }
                if(checkWrite)
                {
                        assert(checkWrite !is checkError);
                }
        }
        body
        {
                набор_уд* fr, fw, fe;

                version(Win32)
                {
                        //Windows есть a problem with пустой набор_уд's that aren't пусто
                        fr = (checkRead && checkRead.счёт()) ? checkRead.вНабор_УД() : пусто;
                        fw = (checkWrite && checkWrite.счёт()) ? checkWrite.вНабор_УД() : пусто;
                        fe = (checkError && checkError.счёт()) ? checkError.вНабор_УД() : пусто;
                }
                else
                {
                        fr = checkRead ? checkRead.вНабор_УД() : пусто;
                        fw = checkWrite ? checkWrite.вНабор_УД() : пусто;
                        fe = checkError ? checkError.вНабор_УД() : пусто;
                }

                цел результат;

                // Dinrus: if выбери() was interrupted, we сейчас try again
                version(Win32)
                {
                        while ((результат = .выбери (т_сокет.max - 1, fr, fw, fe, tv)) == -1)
                        {
                                if(ВСАДайПоследнююОшибку() != WSAEINTR)
                                   break;
                        }
                }
                else version (Posix)
                {
                        т_сокет максуд = 0;

                        if (checkRead)
                                максуд = checkRead.максуд;

                        if (checkWrite && checkWrite.максуд > максуд)
                                максуд = checkWrite.максуд;

                        if (checkError && checkError.максуд > максуд)
                                максуд = checkError.максуд;

                        while ((результат = .выбери (максуд + 1, fr, fw, fe, tv)) == -1)
                        {
                                if(дайНомОш() != EINTR)
                                   break;
                        }
                }
                else
                {
                        static assert(0);
                }
                // Dinrus: don't throw an исключение here ... жди until we получи
                // a bit further back along the control путь
                //if(СОКОШИБ == результат)
                //   throw new СокетИскл("Сокет выбери ошибка.");

                return результат;
        }

        /***********************************************************************

                выбери with specified таймаут

        ***********************************************************************/

        static цел выбери (НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError, ИнтервалВремени время)
        {
                auto tv = вЗначВрем (время);
                return выбери (checkRead, checkWrite, checkError, &tv);
        }

        /***********************************************************************

                выбери with maximum таймаут

        ***********************************************************************/

        static цел выбери (НаборСокетов checkRead, НаборСокетов checkWrite, НаборСокетов checkError)
        {
                return выбери (checkRead, checkWrite, checkError, пусто);
        }

        /***********************************************************************

                Handy utility for converting ИнтервалВремени преобр_в значврем

        ***********************************************************************/

        static значврем вЗначВрем (ИнтервалВремени время)
        {
                значврем tv;
                tv.сек = cast(бцел) время.сек;
                tv.микросек = cast(бцел) время.micros % 1_000_000;
                return tv;
        }
}



/*******************************************************************************


*******************************************************************************/

abstract class адрес
{
        protected адрессок* имя();
        protected цел длинаИмени();
        ПСемействоАдресов ПСемействоАдресов();
        ткст вТкст();

        /***********************************************************************

                Dinrus: добавьed this common function

        ***********************************************************************/

        static проц исключение (ткст сооб)
        {
                throw new АдрИскл (сооб);
        }

}


/*******************************************************************************


*******************************************************************************/

class НеизвестныйАдрес: адрес
{
        protected:
        адрессок sa;


        /***********************************************************************


        ***********************************************************************/

        адрессок* имя()
        {
                return &sa;
        }


        /***********************************************************************


        ***********************************************************************/

        цел длинаИмени()
        {
                return sa.sizeof;
        }


        public:
        /***********************************************************************


        ***********************************************************************/

        ПСемействоАдресов ПСемействоАдресов()
        {
                return cast(ПСемействоАдресов) sa.семейство;
        }


        /***********************************************************************


        ***********************************************************************/

        ткст вТкст()
        {
                return "Unknown";
        }
}


/*******************************************************************************


*******************************************************************************/

class НетХост
{
        ткст имя;
        ткст[] aliases;
        бцел[] АдрСписок;


        /***********************************************************************


        ***********************************************************************/

        protected проц проверьХостзап(хостзап* he)
        {
                if(he.типадр != cast(цел)ПСемействоАдресов.ИНЕТ || he.длина != 4)
                        throw new ХостИскл("адрес семейство не_совпадают.");
        }


        /***********************************************************************


        ***********************************************************************/

        проц наполни(хостзап* he)
        {
                цел i;
                сим* p;

                имя = .вТкст(he.имя);

                for(i = 0;; i++)
                {
                        p = he.алиасы[i];
                        if(!p)
                                break;
                }

                if(i)
                {
                        aliases = new ткст[i];
                        for(i = 0; i != aliases.length; i++)
                        {
                                aliases[i] = .вТкст(he.алиасы[i]);
                        }
                }
                else
                {
                        aliases = пусто;
                }

                for(i = 0;; i++)
                {
                        p = he.списадр[i];
                        if(!p)
                                break;
                }

                if(i)
                {
                        АдрСписок = new бцел[i];
                        for(i = 0; i != АдрСписок.length; i++)
                        {
                                АдрСписок[i] = с8хбц(*(cast(бцел*)he.списадр[i]));
                        }
                }
                else
                {
                        АдрСписок = пусто;
                }
        }


        /***********************************************************************


        ***********************************************************************/

        бул дайХостПоИмени(ткст имя)
        {
                сим[1024] врем;

                synchronized (Сокет.classinfo)
                             {
                             хостзап* he = дайхостпоимени(преобразуй2Си (имя, врем));
                             if(!he)
                                return нет;
                             проверьХостзап(he);
                             наполни(he);
                             }
                return да;
        }


        /***********************************************************************


        ***********************************************************************/

        бул дайХостПоАдресу(бцел адр)
        {
                бцел x = х8сбц(адр);
                synchronized (Сокет.classinfo)
                             {
                             хостзап* he = дайхостпоадресу(&x, 4, cast(цел)ПСемействоАдресов.ИНЕТ);
                             if(!he)
                                 return нет;
                             проверьХостзап(he);
                             наполни(he);
                             }
                return да;
        }


        /***********************************************************************


        ***********************************************************************/

        //shortcut
        бул дайХостПоАдресу(ткст адр)
        {
                сим[64] врем;

                synchronized (Сокет.classinfo)
                             {
                             бцел x = адр_инет(преобразуй2Си (адр, врем));
                             хостзап* he = дайхостпоадресу(&x, 4, cast(цел)ПСемействоАдресов.ИНЕТ);
                             if(!he)
                                 return нет;
                             проверьХостзап(he);
                             наполни(he);
                             }
                return да;
        }
}


debug (UnitText)
{
extern (C) цел printf(сим*, ...);
unittest
{
        try
        {
        НетХост ih = new НетХост;
        ih.дайХостПоИмени(Сокет.имяХоста());
        assert(ih.АдрСписок.length > 0);
        АдресИПв4 ia = new АдресИПв4(ih.АдрСписок[0], АдресИПв4.ПОРТ_ЛЮБОЙ);
        printf("ИП адрес = %.*s\nname = %.*s\n", ia.вТкстАдреса(), ih.имя);
        foreach(цел i, ткст s; ih.aliases)
        {
                printf("aliases[%d] = %.*s\n", i, s);
        }

        printf("---\n");

        assert(ih.дайХостПоАдресу(ih.АдрСписок[0]));
        printf("имя = %.*s\n", ih.имя);
        foreach(цел i, ткст s; ih.aliases)
        {
                printf("aliases[%d] = %.*s\n", i, s);
                }
        }
        catch( Объект o )
        {
            assert( нет );
        }
}
}


/*******************************************************************************


*******************************************************************************/

class АдресИПв4 : адрес
{
        protected:
        сим[8] _port;

        /***********************************************************************


        ***********************************************************************/

        struct сокадр_ин
        {
                бкрат семействоИС = ПСемействоАдресов.ИНЕТ;
                бкрат портИС;
                бцел адрИС; //in_Addr
                сим[8] зероИС = 0;
        }

        сокадр_ин син;


        /***********************************************************************


        ***********************************************************************/

        адрессок* имя()
        {
                return cast(адрессок*)&син;
        }


        /***********************************************************************


        ***********************************************************************/

        цел длинаИмени()
        {
                return син.sizeof;
        }


        public:

        /***********************************************************************


        ***********************************************************************/

        this()
        {
        }


        const бцел АДР_ЛЮБОЙ = 0;
        const бцел АДР_НЕУК = cast(бцел)-1;
        const бкрат ПОРТ_ЛЮБОЙ = 0;


        /***********************************************************************


        ***********************************************************************/

        ПСемействоАдресов ПСемействоАдресов()
        {
                return ПСемействоАдресов.ИНЕТ;
        }


        /***********************************************************************


        ***********************************************************************/

        бкрат порт()
        {
                return с8хбк(син.портИС);
        }


        /***********************************************************************


        ***********************************************************************/

        бцел адр()
        {
                return с8хбц(син.адрИС);
        }


        /***********************************************************************

                -порт- can be ПОРТ_ЛЮБОЙ
                -адр- is an ИП адрес or хост имя

        ***********************************************************************/

        this(ткст адр, цел порт = ПОРТ_ЛЮБОЙ)
        {
                бцел uiAddr = разбор(адр);
                if(АДР_НЕУК == uiAddr)
                {
                        НетХост ih = new НетХост;
                        if(!ih.дайХостПоИмени(адр))
                          {
                          сим[16] врем =void;
                          исключение ("Unable в_ разреши "~адр~":"~.вТкст(врем, порт));
                          }
                        uiAddr = ih.АдрСписок[0];
                }
                син.адрИС = х8сбц(uiAddr);
                син.портИС = х8сбк(cast(бкрат) порт);
        }


        /***********************************************************************


        ***********************************************************************/

        this(бцел адр, бкрат порт)
        {
                син.адрИС = х8сбц(адр);
                син.портИС = х8сбк(порт);
        }


        /***********************************************************************


        ***********************************************************************/

        this(бкрат порт)
        {
                син.адрИС = 0; //any, "0.0.0.0"
                син.портИС = х8сбк(порт);
        }

        /***********************************************************************


        ***********************************************************************/

        synchronized ткст вТкстАдреса()
        {
                return .вТкст(инетс8а(син.адрИС)).dup;
        }


        /***********************************************************************


        ***********************************************************************/

        ткст вТкстПорта()
        {
                return .вТкст (_port, порт());
        }


        /***********************************************************************


        ***********************************************************************/

        ткст вТкст()
        {
                return вТкстАдреса() ~ ":" ~ вТкстПорта();
        }


        /***********************************************************************

                -адр- is an ИП адрес in the форматируй "a.b.c.d"
                returns АДР_НЕУК on failure

        ***********************************************************************/

        static бцел разбор(ткст адр)
        {
                сим[64] врем;

                synchronized (АдресИПв4.classinfo)
                              return с8хбц(адр_инет(преобразуй2Си (адр, врем)));
        }
}

debug(Unittest)
{
unittest
{
        АдресИПв4 ia = new АдресИПв4("63.105.9.61", 80);
        assert(ia.вТкст() == "63.105.9.61:80");
}
}

/*******************************************************************************


*******************************************************************************/

//a установи of СОКЕТs for Сокет.выбери()
class НаборСокетов
{
        private бцел  члоБайт; //Win32: excludes бцел.размер "счёт"
        private байт* буф;

        version(Win32)
        {
                бцел счёт()
                {
                        return *(cast(бцел*)буф);
                }


                проц счёт(цел setter)
                {
                        *(cast(бцел*)буф) = setter;
                }


                т_сокет* first()
                {
                        return cast(т_сокет*)(буф + бцел.sizeof);
                }
        }
        else version (Posix)
        {
                import core.BitManip;


                бцел nfdbits;
                т_сокет _maxfd = 0;

                бцел fdelt(т_сокет s)
                {
                        return cast(бцел)s / nfdbits;
                }


                бцел fdmask(т_сокет s)
                {
                        return 1 << cast(бцел)s % nfdbits;
                }


                бцел* first()
                {
                        return cast(бцел*)буф;
                }

                public т_сокет максуд()
                {
                        return _maxfd;
                }
        }


        public:
        /***********************************************************************


        ***********************************************************************/

        this (бцел max)
        {
                version(Win32)
                {
                        члоБайт = max * т_сокет.sizeof;
                        буф = (new байт[члоБайт + бцел.sizeof]).ptr;
                        счёт = 0;
                }
                else version (Posix)
                {
                        if (max <= 32)
                            члоБайт = 32 * бцел.sizeof;
                        else
                           члоБайт = max * бцел.sizeof;

                        буф = (new байт[члоБайт]).ptr;
                        nfdbits = члоБайт * 8;
                        //сотри(); //new initializes в_ 0
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        this (НаборСокетов o) 
        {
                члоБайт = o.члоБайт;
                auto размер = члоБайт;
                version (Win32) 
                         размер += бцел.sizeof;

                version (Posix) 
                        {
                        nfdbits = o.nfdbits;
                        _maxfd = o._maxfd;
                        }
                
                auto b = new байт[размер];
                b[] = o.буф[0..размер];
                буф = b.ptr;
        }

        /***********************************************************************


        ***********************************************************************/

        this()
        {
                version(Win32)
                {
                        this(64);
                }
                else version (Posix)
                {
                        this(32);
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/
        
        НаборСокетов dup() 
        {
                return new НаборСокетов (this);
        }
        
        /***********************************************************************


        ***********************************************************************/

        проц сбрось()
        {
                version(Win32)
                {
                        счёт = 0;
                }
                else version (Posix)
                {
                        буф[0 .. члоБайт] = 0;
                        _maxfd = 0;
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        проц добавь(т_сокет s)
        in
        {
                version(Win32)
                {
                        assert(счёт < max); //добавьed too many СОКЕТs; specify a higher max in the constructor
                }
        }
        body
        {
                version(Win32)
                {
                        бцел c = счёт;
                        first[c] = s;
                        счёт = c + 1;
                }
                else version (Posix)
                {
                        if (s > _maxfd)
                                _maxfd = s;

                        bts(cast(бцел*)&first[fdelt(s)], cast(бцел)s % nfdbits);
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        проц добавь(Сокет s)
        {
                добавь(s.сок);
        }

        /***********************************************************************


        ***********************************************************************/

        проц удали(т_сокет s)
        {
                version(Win32)
                {
                        бцел c = счёт;
                        т_сокет* старт = first;
                        т_сокет* stop = старт + c;

                        for(; старт != stop; старт++)
                        {
                                if(*старт == s)
                                        goto найдено;
                        }
                        return; //не найден

                        найдено:
                        for(++старт; старт != stop; старт++)
                        {
                                *(старт - 1) = *старт;
                        }

                        счёт = c - 1;
                }
                else version (Posix)
                {
                        btr(cast(бцел*)&first[fdelt(s)], cast(бцел)s % nfdbits);

                        // If we're removing the biggest файл descrИПtor we've
                        // entered so far we need в_ recalculate this значение
                        // for the сокет установи.
                        if (s == _maxfd)
                        {
                                while (--_maxfd >= 0)
                                {
                                        if (набор_ли(_maxfd))
                                        {
                                                break;
                                        }
                                }
                        }
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        проц удали(Сокет s)
        {
                удали(s.сок);
        }

        /***********************************************************************


        ***********************************************************************/

        цел набор_ли(т_сокет s)
        {
                version(Win32)
                {
                        т_сокет* старт = first;
                        т_сокет* stop = старт + счёт;

                        for(; старт != stop; старт++)
                        {
                                if(*старт == s)
                                        return да;
                        }
                        return нет;
                }
                else version (Posix)
                {
                        //return bt(cast(бцел*)&first[fdelt(s)], cast(бцел)s % nfdbits);
                        цел индекс = cast(бцел)s % nfdbits;
                        return (cast(бцел*)&first[fdelt(s)])[индекс / (бцел.sizeof*8)] & (1 << (индекс & ((бцел.sizeof*8) - 1)));
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        цел набор_ли(Сокет s)
        {
                return набор_ли(s.сок);
        }

        /***********************************************************************

                max СОКЕТs that can be добавьed, like FD_SETSIZE

        ***********************************************************************/

        бцел max()
        {
                return члоБайт / т_сокет.sizeof;
        }

        /***********************************************************************


        ***********************************************************************/

        набор_уд* вНабор_УД()
        {
                return cast(набор_уд*)буф;
        }
}


