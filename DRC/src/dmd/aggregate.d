/**
 * Compiler implementation of the
 * $(LINK2 http://www.dlang.org, D programming language).
 *
 * Copyright:   Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved
 * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)
 * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/aggregate.d, _aggregate.d)
 * Documentation:  https://dlang.org/phobos/dmd_aggregate.html
 * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/aggregate.d
 */

module dmd.aggregate;

import cidrus;
import core.checkedint;

import dmd.aliasthis;
import dmd.arraytypes;
import dmd.gluelayer : Symbol;
import dmd.declaration;
import dmd.dscope;
import dmd.dstruct;
import dmd.дсимвол;
import dmd.dsymbolsem;
import dmd.dtemplate;
import dmd.errors;
import drc.ast.Expression;
import dmd.func;
import dmd.globals;
import drc.lexer.Id;
import drc.lexer.Identifier;
import dmd.mtype;
import drc.lexer.Tokens;
import dmd.typesem : defaultInit;
import drc.ast.Visitor;

enum Sizeok : цел
{
    none,           // size of aggregate is not yet able to compute
    fwd,            // size of aggregate is ready to compute
    inProcess,      // in the midst of computing the size
    done,           // size of aggregate is set correctly
}

enum Baseok : цел
{
    none,             // base classes not computed yet
    start,            // in process of resolving base classes
    done,             // all base classes are resolved
    semanticdone,     // all base classes semantic done
}

/**
 * Перечень ClassKind используется в узлах AggregateDeclaration AST для
 * определения типа компоновки структуры/класс/интерфейса или того,
 * является ли этот класс анонимным. Если класс анонимен, то также полагается,
 * что это класс D.
 */
enum ClassKind : цел
{
    /// the aggregate is a d(efault) class
    d,
    /// the aggregate is a C++ struct/class/interface
    cpp,
    /// the aggregate is an Objective-C class/interface
    objc,
}

/***********************************************************
 */
 abstract class AggregateDeclaration : ScopeDsymbol
{
    Тип тип;
    КлассХранения класс_хранения;
    Prot защита;
    бцел structsize;        // size of struct
    бцел alignsize;         // size of struct for alignment purposes
    VarDeclarations fields; // VarDeclaration fields
    Sizeok sizeok = Sizeok.none;  // set when structsize содержит valid данные
    ДСимвол deferred;       // any deferred semantic2() or semantic3() symbol

    /// specifies whether this is a D, C++, Objective-C or анонимный struct/class/interface
    ClassKind classKind;

    /* !=null if is nested
     * pointing to the дсимвол that directly enclosing it.
     * 1. The function that enclosing it (nested struct and class)
     * 2. The class that enclosing it (nested class only)
     * 3. If enclosing aggregate is template, its enclosing дсимвол.
     * See AggregateDeclaraton::makeNested for the details.
     */
    ДСимвол enclosing;

    VarDeclaration vthis;   // 'this' параметр if this aggregate is nested
    VarDeclaration vthis2;  // 'this' параметр if this aggregate is a template and is nested

    // Special member functions
    FuncDeclarations invs;          // МассивДРК of invariants
    FuncDeclaration inv;            // invariant
    NewDeclaration aggNew;          // allocator

    // CtorDeclaration or TemplateDeclaration
    ДСимвол ctor;

    // default constructor - should have no arguments, because
    // it would be stored in TypeInfo_Class.defaultConstructor
    CtorDeclaration defaultCtor;

    AliasThis aliasthis;    // forward unresolved lookups to aliasthis
    бул noDefaultCtor;     // no default construction

    DtorDeclarations dtors; // МассивДРК of destructors
    DtorDeclaration dtor;   // aggregate destructor
    DtorDeclaration primaryDtor; // non-deleting C++ destructor, same as dtor for D
    DtorDeclaration tidtor; // aggregate destructor используется in TypeInfo (must have extern(D) ABI)
    FuncDeclaration fieldDtor;   // aggregate destructor for just the fields

    Выражение getRTInfo;   // pointer to СМ info generated by объект.RTInfo(this)

    final this(ref Место место, Идентификатор2 ид)
    {
        super(место, ид);
        защита = Prot(Prot.Kind.public_);
    }

    /***************************************
     * Create a new scope from sc.
     * semantic, semantic2 and semantic3 will use this for aggregate члены.
     */
    Scope* newScope(Scope* sc)
    {
        auto sc2 = sc.сунь(this);
        sc2.stc &= STCFlowThruAggregate;
        sc2.родитель = this;
        sc2.inunion = isUnionDeclaration();
        sc2.защита = Prot(Prot.Kind.public_);
        sc2.explicitProtection = 0;
        sc2.aligndecl = null;
        sc2.userAttribDecl = null;
        sc2.namespace = null;
        return sc2;
    }

    override final проц setScope(Scope* sc)
    {
        // Might need a scope to resolve forward references. The check for
        // semanticRun prevents unnecessary setting of _scope during deferred
        // setScope phases for aggregates which already finished semantic().
        // See https://issues.dlang.org/show_bug.cgi?ид=16607
        if (semanticRun < PASS.semanticdone)
            ScopeDsymbol.setScope(sc);
    }

    /***************************************
     * Find all instance fields, then сунь them into `fields`.
     *
     * Runs semantic() for all instance field variables, but also
     * the field types can remain yet not resolved forward references,
     * except direct recursive definitions.
     * After the process sizeok is set to Sizeok.fwd.
     *
     * Возвращает:
     *      нет if any errors occur.
     */
    final бул determineFields()
    {
        if (_scope)
            dsymbolSemantic(this, null);
        if (sizeok != Sizeok.none)
            return да;

        //printf("determineFields() %s, fields.dim = %d\n", вТкст0(), fields.dim);
        // determineFields can be called recursively from one of the fields's v.semantic
        fields.устДим(0);

         static цел func(ДСимвол s, ук param)
        {
            auto v = s.isVarDeclaration();
            if (!v)
                return 0;
            if (v.класс_хранения & STC.manifest)
                return 0;

            auto ad = cast(AggregateDeclaration)param;

            if (v.semanticRun < PASS.semanticdone)
                v.dsymbolSemantic(null);
            // Return in case a recursive determineFields triggered by v.semantic already finished
            if (ad.sizeok != Sizeok.none)
                return 1;

            if (v.aliassym)
                return 0;   // If this variable was really a кортеж, skip it.

            if (v.класс_хранения & (STC.static_ | STC.extern_ | STC.tls | STC.gshared | STC.manifest | STC.ctfe | STC.шаблонпараметр))
                return 0;
            if (!v.isField() || v.semanticRun < PASS.semanticdone)
                return 1;   // unresolvable forward reference

            ad.fields.сунь(v);

            if (v.класс_хранения & STC.ref_)
                return 0;
            auto tv = v.тип.baseElemOf();
            if (tv.ty != Tstruct)
                return 0;
            if (ad == (cast(TypeStruct)tv).sym)
            {
                ткст0 psz = (v.тип.toBasetype().ty == Tsarray) ? "static массив of " : "";
                ad.выведиОшибку("cannot have field `%s` with %ssame struct тип", v.вТкст0(), psz);
                ad.тип = Тип.terror;
                ad.errors = да;
                return 1;
            }
            return 0;
        }

        if (члены)
        {
            for (т_мера i = 0; i < члены.dim; i++)
            {
                auto s = (*члены)[i];
                if (s.apply(&func, cast(ук)this))
                {
                    if (sizeok != Sizeok.none)
                    {
                        // recursive determineFields already finished
                        return да;
                    }
                    return нет;
                }
            }
        }

        if (sizeok != Sizeok.done)
            sizeok = Sizeok.fwd;

        return да;
    }

    /***************************************
     * Возвращает:
     *      The total number of fields minus the number of hidden fields.
     */
    final т_мера nonHiddenFields()
    {
        return fields.dim - isNested() - (vthis2 !is null);
    }

    /***************************************
     * Collect all instance fields, then determine instance size.
     * Возвращает:
     *      нет if failed to determine the size.
     */
    final бул determineSize(Место место)
    {
        //printf("AggregateDeclaration::determineSize() %s, sizeok = %d\n", вТкст0(), sizeok);

        // The previous instance size finalizing had:
        if (тип.ty == Terror)
            return нет;   // failed already
        if (sizeok == Sizeok.done)
            return да;    // succeeded

        if (!члены)
        {
            выведиОшибку(место, "неизвестен размер");
            return нет;
        }

        if (_scope)
            dsymbolSemantic(this, null);

        // Determine the instance size of base class first.
        if (auto cd = isClassDeclaration())
        {
            cd = cd.baseClass;
            if (cd && !cd.determineSize(место))
                goto Lfail;
        }

        // Determine instance fields when sizeok == Sizeok.none
        if (!determineFields())
            goto Lfail;
        if (sizeok != Sizeok.done)
            finalizeSize();

        // this aggregate тип has:
        if (тип.ty == Terror)
            return нет;   // marked as invalid during the finalizing.
        if (sizeok == Sizeok.done)
            return да;    // succeeded to calculate instance size.

    Lfail:
        // There's unresolvable forward reference.
        if (тип != Тип.terror)
            выведиОшибку(место, "no size because of forward reference");
        // Don't cache errors from speculative semantic, might be resolvable later.
        // https://issues.dlang.org/show_bug.cgi?ид=16574
        if (!глоб2.gag)
        {
            тип = Тип.terror;
            errors = да;
        }
        return нет;
    }

    abstract проц finalizeSize();

    override final d_uns64 size(ref Место место)
    {
        //printf("+AggregateDeclaration::size() %s, scope = %p, sizeok = %d\n", вТкст0(), _scope, sizeok);
        бул ok = determineSize(место);
        //printf("-AggregateDeclaration::size() %s, scope = %p, sizeok = %d\n", вТкст0(), _scope, sizeok);
        return ok ? structsize : SIZE_INVALID;
    }

    /***************************************
     * Calculate field[i].overlapped and overlapUnsafe, and check that all of explicit
     * field initializers have unique memory space on instance.
     * Возвращает:
     *      да if any errors happen.
     */
    final бул checkOverlappedFields()
    {
        //printf("AggregateDeclaration::checkOverlappedFields() %s\n", вТкст0());
        assert(sizeok == Sizeok.done);
        т_мера nfields = fields.dim;
        if (isNested())
        {
            auto cd = isClassDeclaration();
            if (!cd || !cd.baseClass || !cd.baseClass.isNested())
                nfields--;
            if (vthis2 && !(cd && cd.baseClass && cd.baseClass.vthis2))
                nfields--;
        }
        бул errors = нет;

        // Fill in missing any elements with default initializers
        foreach (i; new бцел[0 .. nfields])
        {
            auto vd = fields[i];
            if (vd.errors)
            {
                errors = да;
                continue;
            }

            const vdIsVoidInit = vd._иниц && vd._иниц.isVoidInitializer();

            // Find overlapped fields with the hole [vd.смещение .. vd.смещение.size()].
            foreach (j; new бцел[0 .. nfields])
            {
                if (i == j)
                    continue;
                auto v2 = fields[j];
                if (v2.errors)
                {
                    errors = да;
                    continue;
                }
                if (!vd.isOverlappedWith(v2))
                    continue;

                // vd and v2 are overlapping.
                vd.overlapped = да;
                v2.overlapped = да;

                if (!MODimplicitConv(vd.тип.mod, v2.тип.mod))
                    v2.overlapUnsafe = да;
                if (!MODimplicitConv(v2.тип.mod, vd.тип.mod))
                    vd.overlapUnsafe = да;

                if (i > j)
                    continue;

                if (!v2._иниц)
                    continue;

                if (v2._иниц.isVoidInitializer())
                    continue;

                if (vd._иниц && !vdIsVoidInit && v2._иниц)
                {
                    .выведиОшибку(место, "overlapping default initialization for field `%s` and `%s`", v2.вТкст0(), vd.вТкст0());
                    errors = да;
                }
                else if (v2._иниц && i < j)
                {
                    // @@@DEPRECATED_v2.086@@@.
                    .deprecation(v2.место, "union field `%s` with default initialization `%s` must be before field `%s`",
                        v2.вТкст0(), v2._иниц.вТкст0(), vd.вТкст0());
                    //errors = да;
                }
            }
        }
        return errors;
    }

    /***************************************
     * Fill out remainder of elements[] with default initializers for fields[].
     * Параметры:
     *      место         = location
     *      elements    = explicit arguments which given to construct объект.
     *      ctorinit    = да if the elements will be используется for default initialization.
     * Возвращает:
     *      нет if any errors occur.
     *      Otherwise, returns да and the missing arguments will be pushed in elements[].
     */
    final бул fill(Место место, Выражения* elements, бул ctorinit)
    {
        //printf("AggregateDeclaration::fill() %s\n", вТкст0());
        assert(sizeok == Sizeok.done);
        assert(elements);
        const nfields = nonHiddenFields();
        бул errors = нет;

        т_мера dim = elements.dim;
        elements.устДим(nfields);
        foreach (т_мера i; new бцел[dim .. nfields])
            (*elements)[i] = null;

        // Fill in missing any elements with default initializers
        foreach (i; new бцел[0 .. nfields])
        {
            if ((*elements)[i])
                continue;

            auto vd = fields[i];
            auto vx = vd;
            if (vd._иниц && vd._иниц.isVoidInitializer())
                vx = null;

            // Find overlapped fields with the hole [vd.смещение .. vd.смещение.size()].
            т_мера fieldi = i;
            foreach (j; new бцел[0 .. nfields])
            {
                if (i == j)
                    continue;
                auto v2 = fields[j];
                if (!vd.isOverlappedWith(v2))
                    continue;

                if ((*elements)[j])
                {
                    vx = null;
                    break;
                }
                if (v2._иниц && v2._иниц.isVoidInitializer())
                    continue;

                version (all)
                {
                    /* Prefer first found non-проц-initialized field
                     * union U { цел a; цел b = 2; }
                     * U u;    // Error: overlapping initialization for field a and b
                     */
                    if (!vx)
                    {
                        vx = v2;
                        fieldi = j;
                    }
                    else if (v2._иниц)
                    {
                        .выведиОшибку(место, "overlapping initialization for field `%s` and `%s`", v2.вТкст0(), vd.вТкст0());
                        errors = да;
                    }
                }
                else
                {
                    // fixes https://issues.dlang.org/show_bug.cgi?ид=1432 by enabling this path always

                    /* Prefer explicitly initialized field
                     * union U { цел a; цел b = 2; }
                     * U u;    // OK (u.b == 2)
                     */
                    if (!vx || !vx._иниц && v2._иниц)
                    {
                        vx = v2;
                        fieldi = j;
                    }
                    else if (vx != vd && !vx.isOverlappedWith(v2))
                    {
                        // Both vx and v2 fills vd, but vx and v2 does not overlap
                    }
                    else if (vx._иниц && v2._иниц)
                    {
                        .выведиОшибку(место, "overlapping default initialization for field `%s` and `%s`",
                            v2.вТкст0(), vd.вТкст0());
                        errors = да;
                    }
                    else
                        assert(vx._иниц || !vx._иниц && !v2._иниц);
                }
            }
            if (vx)
            {
                Выражение e;
                if (vx.тип.size() == 0)
                {
                    e = null;
                }
                else if (vx._иниц)
                {
                    assert(!vx._иниц.isVoidInitializer());
                    if (vx.inuse)   // https://issues.dlang.org/show_bug.cgi?ид=18057
                    {
                        vx.выведиОшибку(место, "recursive initialization of field");
                        errors = да;
                    }
                    else
                        e = vx.getConstInitializer(нет);
                }
                else
                {
                    if ((vx.класс_хранения & STC.nodefaultctor) && !ctorinit)
                    {
                        .выведиОшибку(место, "field `%s.%s` must be initialized because it has no default constructor",
                            тип.вТкст0(), vx.вТкст0());
                        errors = да;
                    }
                    /* https://issues.dlang.org/show_bug.cgi?ид=12509
                     * Get the element of static массив тип.
                     */
                    Тип telem = vx.тип;
                    if (telem.ty == Tsarray)
                    {
                        /* We cannot use Тип::baseElemOf() here.
                         * If the bottom of the Tsarray is an enum тип, baseElemOf()
                         * will return the base of the enum, and its default инициализатор
                         * would be different from the enum's.
                         */
                        while (telem.toBasetype().ty == Tsarray)
                            telem = (cast(TypeSArray)telem.toBasetype()).следщ;
                        if (telem.ty == Tvoid)
                            telem = Тип.tuns8.addMod(telem.mod);
                    }
                    if (telem.needsNested() && ctorinit)
                        e = telem.defaultInit(место);
                    else
                        e = telem.defaultInitLiteral(место);
                }
                (*elements)[fieldi] = e;
            }
        }
        foreach (e; *elements)
        {
            if (e && e.op == ТОК2.error)
                return нет;
        }

        return !errors;
    }

    /****************************
     * Do byte or word alignment as necessary.
     * Align sizes of 0, as we may not know массив sizes yet.
     * Параметры:
     *   alignment = struct alignment that is in effect
     *   size = alignment requirement of field
     *   poffset = pointer to смещение to be aligned
     */
    extern (D) static проц alignmember(structalign_t alignment, бцел size, бцел* poffset)  
    {
        //printf("alignment = %d, size = %d, смещение = %d\n",alignment,size,смещение);
        switch (alignment)
        {
        case cast(structalign_t)1:
            // No alignment
            break;

        case cast(structalign_t)STRUCTALIGN_DEFAULT:
            // Alignment in Target::fieldalignsize must match what the
            // corresponding C compiler's default alignment behavior is.
            assert(size > 0 && !(size & (size - 1)));
            *poffset = (*poffset + size - 1) & ~(size - 1);
            break;

        default:
            // Align on alignment boundary, which must be a positive power of 2
            assert(alignment > 0 && !(alignment & (alignment - 1)));
            *poffset = (*poffset + alignment - 1) & ~(alignment - 1);
            break;
        }
    }

    /****************************************
     * Place a member (mem) into an aggregate (agg), which can be a struct, union or class
     * Возвращает:
     *      смещение to place field at
     *
     * nextoffset:    следщ location in aggregate
     * memsize:       size of member
     * memalignsize:  natural alignment of member
     * alignment:     alignment in effect for this member
     * paggsize:      size of aggregate (updated)
     * paggalignsize: alignment of aggregate (updated)
     * isunion:       the aggregate is a union
     */
    extern (D) static бцел placeField(бцел* nextoffset, бцел memsize, бцел memalignsize,
        structalign_t alignment, бцел* paggsize, бцел* paggalignsize, бул isunion)
    {
        бцел ofs = *nextoffset;

        const бцел actualAlignment =
            alignment == STRUCTALIGN_DEFAULT ? memalignsize : alignment;

        // Гарант no overflow
        бул overflow;
        const sz = addu(memsize, actualAlignment, overflow);
        addu(ofs, sz, overflow);
        if (overflow) assert(0);

        alignmember(alignment, memalignsize, &ofs);
        бцел memoffset = ofs;
        ofs += memsize;
        if (ofs > *paggsize)
            *paggsize = ofs;
        if (!isunion)
            *nextoffset = ofs;

        if (*paggalignsize < actualAlignment)
            *paggalignsize = actualAlignment;

        return memoffset;
    }

    override final Тип getType()
    {
        return тип;
    }

    // is aggregate deprecated?
    override final бул isDeprecated()
    {
        return !!(this.класс_хранения & STC.deprecated_);
    }

    /// Flag this aggregate as deprecated
    final проц setDeprecated()
    {
        this.класс_хранения |= STC.deprecated_;
    }

    /****************************************
     * Возвращает да if there's an extra member which is the 'this'
     * pointer to the enclosing context (enclosing aggregate or function)
     */
    final бул isNested()
    {
        return enclosing !is null;
    }

    /* Append vthis field (this.tupleof[$-1]) to make this aggregate тип nested.
     */
    extern (D) final проц makeNested()
    {
        if (enclosing) // if already nested
            return;
        if (sizeok == Sizeok.done)
            return;
        if (isUnionDeclaration() || isInterfaceDeclaration())
            return;
        if (класс_хранения & STC.static_)
            return;

        // If nested struct, add in hidden 'this' pointer to outer scope
        auto s = toParentLocal();
        if (!s)
            s = toParent2();
        if (!s)
            return;
        Тип t = null;
        if (auto fd = s.isFuncDeclaration())
        {
            enclosing = fd;

            /* https://issues.dlang.org/show_bug.cgi?ид=14422
             * If a nested class родитель is a function, its
             * context pointer (== `outer`) should be ук always.
             */
            t = Тип.tvoidptr;
        }
        else if (auto ad = s.isAggregateDeclaration())
        {
            if (isClassDeclaration() && ad.isClassDeclaration())
            {
                enclosing = ad;
            }
            else if (isStructDeclaration())
            {
                if (auto ti = ad.родитель.isTemplateInstance())
                {
                    enclosing = ti.enclosing;
                }
            }
            t = ad.handleType();
        }
        if (enclosing)
        {
            //printf("makeNested %s, enclosing = %s\n", вТкст0(), enclosing.вТкст0());
            assert(t);
            if (t.ty == Tstruct)
                t = Тип.tvoidptr; // t should not be a ref тип

            assert(!vthis);
            vthis = new ThisDeclaration(место, t);
            //vthis.класс_хранения |= STC.ref_;

            // Emulate vthis.addMember()
            члены.сунь(vthis);

            // Emulate vthis.dsymbolSemantic()
            vthis.класс_хранения |= STC.field;
            vthis.родитель = this;
            vthis.защита = Prot(Prot.Kind.public_);
            vthis.alignment = t.alignment();
            vthis.semanticRun = PASS.semanticdone;

            if (sizeok == Sizeok.fwd)
                fields.сунь(vthis);

            makeNested2();
        }
    }

    /* Append vthis2 field (this.tupleof[$-1]) to add a second context pointer.
     */
    extern (D) final проц makeNested2()
    {
        if (vthis2)
            return;
        if (!vthis)
            makeNested();   // can't add second before first
        if (!vthis)
            return;
        if (sizeok == Sizeok.done)
            return;
        if (isUnionDeclaration() || isInterfaceDeclaration())
            return;
        if (класс_хранения & STC.static_)
            return;

        auto s0 = toParentLocal();
        auto s = toParent2();
        if (!s || !s0 || s == s0)
            return;
        auto cd = s.isClassDeclaration();
        Тип t = cd ? cd.тип : Тип.tvoidptr;

        vthis2 = new ThisDeclaration(место, t);
        //vthis2.класс_хранения |= STC.ref_;

        // Emulate vthis2.addMember()
        члены.сунь(vthis2);

        // Emulate vthis2.dsymbolSemantic()
        vthis2.класс_хранения |= STC.field;
        vthis2.родитель = this;
        vthis2.защита = Prot(Prot.Kind.public_);
        vthis2.alignment = t.alignment();
        vthis2.semanticRun = PASS.semanticdone;

        if (sizeok == Sizeok.fwd)
            fields.сунь(vthis2);
    }

    override final бул isExport()
    {
        return защита.вид == Prot.Kind.export_;
    }

    /*******************************************
     * Look for constructor declaration.
     */
    final ДСимвол searchCtor()
    {
        auto s = search(Место.initial, Id.ctor);
        if (s)
        {
            if (!(s.isCtorDeclaration() ||
                  s.isTemplateDeclaration() ||
                  s.isOverloadSet()))
            {
                s.выведиОшибку("is not a constructor; identifiers starting with `__` are reserved for the implementation");
                errors = да;
                s = null;
            }
        }
        if (s && s.toParent() != this)
            s = null; // search() looks through ancestor classes
        if (s)
        {
            // Finish all constructors semantics to determine this.noDefaultCtor.
            struct SearchCtor
            {
                 static цел fp(ДСимвол s, ук ctxt)
                {
                    auto f = s.isCtorDeclaration();
                    if (f && f.semanticRun == PASS.init)
                        f.dsymbolSemantic(null);
                    return 0;
                }
            }

            for (т_мера i = 0; i < члены.dim; i++)
            {
                auto sm = (*члены)[i];
                sm.apply(&SearchCtor.fp, null);
            }
        }
        return s;
    }

    override final Prot prot()   
    {
        return защита;
    }

    // 'this' тип
    final Тип handleType()
    {
        return тип;
    }

    // Back end
    Symbol* stag; // tag symbol for debug данные
    Symbol* sinit;

    override final AggregateDeclaration isAggregateDeclaration() 
    {
        return this;
    }

    override проц прими(Визитор2 v)
    {
        v.посети(this);
    }
}
