/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity high)
module drc.doc.Doc;

import drc.doc.Parser;
import drc.ast.Node;
import drc.lexer.Funcs;
import drc.Unicode;
import common;

import text.Ascii : сравнилюб;

alias drc.doc.Parser.ПарсерЗначенияИдентификатора.телоТекста телоТекста;

/// Представляет собой санитированный и парсированный комментарий DDoc.
class КомментарийДДок
{
  Раздел[] разделы; /// Разделы этого комментария.
  Раздел сводка; /// Необязательный раздел сводка.
  Раздел описание; /// Необязательный раздел описание.

  this(Раздел[] разделы, Раздел сводка, Раздел описание)
  {
    this.разделы = разделы;
    this.сводка = сводка;
    this.описание = описание;
  }

  /// Удаляет первый раздел авторское_право и возвращает его.
  Раздел взятьАвторскоеПраво()
  {
    foreach (i, раздел; разделы)
      if (раздел.Является("авторское_право"))
      {
        разделы = разделы[0..i] ~ разделы[i+1..$];
        return раздел;
      }
    return пусто;
  }

  /// Возвращает да, если в этом комментарии "определено" единственный текст.
  бул дитто()
  {
    return сводка && разделы.length == 1 &&
           сравнилюб(сводка.текст, "определено") == 0;
  }
}

/// Пространство имён для некоторых утилитных функций.
struct УтилитыДДок
{
static:
  /// Возвращает узел's КомментарийДДок.
  КомментарийДДок дайКомментарийДДок(Узел узел)
  {
    ПарсерДДок у;
    auto семыДок = дайСемыДокум(узел);
    if (!семыДок.length)
      return пусто;
    у.разбор(дайТекстДДок(семыДок));
    return new КомментарийДДок(у.разделы, у.сводка, у.описание);
  }

  /// Возвращает КомментарийДДок созданный из текста.
  КомментарийДДок дайКомментарийДДок(ткст текст)
  {
    текст = санитируй(текст, '\0'); // May be unnecessary.
    ПарсерДДок у;
    у.разбор(текст);
    return new КомментарийДДок(у.разделы, у.сводка, у.описание);
  }

  /// Возвращает "да", если сема - комментарий Doxygen.
  бул комментДоксигена(Сема* сема)
  { // Doxygen: '/+!' '/*!' '//!'
    return сема.вид == ТОК2.Комментарий && сема.старт[2] == '!';
  }

  /// Возвращает "да", если сема - комментарий DDoc.
  бул комментДДока(Сема* сема)
  { // DDOC: '/++' '/**' '///'
    return сема.вид == ТОК2.Комментарий && сема.старт[1] == сема.старт[2];
  }

  /// Возвращает семы, окрущающие документационные комментарии.
  /// Параметры:
  ///   узел = узел, для которого нужно найди комментарии документации.
  ///   докКоммент_ли = предикат функции, проверяющий семы документации.
  /// Примечание: эта функция работает правильно только, если
  ///       исходный текст синтактически верен.
  Сема*[] дайСемыДокум(Узел узел, бул function(Сема*) докКоммент_ли = &комментДДока)
  {
    Сема*[] комменты;
    auto членПеречня_ли = узел.вид == ВидУзла.ДекларацияЧленаПеречня;
    // Получить предыдущие комменты.
    auto сема = узел.начало;
    // Сканировать обратно до нахождения другой декларации.
  Loop:
    for (; сема; сема = сема.предш)
    {
      if (сема.вид == ТОК2.ЛФСкобка ||
          сема.вид == ТОК2.ПФСкобка ||
          сема.вид == ТОК2.ТочкаЗапятая ||
          /+сема.вид == ТОК2.ГОЛОВА ||+/
          (членПеречня_ли && сема.вид == ТОК2.Запятая))
        break;

      if (сема.вид == ТОК2.Комментарий)
      { // Проверка, что этот коммент не относится к предшествующей документации.
        switch (сема.предш.вид)
        {
        case ТОК2.ТочкаЗапятая, ТОК2.ПФСкобка, ТОК2.Запятая:
          break Loop;
        default:
          if (докКоммент_ли(сема))
            комменты = [сема] ~ комменты;
        }
      }
    }
    // Получить единичный комментарий справа.
    сема = узел.конец.следщ;
    if (сема.вид == ТОК2.Комментарий && докКоммент_ли(сема))
      комменты ~= сема;
    else if (членПеречня_ли)
    {
      сема = узел.конец.следщНепроб;
      if (сема.вид == ТОК2.Запятая)
      {
        сема = сема.следщ;
        if (сема.вид == ТОК2.Комментарий && докКоммент_ли(сема))
          комменты ~= сема;
      }
    }
    return комменты;
  }

  бул однострочныйКоммент_ли(Сема* т)
  {
    assert(т.вид == ТОК2.Комментарий);
    return т.старт[1] == '/';
  }

  ///Извлекает текстовое тело семы комментария.
  ткст дайТекстДДок(Сема*[] семы)
  {
    if (семы.length == 0)
      return пусто;
    ткст результат;
    foreach (сема; семы)
    { // Determine how many characters в срез off из the конец of the коммент.
      // 0 for "//", 2 for "+/" and "*/".
      auto n = однострочныйКоммент_ли(сема) ? 0 : 2;
      результат ~= санитируй(сема.исхТекст[3 .. $-n], сема.старт[1]);
      assert(сема.следщ);
      результат ~= (сема.следщ.вид == ТОК2.Новстр) ? '\n' : ' ';
    }
    return результат[0..$-1]; // Срез off last '\n' или ' '.
  }

  /// Санатирует текст комментария DDoc.
  ///
  /// Вводные "симКоммент"ы удаляются из строчки.
  /// Разного типа нс преобразуются в '\n'.
  /// Параметры:
  ///   коммент = санитируемый ткст.
  ///   симКоммент = '/', '+' или '*'
  ткст санитируй(ткст коммент, сим симКоммент)
  {
    alias коммент результат;

    бул нс = да; // Истина, если находимся в начале новой строки.
    бцел i, j;
    auto длин = результат.length;
    for (; i < длин; i++, j++)
    {
      if (нс)
      { // Игнорируем симКомменты в начале каждой новой строки.
        нс = нет;
        auto начало = i;
        while (i < длин && пбел(результат[i]))
          i++;
        if (i < длин && результат[i] == симКоммент)
          while (++i < длин && результат[i] == симКоммент)
          {}
        else
          i = начало; // Сброс. Ни один симКоммент не найден.
        if (i >= длин)
          break;
      }
      // Проверим на Новстр.
      switch (результат[i])
      {
      case '\r':
        if (i+1 < длин && результат[i+1] == '\n')
          i++;
      case '\n':
        результат[j] = '\n'; // Копируем Новстр как '\n'.
        нс = да;
        continue;
      default:
        if (!аски(результат[i]) && i+2 < длин && новСтрЮ(результат.ptr + i))
        {
          i += 2;
          goto case '\n';
        }
      }
      // Копируем символ.
      результат[j] = результат[i];
    }
    результат.length = j; // Настраиваем длину.

    if (!результат.length)
      return пусто;
    i = результат.length;
    for (; i && результат[i-1] == симКоммент; i--)
    {}
    результат.length = i;
    return результат;
  }

  /// Убрать отступы всех строк в тексте максимально возможным образом.
  /// Примечание: считает табуляторы как единичные пробелы.
  /// Возвращает: текст без отступов или оригинальный текст.
  ткст unindentText(ткст текст)
  {
    ткст0 у = текст.ptr, конец = у + текст.length;
    бцел отступ = бцел.max; // Старт с наибольшего числа.
    ткст0 начстр = у; // Начало строки.
    // Определим максимум  для удаления.
    while (у < конец)
    {
      while (у < конец && пбел(*у)) // Пропустим вводный пробел.
        у++;
      if (у < конец && *у != '\n') //Не считать пустые строчки.
        if (у - начстр < отступ)
        {
          отступ = у - начстр;
          if (отступ == 0)
            return текст; // Nothing в unindent;
        }
      // Пропустим до конца строки.
      while (у < конец && *у != '\n')
        у++;
      while (у < конец && *у == '\n')
        у++;
      начстр = у;
    }

    у = текст.ptr, конец = у + текст.length;
    начстр = у;
    ткст0 q = у; // Писака.
    // Удалим определённый нами максимум.
    while (у < конец)
    {
      while (у < конец && пбел(*у)) // Пропустим вводный пробел.
        *q++ = *у++;
      if (у < конец && *у == '\n') // Сбросим пустые строчки.
        q -= у - начстр; // Back up q by the amount of spaces on this line.
      else {//if (отступ <= у - начстр)
        assert(отступ <= у - начстр);
        q -= отступ; // Back up q by the отступ amount.
      }
      // Пропустим до конца строки.
      while (у < конец && *у != '\n')
        *q++ = *у++;
      while (у < конец && *у == '\n')
        *q++ = *у++;
      начстр = у;
    }
    текст.length = q - текст.ptr;
    return текст;
  }
}

/// Разбирает текст комментариев DDoc.
struct ПарсерДДок
{
  ткст0 у; /// Указатель на текущий символ.
  ткст0 конецТекста; /// Указывает на символ после конца текста.
  Раздел[] разделы; /// Разобранные разделы.
  Раздел сводка; /// Необязательный раздел сводки.
  Раздел описание; /// Необязательный раздел описания.

  /// Разбирает DDoc текст на разделы.
  /// Все новые строки в тексте должны быть преобразованы в '\n'.
  Раздел[] разбор(ткст текст)
  {
    if (!текст.length)
      return пусто;
    у = текст.ptr;
    конецТекста = у + текст.length;

    ткст0 началоСводки;
    ткст идент, следщИдент;
    ткст0 началоТела, началоСледщТела;

    while (у < конецТекста && (пбел(*у) || *у == '\n'))
      у++;
    началоСводки = у;

    if (найдиСледщИдДвоеточие(идент, началоТела))
    { // Проверяет, что этот раздел не явный.
      if (началоСводки != идент.ptr)
        сканируйСводкуИОписание(началоСводки, идент.ptr);
    }
    else // Явных разделов нет.
    {
      сканируйСводкуИОписание(началоСводки, конецТекста);
      return разделы;
    }

    assert(идент.length);
    // Дальнейший разбор.
    while (найдиСледщИдДвоеточие(следщИдент, началоСледщТела))
    {
      разделы ~= new Раздел(идент, телоТекста(началоТела, следщИдент.ptr));
      идент = следщИдент;
      началоТела = началоСледщТела;
    }
    // Добавить последний раздел.
    разделы ~= new Раздел(идент, телоТекста(началоТела, конецТекста));
    return разделы;
  }

  /// Разделяет текст между у и конец
  /// на разделы сводки и необязательного описания.
  проц  сканируйСводкуИОписание(ткст0 у, ткст0 конец)
  {
    assert(у <= конец);
    ткст0 началоРаздела = у;
    // Ищем конец первого параграфа.
    while (у < конец && !(*у == '\n' && у+1 < конец && у[1] == '\n'))
      if (пропустиСекциюКода(у, конец) == нет)
        у++;
    assert(у == конец || (*у == '\n' && у[1] == '\n'));
    // Первый параграф является сводкой.
    сводка = new Раздел("", телоТекста(началоРаздела, у));
    разделы ~= сводка;
    // Остальное - раздел описания.
    if (auto текстОписания = телоТекста(у, конец))
      разделы ~= (описание = new Раздел("", текстОписания));
    assert(описание ? описание.текст !is пусто : да);
  }

  /// Возвращает "да", если у указывает на "$(DDD)".
  static бул секцияКода(ткст0 у, ткст0 конец)
  {
    return у < конец && *у == '-' && у+2 < конец && у[1] == '-' && у[2] == '-';
  }

  /// Минует раздел с кодом и устанавливает у на один символ после него.
  /// Возвращает: "да", если раздел с кодом был пропущен.
  static бул пропустиСекциюКода(ref ткст0 у, ткст0 конец)
  {
    if (!секцияКода(у, конец))
      return нет;
    у += 3; // Пропустим "---".
    while (у < конец && *у == '-')
      у++;
    while (у < конец && !(*у == '-' && у+2 < конец && у[1] == '-' && у[2] == '-'))
      у++;
    while (у < конец && *у == '-')
      у++;
    assert(у is конец || у[-1] == '-');
    return да;
  }

  /// Найти следующий "Идентификатор:".
  /// Параметры:
  ///   идент = установлен на Идентификатор.
  ///   началоТела = установлен на начало oтдела текста (пробелы пропускаются.)
  /// Возвращает: "да", если найден.
  бул найдиСледщИдДвоеточие(ref ткст идент, ref ткст0 началоТела)
  {
    while (у < конецТекста)
    {
      пропустиПробельные();
      if (у is конецТекста)
        break;
      if (пропустиСекциюКода(у, конецТекста))
        continue;
      assert(у < конецТекста && (аски(*у) || ведущийБайт(*у)));
      идент = сканируйИдентификатор(у, конецТекста);
      if (идент && у < конецТекста && *у == ':')
      {
        началоТела = ++у;
        пропустиСтроку();
        return да;
      }
      пропустиСтроку();
    }
    assert(у is конецТекста);
    return нет;
  }

  проц  пропустиПробельные()
  {
    while (у < конецТекста && пбел(*у))
      у++;
  }

  проц  пропустиСтроку()
  {
    while (у < конецТекста && *у != '\n')
      у++;
    while (у < конецТекста && *у == '\n')
      у++;
  }
}

/// Представляет раздел DDoc.
class Раздел
{
  ткст имя;
  ткст текст;
  this(ткст имя, ткст текст)
  {
    this.имя = имя;
    this.текст = текст;
  }

  /// Сравнивает регистронейтральным образом текст имя с Имя2.
  бул Является(ткст Имя2)
  {
    return сравнилюб(имя, Имя2) == 0;
  }

  /// Возвращает текст раздела, включая его имя.
  ткст весьТекст()
  {
    if (имя.length == 0)
      return текст;
    return сделайТекст(имя.ptr, текст.ptr+текст.length);
  }
}

class РазделПараметров : Раздел
{
  ткст[] именаПарамов; /// Имена параметров.
  ткст[] деклыПарамов; /// Описания параметров.
  this(ткст имя, ткст текст)
  {
    super(имя, текст);
    ПарсерЗначенияИдентификатора парсер;
    auto идзначения = парсер.разбор(текст);
    this.именаПарамов = new ткст[идзначения.length];
    this.деклыПарамов = new ткст[идзначения.length];
    foreach (i, идзначение; идзначения)
    {
      this.именаПарамов[i] = идзначение.идент;
      this.деклыПарамов[i] = идзначение.значение;
    }
  }
}

class РазделМакросов : Раздел
{
  ткст[] именаМакросов; /// Имена макросов.
  ткст[] текстыМакросов; /// Тексты макросов.
  this(ткст имя, ткст текст)
  {
    super(имя, текст);
    ПарсерЗначенияИдентификатора парсер;
    auto идзначения = парсер.разбор(текст);
    this.именаМакросов = new ткст[идзначения.length];
    this.текстыМакросов = new ткст[идзначения.length];
    foreach (i, идзначение; идзначения)
    {
      this.именаМакросов[i] = идзначение.идент;
      this.текстыМакросов[i] = идзначение.значение;
    }
  }
}
