module drc.lexer.Lexer;

import drc.lexer.Token,
       drc.lexer.Keywords,
       drc.lexer.Identifier,
       drc.lexer.IdTable;
import drc.Diagnostics;
import drc.Messages;
import drc.HtmlEntities;
import drc.CompilerInfo;
import drc.Unicode;
import drc.SourceText;
import drc.Time;
import common;

import cidrus : strtof, strtod, strtold, ERANGE;
import core.TangoVararg;

extern(C) цел getErrno();      // для внутреннего пользования
extern(C) цел setErrno(цел);   // для внутреннего пользования

alias getErrno errno;
alias setErrno errno;

public import drc.lexer.Funcs;

/// Лексер анализирует символы исходного текста и
/// производит дважды-линкованный список сем (токенов).
class Лексер
{
  ИсходныйТекст исхТекст; /// Исходный текст.
  ткст0 у;            /// Указывает на текущий символ в исходном тексте.
  ткст0 конец;          /// Указывает на символ после конца исходного текста.

  Сема* глава;  /// Глава дважды линкованного списка сем.
  Сема* хвост;  /// Хвост линкованного списка. Устанавливается в сканируй().
  Сема* сема; /// Указывает на текущую сему в списке сем.

  // Члены, используемые для сообщений об ошибке:
  Диагностика диаг;
  ОшибкаЛексера[] ошибки;
  /// Всегда указывает на первый символ текущей строки.
  ткст0 началоСтроки;
//   Сема* нс;     /// Текущая нс сема.
  бцел номерСтроки = 1;   /// Текущий, действительный номер строки исходного текста.
  бцел номСтр_хлайн; /// Номер строки, установленный #line.
  бцел вСемТкст; /// > 0, если внутри q{ }
  /// Содержит исходный и модифицированный файловые пути (посредством #line.)
  ДанныеНовСтр.ФПути* путиКФайлам;

  /// Конструировать Лексер объект.
  /// Параметры:
  ///   исхТекст = исходный код в UTF-8.
  ///   диаг = используется для сбора сообщений об ошибках.
  this(ИсходныйТекст исхТекст, Диагностика диаг = пусто)
  {
    this.исхТекст = исхТекст;
    this.диаг = диаг;

    assert(текст.length && текст[$-1] == 0, "в исходнике отсутствует символ sentinel");
    this.у = текст.ptr;
    this.конец = this.у + текст.length;
    this.началоСтроки = this.у;

    this.глава = new Сема;
    this.глава.вид = ТОК.ГОЛОВА;
    this.глава.старт = this.глава.конец = this.у;
    this.сема = this.глава;
    // Инициализовать this.путиКФайлам.
    новыйПутьФ(this.исхТекст.путьКФайлу);
    // Добавить нс как первую сему после главы.
    auto нс = new Сема;
    нс.вид = ТОК.Новстр;
    нс.установиФлагПробельные();
    нс.старт = нс.конец = this.у;
    нс.нс.путиКФайлам = this.путиКФайлам;
    нс.нс.ориНомСтр = 1;
    нс.нс.устНомСтр = 0;
    // Link in.
    this.сема.следщ = нс;
    нс.предш = this.сема;
    this.сема = нс;
//     this.нс = нс;
    сканируйШебанг();
  }

  /// Деструктор удаляет дважды линкованный список сем.
  ~this()
  {
    auto сема = глава.следщ;
    while (сема !is пусто)
    {
      assert(сема.вид == ТОК.КФ ? сема == хвост && сема.следщ is пусто : 1);
      delete сема.предш;
      сема = сема.следщ;
    }
    delete хвост;
  }

  ткст текст()
  {
    return исхТекст.данные;
  }

  /// "Шебанг" может единожды опционально появляться в начале файла.
  /// Regexp: #![^\КонецСтроки]*
  проц  сканируйШебанг()
  {
    if (*у == '#' && у[1] == '!')
    {
      auto т = new Сема;
      т.вид = ТОК.Шебанг;
      т.установиФлагПробельные();
      т.старт = у;
      ++у;
      while (!конецСтроки(++у))
        аски(*у) || раскодируйЮ8();
      т.конец = у;
      this.сема.следщ = т;
      т.предш = this.сема;
    }
  }

  /// Устанавливает значение у особой семы.
  проц  закончиОсобуюСему(ref Сема т)
  {
    assert(т.исхТекст[0..2] == "__");
    switch (т.вид)
    {
    case ТОК.ФАЙЛ:
      т.ткт = this.путиКФайлам.устПуть;
      break;
    case ТОК.СТРОКА:
      т.бцел_ = this.номерСтрокиОшиб(this.номерСтроки);
      break;
    case ТОК.ДАТА,
         ТОК.ВРЕМЯ,
         ТОК.ШТАМПВРЕМЕНИ:
      auto ткт_время = Время.вТкст();
      switch (т.вид)
      {
      case ТОК.ДАТА:
        ткт_время = Время.день_месяца(ткт_время) ~ ' ' ~ Время.год(ткт_время); break;
      case ТОК.ВРЕМЯ:
        ткт_время = Время.время(ткт_время); break;
      case ТОК.ШТАМПВРЕМЕНИ:
        break; // ткт_время - штамп времени.
      default: assert(0);
      }
      ткт_время ~= '\0'; // Завершается нулём.
      т.ткт = ткт_время;
      break;
    case ТОК.ПОСТАВЩИК:
      т.ткт = ПОСТАВЩИК;
      break;
    case ТОК.ВЕРСИЯ:
      т.бцел_ = ВЕРСИЯ_МАЖОР*1000 + ВЕРСИЯ_МИНОР;
      break;
    default:
      assert(0);
    }
  }

  /// Устанавливает новый файловый путь.
  проц  новыйПутьФ(ткст новПуть)
  {
    auto пути = new ДанныеНовСтр.ФПути;
    пути.исхПуть = this.исхТекст.путьКФайлу;
    пути.устПуть = новПуть;
    this.путиКФайлам = пути;
  }

  private проц  установиНачалоСтроки(ткст0 у)
  {
    // Проверка возвожности заглянуть за один символ.
    assert((у-1) >= текст.ptr && у < конец);
    // Проверка на то, что предшествующий символ есть нс.
    assert(конецНовСтроки(у - 1));
    this.началоСтроки = у;
  }

  /// Сканирует следующую сему в исходном тексте.
  ///
  /// Создаёт новую сему, если т.следщ = пусто, и добавляет её к списку.
  private проц  сканируйСледщ(ref Сема* т)
  {
    assert(т !is пусто);
    if (т.следщ)
    {
      т = т.следщ;
//       if (т.вид == ТОК.Новстр)
//         this.нс = т;
    }
    else if (т != this.хвост)
    {
      Сема* т_нов = new Сема;
      сканируй(*т_нов);
      т_нов.предш = т;
      т.следщ = т_нов;
      т = т_нов;
    }
  }

  /// Продвинуть т на одну сему вперёд.
  проц  возьми(ref Сема* т)
  {
    сканируйСледщ(т);
  }

  /// Переместиться на следующую сему по исходному тексту.
  ТОК следщСема()
  {
    сканируйСледщ(this.сема);
    return this.сема.вид;
  }

  /// Возвращает да, если у указывает на последний символ Новстр.
  бул конецНовСтроки(ткст0 у)
  {
    if (*у == '\n' || *у == '\r')
      return да;
    if (*у == РС[2] || *у == РА[2])
      if ((у-2) >= текст.ptr)
        if (у[-1] == РС[1] && у[-2] == РС[0])
          return да;
    return нет;
  }

  /// Главный метод, который распознаёт символы, составляющие сему.
  ///
  /// Сложные семы сканируются отдельными методами.
  public проц  сканируй(ref Сема т)
  in
  {
    assert(текст.ptr <= у && у < конец);
  }
  out
  {
    assert(текст.ptr <= т.старт && т.старт < конец, Сема.вТкст(т.вид));
    assert(текст.ptr <= т.конец && т.конец <= конец, Сема.вТкст(т.вид));
  }
  body
  {
    // Сканировать пробел.
    if (пбел(*у))
    {
      т.пп = у;
      while (пбел(*++у))
      {}
    }

    // Сканировать сему.
    бцел с = *у;
    {
      т.старт = у;
      // Новстр.
      switch (*у)
      {
      case '\r':
        if (у[1] == '\n')
          ++у;
      case '\n':
        assert(конецНовСтроки(у));
        ++у;
        ++номерСтроки;
        установиНачалоСтроки(у);
//         this.нс = &т;
        т.вид = ТОК.Новстр;
        т.установиФлагПробельные();
        т.нс.путиКФайлам = this.путиКФайлам;
        т.нс.ориНомСтр = номерСтроки;
        т.нс.устНомСтр = номСтр_хлайн;
        т.конец = у;
        return;
      default:
        if (новСтрЮ(у))
        {
          ++у; ++у;
          goto case '\n';
        }
      }
      // Идентификатор или текстовый литерал.
      if (начсим(с))
      {
        if (с == 'r' && у[1] == '"' && ++у)
          return сканируйСыройСтроковыйЛитерал(т);
        if (с == 'x' && у[1] == '"')
          return сканируйСтроковыйГексЛитерал(т);
      version(D2)
      {
        if (с == 'q' && у[1] == '"')
          return сканируйЛитералОграниченнойСтроки(т);
        if (с == 'q' && у[1] == '{')
          return сканируйСтроковыйЛитералСемы(т);
      }
        // Сканировать идентификатор.
      Lidentifier:
        do
        { с = *++у; }
        while (идент(с) || !аски(с) && юАльфа())

        т.конец = у;

        auto ид = ТаблицаИд.сыщи(т.исхТекст);
        т.вид = ид.вид;
        т.идент = ид;

        if (т.вид == ТОК.Идентификатор || т.кслово)
          return;
        else if (т.спецСема)
          закончиОсобуюСему(т);
        else if (т.вид == ТОК.КФ)
        {
          хвост = &т;
          assert(т.исхТекст == "__EOF__");
        }
        else
          assert(0, "неожидаемый тип семы: " ~ Сема.вТкст(т.вид));
        return;
      }

      if (цифра(с))
        return сканируйЧисло(т);

      if (с == '/')
      {
        с = *++у;
        switch(с)
        {
        case '=':
          ++у;
          т.вид = ТОК.ДелиПрисвой;
          т.конец = у;
          return;
        case '+':
          return сканируйГнездовойКомментарий(т);
        case '*':
          return сканируйБлочныйКомментарий(т);
        case '/':
          while (!конецСтроки(++у))
            аски(*у) || раскодируйЮ8();
          т.вид = ТОК.Комментарий;
          т.установиФлагПробельные();
          т.конец = у;
          return;
        default:
          т.вид = ТОК.Деление;
          т.конец = у;
          return;
        }
      }

      switch (с)
      {
      case '\'':
        return сканируйСимвольныйЛитерал(т);
      case '`':
        return сканируйСыройСтроковыйЛитерал(т);
      case '"':
        return сканируйНормальныйСтроковыйЛитерал(т);
      case '\\':
        ткст буфер;
        do
        {
          бул бинарен;
          с = сканируйИскейпПоследовательность(бинарен);
          if (аски(с) || бинарен)
            буфер ~= с;
          else
            кодируйВЮ8(буфер, с);
        } while (*у == '\\');
        буфер ~= 0;
        т.вид = ТОК.Ткст;
        т.ткт = буфер;
        т.конец = у;
        return;
      case '>': /* >  >=  >>  >>=  >>>  >>>= */
        с = *++у;
        switch (с)
        {
        case '=':
          т.вид = ТОК.БольшеРавно;
          goto Lcommon;
        case '>':
          if (у[1] == '>')
          {
            ++у;
            if (у[1] == '=')
            { ++у;
              т.вид = ТОК.БПСдвигПрисвой;
            }
            else
              т.вид = ТОК.БПСдвиг;
          }
          else if (у[1] == '=')
          {
            ++у;
            т.вид = ТОК.ПСдвигПрисвой;
          }
          else
            т.вид = ТОК.ПСдвиг;
          goto Lcommon;
        default:
          т.вид = ТОК.Больше;
          goto Lcommon2;
        }
        assert(0);
      case '<': /* <  <=  <>  <>=  <<  <<= */
        с = *++у;
        switch (с)
        {
        case '=':
          т.вид = ТОК.МеньшеРавно;
          goto Lcommon;
        case '<':
          if (у[1] == '=') {
            ++у;
            т.вид = ТОК.ЛСдвигПрисвой;
          }
          else
            т.вид = ТОК.ЛСдвиг;
          goto Lcommon;
        case '>':
          if (у[1] == '=') {
            ++у;
            т.вид = ТОК.МилиРилиБ;
          }
          else
            т.вид = ТОК.МилиБ;
          goto Lcommon;
        default:
          т.вид = ТОК.Меньше;
          goto Lcommon2;
        }
        assert(0);
      case '!': /* !  !<  !>  !<=  !>=  !<>  !<>= */
        с = *++у;
        switch (с)
        {
        case '<':
          с = *++у;
          if (с == '>')
          {
            if (у[1] == '=') {
              ++у;
              т.вид = ТОК.Неупорядоченный;
            }
            else
              т.вид = ТОК.НилиР;
          }
          else if (с == '=')
          {
            т.вид = ТОК.НилиБ;
          }
          else {
            т.вид = ТОК.НилиБилиР;
            goto Lcommon2;
          }
          goto Lcommon;
        case '>':
          if (у[1] == '=')
          {
            ++у;
            т.вид = ТОК.НилиМ;
          }
          else
            т.вид = ТОК.НилиМилиР;
          goto Lcommon;
        case '=':
          т.вид = ТОК.НеРавно;
          goto Lcommon;
        default:
          т.вид = ТОК.Не;
          goto Lcommon2;
        }
        assert(0);
      case '.': /* .  .[0-9]  ..  ... */
        if (у[1] == '.')
        {
          ++у;
          if (у[1] == '.') {
            ++у;
            т.вид = ТОК.Эллипсис;
          }
          else
            т.вид = ТОК.Срез;
        }
        else if (цифра(у[1]))
        {
          return сканируйРеал(т);
        }
        else
          т.вид = ТОК.Точка;
        goto Lcommon;
      case '|': /* |  ||  |= */
        с = *++у;
        if (с == '=')
          т.вид = ТОК.ИлиПрисвой;
        else if (с == '|')
          т.вид = ТОК.ИлиЛог;
        else {
          т.вид = ТОК.ИлиБинарное;
          goto Lcommon2;
        }
        goto Lcommon;
      case '&': /* &  &&  &= */
        с = *++у;
        if (с == '=')
          т.вид = ТОК.ИПрисвой;
        else if (с == '&')
          т.вид = ТОК.ИЛог;
        else {
          т.вид = ТОК.ИБинарное;
          goto Lcommon2;
        }
        goto Lcommon;
      case '+': /* +  ++  += */
        с = *++у;
        if (с == '=')
          т.вид = ТОК.ПрибавьПрисвой;
        else if (с == '+')
          т.вид = ТОК.ПлюсПлюс;
        else {
          т.вид = ТОК.Плюс;
          goto Lcommon2;
        }
        goto Lcommon;
      case '-': /* -  --  -= */
        с = *++у;
        if (с == '=')
          т.вид = ТОК.ОтнимиПрисвой;
        else if (с == '-')
          т.вид = ТОК.МинусМинус;
        else {
          т.вид = ТОК.Минус;
          goto Lcommon2;
        }
        goto Lcommon;
      case '=': /* =  == */
        if (у[1] == '=') {
          ++у;
          т.вид = ТОК.Равно;
        }
        else
          т.вид = ТОК.Присвоить;
        goto Lcommon;
      case '~': /* ~  ~= */
         if (у[1] == '=') {
           ++у;
           т.вид = ТОК.СоединиПрисвой;
         }
         else
           т.вид = ТОК.Тильда;
         goto Lcommon;
      case '*': /* *  *= */
         if (у[1] == '=') {
           ++у;
           т.вид = ТОК.УмножьПрисвой;
         }
         else
           т.вид = ТОК.Умножь;
         goto Lcommon;
      case '^': /* ^  ^= */
         if (у[1] == '=') {
           ++у;
           т.вид = ТОК.ИИлиПрисвой;
         }
         else
           т.вид = ТОК.ИИли;
         goto Lcommon;
      case '%': /* %  %= */
         if (у[1] == '=') {
           ++у;
           т.вид = ТОК.МодульПрисвой;
         }
         else
           т.вид = ТОК.Модуль;
         goto Lcommon;
      // Single символ семы:
      case '(':
        т.вид = ТОК.ЛСкобка;
        goto Lcommon;
      case ')':
        т.вид = ТОК.ПСкобка;
        goto Lcommon;
      case '[':
        т.вид = ТОК.ЛКвСкобка;
        goto Lcommon;
      case ']':
        т.вид = ТОК.ПКвСкобка;
        goto Lcommon;
      case '{':
        т.вид = ТОК.ЛФСкобка;
        goto Lcommon;
      case '}':
        т.вид = ТОК.ПФСкобка;
        goto Lcommon;
      case ':':
        т.вид = ТОК.Двоеточие;
        goto Lcommon;
      case ';':
        т.вид = ТОК.ТочкаЗапятая;
        goto Lcommon;
      case '?':
        т.вид = ТОК.Вопрос;
        goto Lcommon;
      case ',':
        т.вид = ТОК.Запятая;
        goto Lcommon;
      case '$':
        т.вид = ТОК.Доллар;
      Lcommon:
        ++у;
      Lcommon2:
        т.конец = у;
        return;
      case '#':
        return сканируйОсобуйПоследовательностьСем(т);
      default:
      }

      // Проверим на КФ
      if (кф(с))
      {
        assert(кф(*у), ""~*у);
        т.вид = ТОК.КФ;
        т.конец = у;
        хвост = &т;
        assert(т.старт == т.конец);
        return;
      }

      if (!аски(с))
      {
        с = раскодируйЮ8();
        if (униАльфа(с))
          goto Lidentifier;
      }

      ошибка(т.старт, ИДС.НедопустимыйСимвол, cast(дим)с);

      ++у;
      т.вид = ТОК.Нелегал;
      т.установиФлагПробельные();
      т.дим_ = с;
      т.конец = у;
      return;
    }
  }

  /// Преобразует текстовый литерал в целое.
  template вБцел(ткст T)
  {
    static assert(0 < T.length && T.length <= 4);
    static if (T.length == 1)
      const бцел вБцел = T[0];
    else
      const бцел вБцел = (T[0] << ((T.length-1)*8)) | вБцел!(T[1..$]);
  }
  static assert(вБцел!("\xAA\xBB\xCC\xDD") == 0xAABBCCDD);

  /// Конструирует case инструкции. Напр.:
  /// ---
  //// // случай_!("<", "Меньше", "Lcommon") ->
  /// case 60u:
  ///   т.вид = ТОК.Меньше;
  ///   goto Lcommon;
  /// ---
  /// FIXME: Пока нельзя использовать из-за $(DMDBUG 1534, bug) в DMD.
  template случай_(ткст ткт, ткст вид, ткст лейбл)
  {
    const ткст случай_ =
      `case `~вБцел!(ткт).stringof~`:`
        `т.вид = ТОК.`~вид~`;`
        `goto `~лейбл~`;`;
  }
  //pragma(сооб, случай_!("<", "Меньше", "Lcommon"));

  template случай_Л4(ткст ткт, ТОК вид)
  {
    const ткст случай_Л4 = случай_!(ткт, вид, "Lcommon_4");
  }

  template случай_Л3(ткст ткт, ТОК вид)
  {
    const ткст случай_Л3 = случай_!(ткт, вид, "Lcommon_3");
  }

  template случай_Л2(ткст ткт, ТОК вид)
  {
    const ткст случай_Л2 = случай_!(ткт, вид, "Lcommon_2");
  }

  template случай_Л1(ткст ткт, ТОК вид)
  {
    const ткст случай_Л3 = случай_!(ткт, вид, "Lcommon");
  }

  /// Альтернативный метод сканирования.
  /// Профилирование показывает, что он несколько медлительнее.
  public проц  сканируй_(ref Сема т)
  in
  {
    assert(текст.ptr <= у && у < конец);
  }
  out
  {
    assert(текст.ptr <= т.старт && т.старт < конец, Сема.вТкст(т.вид));
    assert(текст.ptr <= т.конец && т.конец <= конец, Сема.вТкст(т.вид));
  }
  body
  {
    //Сканировать пробел.
    if (пбел(*у))
    {
      т.пп = у;
      while (пбел(*++у))
      {}
    }

    // Сканировать сему.
    т.старт = у;
    // Новстр.
    switch (*у)
    {
    case '\r':
      if (у[1] == '\n')
        ++у;
    case '\n':
      assert(конецНовСтроки(у));
      ++у;
      ++номерСтроки;
      установиНачалоСтроки(у);
//       this.нс = &т;
      т.вид = ТОК.Новстр;
      т.установиФлагПробельные();
      т.нс.путиКФайлам = this.путиКФайлам;
      т.нс.ориНомСтр = номерСтроки;
      т.нс.устНомСтр = номСтр_хлайн;
      т.конец = у;
      return;
    default:
      if (новСтрЮ(у))
      {
        ++у; ++у;
        goto case '\n';
      }
    }

    бцел с = *у;
    assert(конец - у != 0);
    switch (конец - у)
    {
    case 1:
      goto L1character;
    case 2:
      с <<= 8; с |= у[1];
      goto L2characters;
    case 3:
      с <<= 8; с |= у[1]; с <<= 8; с |= у[2];
      goto L3characters;
    default:
      version(BigEndian)
        с = *cast(бцел*)у;
      else
      {
        с <<= 8; с |= у[1]; с <<= 8; с |= у[2]; с <<= 8; с |= у[3];
        /+
        с = *cast(бцел*)у;
        asm
        {
          mov EDX, с;
          bswap EDX;
          mov с, EDX;
        }
        +/
      }
    }

    // 4 символ семы.
    switch (с)
    {
    case вБцел!(">>>="):
      т.вид = ТОК.ПСдвигПрисвой;
      goto Lcommon_4;
    case вБцел!("!<>="):
      т.вид = ТОК.Неупорядоченный;
    Lcommon_4:
      у += 4;
      т.конец = у;
      return;
    default:
    }

    с >>>= 8;
  L3characters:
    assert(у == т.старт);
    // 3 символ семы.
    switch (с)
    {
    case вБцел!(">>="):
      т.вид = ТОК.ПСдвигПрисвой;
      goto Lcommon_3;
    case вБцел!(">>>"):
      т.вид = ТОК.БПСдвиг;
      goto Lcommon_3;
    case вБцел!("<>="):
      т.вид = ТОК.МилиРилиБ;
      goto Lcommon_3;
    case вБцел!("<<="):
      т.вид = ТОК.ЛСдвигПрисвой;
      goto Lcommon_3;
    case вБцел!("!<="):
      т.вид = ТОК.НилиБ;
      goto Lcommon_3;
    case вБцел!("!>="):
      т.вид = ТОК.НилиМ;
      goto Lcommon_3;
    case вБцел!("!<>"):
      т.вид = ТОК.НилиР;
      goto Lcommon_3;
    case вБцел!("..."):
      т.вид = ТОК.Эллипсис;
    Lcommon_3:
      у += 3;
      т.конец = у;
      return;
    default:
    }

    с >>>= 8;
  L2characters:
    assert(у == т.старт);
    // 2 символ семы.
    switch (с)
    {
    case вБцел!("/+"):
      ++у; // Пропустим /
      return сканируйГнездовойКомментарий(т);
    case вБцел!("/*"):
      ++у; // Пропустим /
      return сканируйБлочныйКомментарий(т);
    case вБцел!("//"):
      ++у; // Пропустим /
      assert(*у == '/');
      while (!конецСтроки(++у))
        аски(*у) || раскодируйЮ8();
      т.вид = ТОК.Комментарий;
      т.установиФлагПробельные();
      т.конец = у;
      return;
    case вБцел!(">="):
      т.вид = ТОК.БольшеРавно;
      goto Lcommon_2;
    case вБцел!(">>"):
      т.вид = ТОК.ПСдвиг;
      goto Lcommon_2;
    case вБцел!("<<"):
      т.вид = ТОК.ЛСдвиг;
      goto Lcommon_2;
    case вБцел!("<="):
      т.вид = ТОК.МеньшеРавно;
      goto Lcommon_2;
    case вБцел!("<>"):
      т.вид = ТОК.МилиБ;
      goto Lcommon_2;
    case вБцел!("!<"):
      т.вид = ТОК.НилиБилиР;
      goto Lcommon_2;
    case вБцел!("!>"):
      т.вид = ТОК.НилиМилиР;
      goto Lcommon_2;
    case вБцел!("!="):
      т.вид = ТОК.НеРавно;
      goto Lcommon_2;
    case вБцел!(".."):
      т.вид = ТОК.Срез;
      goto Lcommon_2;
    case вБцел!("&&"):
      т.вид = ТОК.ИЛог;
      goto Lcommon_2;
    case вБцел!("&="):
      т.вид = ТОК.ИПрисвой;
      goto Lcommon_2;
    case вБцел!("||"):
      т.вид = ТОК.ИлиЛог;
      goto Lcommon_2;
    case вБцел!("|="):
      т.вид = ТОК.ИлиПрисвой;
      goto Lcommon_2;
    case вБцел!("++"):
      т.вид = ТОК.ПлюсПлюс;
      goto Lcommon_2;
    case вБцел!("+="):
      т.вид = ТОК.ПрибавьПрисвой;
      goto Lcommon_2;
    case вБцел!("--"):
      т.вид = ТОК.МинусМинус;
      goto Lcommon_2;
    case вБцел!("-="):
      т.вид = ТОК.ОтнимиПрисвой;
      goto Lcommon_2;
    case вБцел!("=="):
      т.вид = ТОК.Равно;
      goto Lcommon_2;
    case вБцел!("~="):
      т.вид = ТОК.СоединиПрисвой;
      goto Lcommon_2;
    case вБцел!("*="):
      т.вид = ТОК.УмножьПрисвой;
      goto Lcommon_2;
    case вБцел!("/="):
      т.вид = ТОК.ДелиПрисвой;
      goto Lcommon_2;
    case вБцел!("^="):
      т.вид = ТОК.ИИлиПрисвой;
      goto Lcommon_2;
    case вБцел!("%="):
      т.вид = ТОК.МодульПрисвой;
    Lcommon_2:
      у += 2;
      т.конец = у;
      return;
    default:
    }

    с >>>= 8;
  L1character:
    assert(у == т.старт);
    assert(*у == с, Формат("у={0},с={1}", *у, cast(дим)с));
    // 1 символ семы.
    // TODO: рассмотреть сохранение типа семы в таблук.
    switch (с)
    {
    case '\'':
      return сканируйСимвольныйЛитерал(т);
    case '`':
      return сканируйСыройСтроковыйЛитерал(т);
    case '"':
      return сканируйНормальныйСтроковыйЛитерал(т);
    case '\\':
      ткст буфер;
      do
      {
        бул бинарен;
        с = сканируйИскейпПоследовательность(бинарен);
        if (аски(с) || бинарен)
          буфер ~= с;
        else
          кодируйВЮ8(буфер, с);
      } while (*у == '\\');
      буфер ~= 0;
      т.вид = ТОК.Ткст;
      т.ткт = буфер;
      т.конец = у;
      return;
    case '<':
      т.вид = ТОК.Больше;
      goto Lcommon;
    case '>':
      т.вид = ТОК.Меньше;
      goto Lcommon;
    case '^':
      т.вид = ТОК.ИИли;
      goto Lcommon;
    case '!':
      т.вид = ТОК.Не;
      goto Lcommon;
    case '.':
      if (цифра(у[1]))
        return сканируйРеал(т);
      т.вид = ТОК.Точка;
      goto Lcommon;
    case '&':
      т.вид = ТОК.ИБинарное;
      goto Lcommon;
    case '|':
      т.вид = ТОК.ИлиБинарное;
      goto Lcommon;
    case '+':
      т.вид = ТОК.Плюс;
      goto Lcommon;
    case '-':
      т.вид = ТОК.Минус;
      goto Lcommon;
    case '=':
      т.вид = ТОК.Присвоить;
      goto Lcommon;
    case '~':
      т.вид = ТОК.Тильда;
      goto Lcommon;
    case '*':
      т.вид = ТОК.Умножь;
      goto Lcommon;
    case '/':
      т.вид = ТОК.Деление;
      goto Lcommon;
    case '%':
      т.вид = ТОК.Модуль;
      goto Lcommon;
    case '(':
      т.вид = ТОК.ЛСкобка;
      goto Lcommon;
    case ')':
      т.вид = ТОК.ПСкобка;
      goto Lcommon;
    case '[':
      т.вид = ТОК.ЛКвСкобка;
      goto Lcommon;
    case ']':
      т.вид = ТОК.ПКвСкобка;
      goto Lcommon;
    case '{':
      т.вид = ТОК.ЛФСкобка;
      goto Lcommon;
    case '}':
      т.вид = ТОК.ПФСкобка;
      goto Lcommon;
    case ':':
      т.вид = ТОК.Двоеточие;
      goto Lcommon;
    case ';':
      т.вид = ТОК.ТочкаЗапятая;
      goto Lcommon;
    case '?':
      т.вид = ТОК.Вопрос;
      goto Lcommon;
    case ',':
      т.вид = ТОК.Запятая;
      goto Lcommon;
    case '$':
      т.вид = ТОК.Доллар;
    Lcommon:
      ++у;
      т.конец = у;
      return;
    case '#':
      return сканируйОсобуйПоследовательностьСем(т);
    default:
    }

    assert(у == т.старт);
    assert(*у == с);

    // TODO: следует переместить начсим() и цифра() выше.
    if (начсим(с))
    {
      if (с == 'r' && у[1] == '"' && ++у)
        return сканируйСыройСтроковыйЛитерал(т);
      if (с == 'x' && у[1] == '"')
        return сканируйСтроковыйГексЛитерал(т);
    version(D2)
    {
      if (с == 'q' && у[1] == '"')
        return сканируйЛитералОграниченнойСтроки(т);
      if (с == 'q' && у[1] == '{')
        return сканируйСтроковыйЛитералСемы(т);
    }
      // Сканируем идентификатор.
    Lidentifier:
      do
      { с = *++у; }
      while (идент(с) || !аски(с) && юАльфа()); //ВК !!!! опять тчкзпт

      т.конец = у;

      auto ид = ТаблицаИд.сыщи(т.исхТекст);
      т.вид = ид.вид;
      т.идент = ид;

      if (т.вид == ТОК.Идентификатор || т.кслово)
        return;
      else if (т.спецСема)
        закончиОсобуюСему(т);
      else if (т.вид == ТОК.КФ)
      {
        хвост = &т;
        assert(т.исхТекст == "__EOF__");
      }
      else
        assert(0, "неожиданный тип семы: " ~ Сема.вТкст(т.вид));
      return;
    }

    if (цифра(с))
      return сканируйЧисло(т);

    // Проверка на КФ
    if (кф(с))
    {
      assert(кф(*у), *у~"");
      т.вид = ТОК.КФ;
      т.конец = у;
      хвост = &т;
      assert(т.старт == т.конец);
      return;
    }

    if (!аски(с))
    {
      с = раскодируйЮ8();
      if (униАльфа(с))
        goto Lidentifier;
    }

    ошибка(т.старт, ИДС.НедопустимыйСимвол, cast(дим)с);

    ++у;
    т.вид = ТОК.Нелегал;
    т.установиФлагПробельные();
    т.дим_ = с;
    т.конец = у;
    return;
  }

  /// Сканирует блочный комментарий.
  ///
  /// БлочнКоммент := "/*" ЛюбойСим* "*/"
  проц  сканируйБлочныйКомментарий(ref Сема т)
  {
    assert(у[-1] == '/' && *у == '*');
    auto номСтрСемы = номерСтроки;
    auto началоСтрСемы = началоСтроки;
  Loop:
    while (1)
    {
      switch (*++у)
      {
      case '*':
        if (у[1] != '/')
          continue;
        у += 2;
        break Loop;
      case '\r':
        if (у[1] == '\n')
          ++у;
      case '\n':
        assert(конецНовСтроки(у));
        ++номерСтроки;
        установиНачалоСтроки(у+1);
        break;
      default:
        if (!аски(*у))
        {
          if (симНовСтрЮ(раскодируйЮ8()))
            goto case '\n';
        }
        else if (кф(*у))
        {
          ошибка(номСтрСемы, началоСтрСемы, т.старт, ИДС.НезавершённыйБлочныйКомментарий);
          break Loop;
        }
      }
    }
    т.вид = ТОК.Комментарий;
    т.установиФлагПробельные();
    т.конец = у;
    return;
  }

  /// Сканирует гнездовой комментарий.
  ///
  /// ГнездКоммент := "/+" (ЛюбойСим* | ГнездКоммент) "+/"
  проц  сканируйГнездовойКомментарий(ref Сема т)
  {
    assert(у[-1] == '/' && *у == '+');
    auto номСтрСемы = номерСтроки;
    auto началоСтрСемы = началоСтроки;
    бцел уровень = 1;
  Loop:
    while (1)
    {
      switch (*++у)
      {
      case '/':
        if (у[1] == '+')
          ++у, ++уровень;
        continue;
      case '+':
        if (у[1] != '/')
          continue;
        ++у;
        if (--уровень != 0)
          continue;
        ++у;
        break Loop;
      case '\r':
        if (у[1] == '\n')
          ++у;
      case '\n':
        assert(конецНовСтроки(у));
        ++номерСтроки;
        установиНачалоСтроки(у+1);
        continue;
      default:
        if (!аски(*у))
        {
          if (симНовСтрЮ(раскодируйЮ8()))
            goto case '\n';
        }
        else if (кф(*у))
        {
          ошибка(номСтрСемы, началоСтрСемы, т.старт, ИДС.НезавершённыйГнездовойКомментарий);
          break Loop;
        }
      }
    }
    т.вид = ТОК.Комментарий;
    т.установиФлагПробельные();
    т.конец = у;
    return;
  }

  /// Сканирует постфиксный символ текстового литерала.
  ///
  /// ПостфиксСим := "с" | "w" | "d"
  сим сканируйПостфикс()
  {
    assert(у[-1] == '"' || у[-1] == '`' ||
      { version(D2) return у[-1] == '}';
               else return 0; }()
    );
    switch (*у)
    {
    case 'c':
    case 'w':
    case 'd':
      return *у++;
    default:
      return 0;
    }
    assert(0);
  }

  /// Сканрует нормальный текстовый литерал.
  ///
  /// НормТекстЛитерал := "\"" Сим* "\""
  проц  сканируйНормальныйСтроковыйЛитерал(ref Сема т)
  {
    assert(*у == '"');
    auto номСтрСемы = номерСтроки;
    auto началоСтрСемы = началоСтроки;
    т.вид = ТОК.Ткст;
    ткст буфер;
    бцел с;
    while (1)
    {
      с = *++у;
      switch (с)
      {
      case '"':
        ++у;
        т.pf = сканируйПостфикс();
      Lreturn:
        т.ткт = буфер ~ '\0';
        т.конец = у;
        return;
      case '\\':
        бул бинарен;
        с = сканируйИскейпПоследовательность(бинарен);
        --у;
        if (аски(с) || бинарен)
          буфер ~= с;
        else
          кодируйВЮ8(буфер, с);
        continue;
      case '\r':
        if (у[1] == '\n')
          ++у;
      case '\n':
        assert(конецНовСтроки(у));
        с = '\n'; // Преобразует Новстр в \n.
        ++номерСтроки;
        установиНачалоСтроки(у+1);
        break;
      case 0, _Z_:
        ошибка(номСтрСемы, началоСтрСемы, т.старт, ИДС.НеоконченыйТкст);
        goto Lreturn;
      default:
        if (!аски(с))
        {
          с = раскодируйЮ8();
          if (симНовСтрЮ(с))
            goto case '\n';
          кодируйВЮ8(буфер, с);
          continue;
        }
      }
      assert(аски(с));
      буфер ~= с;
    }
    assert(0);
  }

  /// Сканирует символьный литерал.
  ///
  /// СимЛитерал := "'" Сим "'"
  проц  сканируйСимвольныйЛитерал(ref Сема т)
  {
    assert(*у == '\'');
    ++у;
    т.вид = ТОК.СимЛитерал;
    switch (*у)
    {
    case '\\':
      бул notused;
      т.дим_ = сканируйИскейпПоследовательность(notused);
      break;
    case '\'':
      ошибка(т.старт, ИДС.ПустойСимвольныйЛитерал);
      break;
    default:
      if (конецСтроки(у))
        break;
      бцел с = *у;
      if (!аски(с))
        с = раскодируйЮ8();
      т.дим_ = с;
      ++у;
    }

    if (*у == '\'')
      ++у;
    else
      ошибка(т.старт, ИДС.НеоконченныйСимвольныйЛитерал);
    т.конец = у;
  }

  /// Сканирует сырой строковый литерал.
  ///
  /// СырТекстЛитерал := "r\"" ЛюбойСим* "\"" | "`" ЛюбойСим* "`"
  проц  сканируйСыройСтроковыйЛитерал(ref Сема т)
  {
    assert(*у == '`' || *у == '"' && у[-1] == 'r');
    auto номСтрСемы = номерСтроки;
    auto началоСтрСемы = началоСтроки;
    т.вид = ТОК.Ткст;
    бцел делим = *у;
    ткст буфер;
    бцел с;
    while (1)
    {
      с = *++у;
      switch (с)
      {
      case '\r':
        if (у[1] == '\n')
          ++у;
      case '\n':
        assert(конецНовСтроки(у));
        с = '\n'; // Преобразовать Новстр в '\n'.
        ++номерСтроки;
        установиНачалоСтроки(у+1);
        break;
      case '`':
      case '"':
        if (с == делим)
        {
          ++у;
          т.pf = сканируйПостфикс();
        Lreturn:
          т.ткт = буфер ~ '\0';
          т.конец = у;
          return;
        }
        break;
      case 0, _Z_:
        ошибка(номСтрСемы, началоСтрСемы, т.старт,
          делим == 'r' ? ИДС.НеоконченнаяСыраяСтрока : ИДС.НезавершённаяСтрокаСОбратнымиКавычками);
        goto Lreturn;
      default:
        if (!аски(с))
        {
          с = раскодируйЮ8();
          if (симНовСтрЮ(с))
            goto case '\n';
          кодируйВЮ8(буфер, с);
          continue;
        }
      }
      assert(аски(с));
      буфер ~= с;
    }
    assert(0);
  }

  /// Сканирует 16-ричный строковый литерал.
  ///
  /// ГексТекстЛитерал := "x\"" (ГексСим ГексСим)* "\""
  проц  сканируйСтроковыйГексЛитерал(ref Сема т)
  {
    assert(у[0] == 'x' && у[1] == '"');
    т.вид = ТОК.Ткст;

    auto номСтрСемы = номерСтроки;
    auto началоСтрСемы = началоСтроки;

    бцел с;
    ббайт[] буфер;
    ббайт h; // 16-ричное число
    бцел n; // число 16-ричных цифр

    ++у;
    assert(*у == '"');
    while (1)
    {
      с = *++у;
      switch (с)
      {
      case '"':
        if (n & 1)
          ошибка(номСтрСемы, началоСтрСемы, т.старт, ИДС.НечётноеЧислоЦифрВГексСтроке);
        ++у;
        т.pf = сканируйПостфикс();
      Lreturn:
        т.ткт = cast(ткст) (буфер ~= 0);
        т.конец = у;
        return;
      case '\r':
        if (у[1] == '\n')
          ++у;
      case '\n':
        assert(конецНовСтроки(у));
        ++номерСтроки;
        установиНачалоСтроки(у+1);
        continue;
      default:
        if (гекс(с))
        {
          if (с <= '9')
            с -= '0';
          else if (с <= 'ф')
            с -= 'A' - 10;
          else
            с -= 'a' - 10;

          if (n & 1)
          {
            h <<= 4;
            h |= с;
            буфер ~= h;
          }
          else
            h = cast(ббайт)с;
          ++n;
          continue;
        }
        else if (пбел(с))
          continue; // Пропуск пробелов.
        else if (кф(с))
        {
          ошибка(номСтрСемы, началоСтрСемы, т.старт, ИДС.НеоконченнаяГексСтрока);
          т.pf = 0;
          goto Lreturn;
        }
        else
        {
          auto ошибкаНа = у;
          if (!аски(с))
          {
            с = раскодируйЮ8();
            if (симНовСтрЮ(с))
              goto case '\n';
          }
          ошибка(ошибкаНа, ИДС.НеГексСимВГексСтроке, cast(дим)с);
        }
      }
    }
    assert(0);
  }

version(DDoc)
{
  /// Сканирует ограниченный строковый литерал.
  проц  сканируйЛитералОграниченнойСтроки(ref Сема т);
  /// Сканирует семовый строковый литерал.
  ///
  /// СемаТекстЛитерал := "q{" Сема* "}"
  проц  сканируйСтроковыйЛитералСемы(ref Сема т);
}
else
version(D2)
{
  проц  сканируйЛитералОграниченнойСтроки(ref Сема т)
  {
    assert(у[0] == 'q' && у[1] == '"');
    т.вид = ТОК.Ткст;

    auto номСтрСемы = номерСтроки;
    auto началоСтрСемы = началоСтроки;

    ткст буфер;
    дим открывающий_делим = 0, // 0 , если нет гнездового ограничителя или '[', '(', '<', '{'
          закрывающий_делим; // будет ']', ')', '>', '},
                         // первый символ идентификатора или
                         // любой другой Юникод/ASCII символ.
    ткст ткт_делим; // Ограничитель идентификатора.
    бцел уровень = 1; // Счётчик гнездовых ограничителей.

    ++у; ++у; // Пропустить q"
    бцел с = *у;
    switch (с)
    {
    case '(':
      открывающий_делим = с;
      закрывающий_делим = ')'; // с + 1
      break;
    case '[', '<', '{':
      открывающий_делим = с;
      закрывающий_делим = с + 2; // Получить в закрывающий оппонент. Элемент ASCII таблицы.
      break;
    default:
      дим сканируйНовСтр()
      {
        switch (*у)
        {
        case '\r':
          if (у[1] == '\n')
            ++у;
        case '\n':
          assert(конецНовСтроки(у));
          ++у;
          ++номерСтроки;
          установиНачалоСтроки(у);
          break;
        default:
          if (новСтрЮ(у)) {
            у += 2;
            goto case '\n';
          }
          return нет;
        }
        return да;
      }
      // Пропустить вводные новстроки:
      while (сканируйНовСтр())
      {}
      assert(!новСтр(у));

      ткст0 начало = у;
      с = *у;
      закрывающий_делим = с;
      // TODO: Проверять непечатные символы?
      if (!аски(с))
      {
        закрывающий_делим = раскодируйЮ8();
        if (!униАльфа(закрывающий_делим))
          break; // Не идентификатор.
      }
      else if (!начсим(с))
        break; // Не идентификатор.

      // Разобрать Идентификатор + КонецСтроки
      do
      { с = *++у; }
      while (идент(с) || !аски(с) && юАльфа());
      // Сохранить идентификатор
      ткт_делим = начало[0..у-начало];
      // Сканировать нс
      if (сканируйНовСтр())
        --у; //Вернуться к предыдущему из-за "с = *++у;" в главном цикле.
      else
      {
        // TODO: ошибка(у, ИДС.ОжидаласьНовСтрПослеОграничителяИдента);
      }
    }

    бул проверьРазгрСтр(ткст0 у)
    {
      assert(ткт_делим.length != 0);
      if (буфер[$-1] == '\n' && // Последним скопированным в буфер символом д.б. '\n'.
          конец-у >= ткт_делим.length && // Проверить остаток длины.
          у[0..ткт_делим.length] == ткт_делим) // Сравнить.
        return да;
      return нет;
    }

    while (1)
    {
      с = *++у;
      switch (с)
      {
      case '\r':
        if (у[1] == '\n')
          ++у;
      case '\n':
        assert(конецНовСтроки(у));
        с = '\n'; // Преобразовать Новстр в '\n'.
        ++номерСтроки;
        установиНачалоСтроки(у+1);
        break;
      case 0, _Z_:
        // TODO: ошибка(номСтрСемы, началоСтрСемы, т.старт, ИДС.НеоконченныйРазграниченныйТкст);
        goto Lreturn3;
      default:
        if (!аски(с))
        {
          auto начало = у;
          с = раскодируйЮ8();
          if (симНовСтрЮ(с))
            goto case '\n';
          if (с == закрывающий_делим)
          {
            if (ткт_делим.length)
            {
              if (проверьРазгрСтр(начало))
              {
                у = начало + ткт_делим.length;
                goto Lreturn2;
              }
            }
            else
            {
              assert(уровень == 1);
              --уровень;
              goto Lreturn;
            }
          }
          кодируйВЮ8(буфер, с);
          continue;
        }
        else
        {
          if (с == открывающий_делим)
            ++уровень;
          else if (с == закрывающий_делим)
          {
            if (ткт_делим.length)
            {
              if (проверьРазгрСтр(у))
              {
                у += ткт_делим.length;
                goto Lreturn2;
              }
            }
            else if (--уровень == 0)
              goto Lreturn;
          }
        }
      }
      assert(аски(с));
      буфер ~= с;
    }
  Lreturn: // Ограничитель символа.
    assert(с == закрывающий_делим);
    assert(уровень == 0);
    ++у; // Пропустить закрывающий ограничитель.
  Lreturn2: // Ткст ограничитель.
    if (*у == '"')
      ++у;
    else
    {
      // TODO: ошибка(у, ИДС.ОжилаласьДвойнКавычкаПослеОграничителя, ткт_делим.length ? ткт_делим : закрывающий_делим~"");
    }

    т.pf = сканируйПостфикс();
  Lreturn3: // Ошибка.
    т.ткт = буфер ~ '\0';
    т.конец = у;
  }

  проц  сканируйСтроковыйЛитералСемы(ref Сема т)
  {
    assert(у[0] == 'q' && у[1] == '{');
    т.вид = ТОК.Ткст;

    auto номСтрСемы = номерСтроки;
    auto началоСтрСемы = началоСтроки;

    // Оберегает от изменений в отдельных членах:
    // this.номСтр_хлайн и this.ошибПуть
    ++вСемТкст;

    бцел номерСтроки = this.номерСтроки;
    бцел уровень = 1;

    ++у; ++у; // Пропустить q{

    auto предш_t = &т;
    Сема* сема;
    while (1)
    {
      сема = new Сема;
      сканируй(*сема);
      // Сохранить семы в дважды линкованном списке.
      // Может пригодиться для различных инструментов.
      сема.предш = предш_t;
      предш_t.следщ = сема;
      предш_t = сема;
      switch (сема.вид)
      {
      case ТОК.ЛФСкобка:
        ++уровень;
        continue;
      case ТОК.ПФСкобка:
        if (--уровень == 0)
        {
          т.ткт_семы = т.следщ;
          т.следщ = пусто;
          break;
        }
        continue;
      case ТОК.КФ:
        // TODO: ошибка(номСтрСемы, началоСтрСемы, т.старт, ИДС.НеоконченныйСемТкст);
        т.ткт_семы = т.следщ;
        т.следщ = сема;
        break;
      default:
        continue;
      }
      break; // Exit loop.
    }

    assert(сема.вид == ТОК.ПФСкобка || сема.вид == ТОК.КФ);
    assert(сема.вид == ТОК.ПФСкобка && т.следщ is пусто ||
           сема.вид == ТОК.КФ && т.следщ !is пусто);

    ткст буфер;
    // сема указывает на } или КФ
    if (сема.вид == ТОК.КФ)
    {
      т.конец = сема.старт;
      буфер = т.исхТекст[2..$].dup ~ '\0';
    }
    else
    {
      // Присвоить в буфер перед сканируйПостфикс().
      т.конец = у;
      буфер = т.исхТекст[2..$-1].dup ~ '\0';
      т.pf = сканируйПостфикс();
      т.конец = у; // Присвоить again because of postfix.
    }
    // Преобразовать новстры в '\n'.
    if (номерСтроки != this.номерСтроки)
    {
      assert(буфер[$-1] == '\0');
      бцел i, j;
      for (; i < буфер.length; ++i)
        switch (буфер[i])
        {
        case '\r':
          if (буфер[i+1] == '\n')
            ++i;
        case '\n':
          assert(конецНовСтроки(буфер.ptr + i));
          буфер[j++] = '\n'; // Преобразовать Новстр в '\n'.
          break;
        default:
          if (новСтрЮ(буфер.ptr + i))
          {
            ++i; ++i;
            goto case '\n';
          }
          буфер[j++] = буфер[i]; // Copy.
        }
      буфер.length = j; // Настроить длину.
    }
    assert(буфер[$-1] == '\0');
    т.ткт = буфер;

    --вСемТкст;
  }
} // version(D2)

  /// Сканирует искейп-последовательность.
  ///
  /// ИскейпПоследовательность := "\" (Восмиричный{1,3} | ("x" Гекс{2}) |
  ///                       ("u" Гекс{4}) | ("U" Гекс{8}) |
  ///                       "'" | "\"" | "\\" | "?" | "a" |
  ///                       "b" | "f" | "n" | "r" | "т" | "v")
  /// Параметры:
  ///   бинарен = установлен в да для 8- и 16-ричных искейпов.
  /// Возвращает: искейп значение.
  дим сканируйИскейпПоследовательность(ref бул бинарен)
  out(результат)
  { assert(верноСимвол(результат)); }
  body
  {
    assert(*у == '\\');

    auto началоПоследовательности = у; // Используется для отчёте об ошибке.

    ++у;
    бцел с = сим8еск(*у);
    if (с)
    {
      ++у;
      return с;
    }

    бцел цифры = 2;

    switch (*у)
    {
    case 'x':
      бинарен = да;
    case_Юникод:
      assert(с == 0);
      assert(цифры == 2 || цифры == 4 || цифры == 8);
      while (1)
      {
        ++у;
        if (гекс(*у))
        {
          с *= 16;
          if (*у <= '9')
            с += *у - '0';
          else if (*у <= 'F')
            с += *у - 'A' + 10;
          else
            с += *у - 'a' + 10;

          if (--цифры == 0)
          {
            ++у;
            if (верноСимвол(с))
              return с; // Итоговое валидное искейп-значение.

            ошибка(началоПоследовательности, ИДС.НевернаяИскейпПоследовательностьЮникод,
                  началоПоследовательности[0..у-началоПоследовательности]);
            break;
          }
          continue;
        }

        ошибка(началоПоследовательности, ИДС.НедостатокГексЦифр,
              началоПоследовательности[0..у-началоПоследовательности]);
        break;
      }
      break;
    case 'u':
      цифры = 4;
      goto case_Юникод;
    case 'U':
      цифры = 8;
      goto case_Юникод;
    default:
      if (восмир(*у))
      {
        бинарен = да;
        assert(с == 0);
        с += *у - '0';
        ++у;
        if (!восмир(*у))
          return с;
        с *= 8;
        с += *у - '0';
        ++у;
        if (!восмир(*у))
          return с;
        с *= 8;
        с += *у - '0';
        ++у;
        if (с > 0xFF)
          ошибка(началоПоследовательности, сооб.НевернаяВосмеричнаяИскейпПоследовательность,
                началоПоследовательности[0..у-началоПоследовательности]);
        return с; //  Итоговое валидное искейп-значение.
      }
      else if(*у == '&')
      {
        if (буква(*++у))
        {
          auto начало = у;
          while (цифробукв(*++у))
          {}

          if (*у == ';')
          {
            // Передать сущность, исключая '&' и ';'.
            с = сущностьВЮникод(начало[0..у - начало]);
            ++у; // Пропустим ;
            if (с != 0xFFFF)
              return с; //  Итоговое валидное искейп-значение.
            else
              ошибка(началоПоследовательности, ИДС.НеопределённаяСущностьГТЯР, началоПоследовательности[0 .. у - началоПоследовательности]);
          }
          else
            ошибка(началоПоследовательности, ИДС.НеоконченнаяСущностьГТЯР, началоПоследовательности[0 .. у - началоПоследовательности]);
        }
        else
          ошибка(началоПоследовательности, ИДС.НеверноеНачалоСущностиГТЯР);
      }
      else if (конецСтроки(у))
        ошибка(началоПоследовательности, ИДС.НеопределённаяИскейпПоследовательность,
          кф(*у) ? `\КФ` : `\НовСтр`);
      else
      {
        ткст ткт = `\`;
        if (аски(с))
          ткт ~= *у;
        else
          кодируйВЮ8(ткт, раскодируйЮ8());
        ++у;
        // TODO: выполнить проверку на непечатный символ?
        ошибка(началоПоследовательности, ИДС.НеопределённаяИскейпПоследовательность, ткт);
      }
    }
    return СИМ_ЗАМЕНЫ; // Ошибка: вернём суррогатный символ.
  }

  /// Сканирует числовой литерал.
  ///
  /// $(PRE
  /// ЦелыйЛитерал := (Дес|Гекс|Бин|Восьм)Суффикс?
  /// Дес := (0|[1-9][0-9_]*)
  /// Гекс := 0[xX][_]*[0-9a-zA-Z][0-9a-zA-Z_]*
  /// Бин := 0[bB][_]*[01][01_]*
  /// Восьм := 0[0-7_]*
  /// Суффикс := (L[uU]?|[uU]L?)
  /// )
  /// Неверно: "0b_", "0x_", "._" и т.д.
  проц  сканируйЧисло(ref Сема т)
  {
    бдол бдол_;
    бул переполнение;
    бул десятичен;
    т_мера цифры;

    if (*у != '0')
      goto LscanInteger;
    ++у; // пропустим ноль
    // check for xX bB ...
    switch (*у)
    {
    case 'x','X':
      goto LscanHex;
    case 'b','B':
      goto LscanBinary;
    case 'L':
      if (у[1] == 'i')
        goto LscanReal; // 0Li
      break; // 0L
    case '.':
      if (у[1] == '.')
        break; // 0..
      // 0.
    case 'i','f','F', // Суффиксы мнимого и дробного литерала.
         'e', 'E':    // Дробная экспонента.
      goto LscanReal;
    default:
      if (*у == '_')
        goto LscanOctal; // 0_
      else if (цифра(*у))
      {
        if (*у == '8' || *у == '9')
          goto Loctal_hasDecimalDigits; // 08 или 09
        else
          goto Loctal_enter_loop; // 0[0-7]
      }
    }

    // Число 0
    assert(у[-1] == '0');
    assert(*у != '_' && !цифра(*у));
    assert(бдол_ == 0);
    десятичен = да;
    goto Lfinalize;

  LscanInteger:
    assert(*у != 0 && цифра(*у));
    десятичен = да;
    goto Lenter_loop_int;
    while (1)
    {
      if (*++у == '_')
        continue;
      if (!цифра(*у))
        break;
    Lenter_loop_int:
      if (бдол_ < бдол.max/10 || (бдол_ == бдол.max/10 && *у <= '5'))
      {
        бдол_ *= 10;
        бдол_ += *у - '0';
        continue;
      }
      // Переполнение: пропустим следующие цифры.
      переполнение = да;
      while (цифра(*++у)) {}
      break;
    }

    // Это число может быть плав, поэтому ниже проверим на переполнение.
    switch (*у)
    {
    case '.':
      if (у[1] != '.')
        goto LscanReal;
      break;
    case 'L':
      if (у[1] != 'i')
        break;
    case 'i', 'f', 'F', 'e', 'E':
      goto LscanReal;
    default:
    }

    if (переполнение)
      ошибка(т.старт, ИДС.ПереполнениеДесятичнЧисла);

    assert((цифра(у[-1]) || у[-1] == '_') && !цифра(*у) && *у != '_');
    goto Lfinalize;

  LscanHex:
    assert(цифры == 0);
    assert(*у == 'x' || *у == 'X');
    while (1)
    {
      if (*++у == '_')
        continue;
      if (!гекс(*у))
        break;
      ++цифры;
      бдол_ *= 16;
      if (*у <= '9')
        бдол_ += *у - '0';
      else if (*у <= 'F')
        бдол_ += *у - 'A' + 10;
      else
        бдол_ += *у - 'a' + 10;
    }

    assert(гекс(у[-1]) || у[-1] == '_' || у[-1] == 'x' || у[-1] == 'X');
    assert(!гекс(*у) && *у != '_');

    switch (*у)
    {
    case '.':
      if (у[1] == '.')
        break;
    case 'у', 'P':
      return сканируйГексРеал(т);
    default:
    }

    if (цифры == 0 || цифры > 16)
      ошибка(т.старт, цифры == 0 ? ИДС.НетЦифрВГексЧисле : ИДС.ПереполнениеГексЧисла);

    goto Lfinalize;

  LscanBinary:
    assert(цифры == 0);
    assert(*у == 'b' || *у == 'B');
    while (1)
    {
      if (*++у == '0')
      {
        ++цифры;
        бдол_ *= 2;
      }
      else if (*у == '1')
      {
        ++цифры;
        бдол_ *= 2;
        бдол_ += *у - '0';
      }
      else if (*у == '_')
        continue;
      else
        break;
    }

    if (цифры == 0 || цифры > 64)
      ошибка(т.старт, цифры == 0 ? ИДС.НетЦифрВБинЧисле : ИДС.ПереполнениеБинЧисла);

    assert(у[-1] == '0' || у[-1] == '1' || у[-1] == '_' || у[-1] == 'b' || у[-1] == 'B', у[-1] ~ "");
    assert( !(*у == '0' || *у == '1' || *у == '_') );
    goto Lfinalize;

  LscanOctal:
    assert(*у == '_');
    while (1)
    {
      if (*++у == '_')
        continue;
      if (!восмир(*у))
        break;
    Loctal_enter_loop:
      if (бдол_ < бдол.max/2 || (бдол_ == бдол.max/2 && *у <= '1'))
      {
        бдол_ *= 8;
        бдол_ += *у - '0';
        continue;
      }
      // Переполнение: пропустим следующие цифры.
      переполнение = да;
      while (восмир(*++у)) {}
      break;
    }

    бул естьДесятичныеЦифры;
    if (цифра(*у))
    {
    Loctal_hasDecimalDigits:
      естьДесятичныеЦифры = да;
      while (цифра(*++у)) {}
    }

    // Это число может быть плав, поэтому проверим ниже на ошибки.
    switch (*у)
    {
    case '.':
      if (у[1] != '.')
        goto LscanReal;
      break;
    case 'L':
      if (у[1] != 'i')
        break;
    case 'i', 'f', 'F', 'e', 'E':
      goto LscanReal;
    default:
    }

    if (естьДесятичныеЦифры)
      ошибка(т.старт, ИДС.ВОктЧислеЕстьДесятичные);

    if (переполнение)
      ошибка(т.старт, ИДС.ПереполнениеОктЧисла);
//     goto Lfinalize;

  Lfinalize:
    enum Суффикс
    {
      Нет     = 0,
      БезЗнака = 1,
      Дол     = 2
    }

    // Сканируем необязательный суффикс: L, Lu, LU, u, uL, U или UL.
    Суффикс суффикс;
    while (1)
    {
      switch (*у)
      {
      case 'L':
        if (суффикс & Суффикс.Дол)
          break;
        суффикс |= Суффикс.Дол;
        ++у;
        continue;
      case 'u', 'U':
        if (суффикс & Суффикс.БезЗнака)
          break;
        суффикс |= Суффикс.БезЗнака;
        ++у;
        continue;
      default:
        break;
      }
      break;
    }

    // Определяем тип целого.
    switch (суффикс)
    {
    case Суффикс.Нет:
      if (бдол_ & 0x8000_0000_0000_0000)
      {
        if (десятичен)
          ошибка(т.старт, ИДС.ПереполнениеДесятичнЗнака);
        т.вид = ТОК.Бцел64;
      }
      else if (бдол_ & 0xFFFF_FFFF_0000_0000)
        т.вид = ТОК.Цел64;
      else if (бдол_ & 0x8000_0000)
        т.вид = десятичен ? ТОК.Цел64 : ТОК.Бцел32;
      else
        т.вид = ТОК.Цел32;
      break;
    case Суффикс.БезЗнака:
      if (бдол_ & 0xFFFF_FFFF_0000_0000)
        т.вид = ТОК.Бцел64;
      else
        т.вид = ТОК.Бцел32;
      break;
    case Суффикс.Дол:
      if (бдол_ & 0x8000_0000_0000_0000)
      {
        if (десятичен)
          ошибка(т.старт, ИДС.ПереполнениеДесятичнЗнака);
        т.вид = ТОК.Бцел64;
      }
      else
        т.вид = ТОК.Цел64;
      break;
    case Суффикс.БезЗнака | Суффикс.Дол:
      т.вид = ТОК.Бцел64;
      break;
    default:
      assert(0);
    }
    т.бдол_ = бдол_;
    т.конец = у;
    return;
  LscanReal:
    сканируйРеал(т);
    return;
  }

  /// Сканирует дробночисленный литерал.
  ///
  /// $(PRE
  /// ДробночисЛитерал := Плав[fFL]?i?
  /// Плав := ДесПлав | ГексПлав
  /// ДесПлав := ([0-9][0-9_]*[.][0-9_]*ДесПлав?) |
  ///             [.][0-9][0-9_]*ДесПлав? | [0-9][0-9_]*ДесПлав
  /// ДесПлав := [eE][+-]?[0-9][0-9_]*
  /// ГексПлав := 0[xX](ГексЦифры[.]ГексЦифры |
  ///                   [.][0-9a-zA-Z]ГексЦифры? |
  ///                   ГексЦифры)ГексЭкспонента
  /// ГексЭкспонента := [pP][+-]?[0-9][0-9_]*
  /// )
  проц  сканируйРеал(ref Сема т)
  {
    if (*у == '.')
    {
      assert(у[1] != '.');
      // Эта функция была вызвана из сканируй() или сканируйЧисло().
      while (цифра(*++у) || *у == '_') {}
    }
    else
      // Эта функция была вызвана из сканируйЧисло().
      assert(delegate ()
        {
          switch (*у)
          {
          case 'L':
            if (у[1] != 'i')
              return нет;
          case 'i', 'f', 'F', 'e', 'E':
            return да;
          default:
          }
          return нет;
        }()
      );

    // Сканируем экспоненту.
    if (*у == 'e' || *у == 'E')
    {
      ++у;
      if (*у == '-' || *у == '+')
        ++у;
      if (цифра(*у))
        while (цифра(*++у) || *у == '_') {}
      else
        ошибка(т.старт, ИДС.ПлавЭкспДлжнНачСЦифры);
    }

    // Скопируем полностью число и удалим подчерки из буфера.
    ткст буфер = т.старт[0..у-т.старт].dup;
    бцел j;
    foreach (с; буфер)
      if (с != '_')
        буфер[j++] = с;
    буфер.length = j; // Настроим длину.
    буфер ~= 0; // Окончание для функций Си.

    финализируйПлав(т, буфер);
  }

  /// Сканирует 16-ричный дробночисленный литерал.
  проц  сканируйГексРеал(ref Сема т)
  {
    assert(*у == '.' || *у == 'у' || *у == 'P');
    ИДС идс;
    if (*у == '.')
      while (гекс(*++у) || *у == '_')
      {}
    // Требуется десятичная экспонента.
    if (*у != 'у' && *у != 'P')
    {
      идс = ИДС.ГексПлавЭкспТребуется;
      goto Lerr;
    }
    // Сканируем экспоненту.
    assert(*у == 'у' || *у == 'P');
    ++у;
    if (*у == '+' || *у == '-')
      ++у;
    if (!цифра(*у))
    {
      идс = ИДС.ГексПлавЭкспДлжнНачСЦифры;
      goto Lerr;
    }
    while (цифра(*++у) || *у == '_')
    {}
    // Копируем полностью число и удаляем подчерки из буфера.
    ткст буфер = т.старт[0..у-т.старт].dup;
    бцел j;
    foreach (с; буфер)
      if (с != '_')
        буфер[j++] = с;
    буфер.length = j; // Настраиваем длину.
    буфер ~= 0; // Окончание для функций Си.
    финализируйПлав(т, буфер);
    return;
  Lerr:
    т.вид = ТОК.Плав32;
    т.конец = у;
    ошибка(т.старт, идс);
  }

  /// Устанавливает значение у семы.
  /// Параметры:
  ///   т = получает значение.
  ///   буфер = сформированное плав число.
  проц  финализируйПлав(ref Сема т, ткст буфер)
  {
    assert(буфер[$-1] == 0);
    // Плав число сформировано. Проверим суффиксы и выполним преобразование.
    switch (*у)
    {
    case 'f', 'F':
      т.вид = ТОК.Плав32;
      т.плав_ = strtof(буфер.ptr, пусто);
      ++у;
      break;
    case 'L':
      т.вид = ТОК.Плав80;
      т.реал_ = strtold(буфер.ptr, пусто);
      ++у;
      break;
    default:
      т.вид = ТОК.Плав64;
      т.дво_ = strtod(буфер.ptr, пусто);
    }
    if (*у == 'i')
    {
      ++у;
      т.вид += 3; // Щит в imaginary counterpart.
      assert(т.вид == ТОК.Мнимое32 ||
             т.вид == ТОК.Мнимое64 ||
             т.вид == ТОК.Мнимое80);
    }
    if (errno() == ERANGE)
      ошибка(т.старт, ИДС.ПереполнениеПлавЧисла);
    т.конец = у;
  }

  /// Сканирует последовательность особых сем.
  ///
  /// ПоследовательностьОсобыхСем := "#строка" Целое Файлспец? КонецСтроки
  проц  сканируйОсобуйПоследовательностьСем(ref Сема т)
  {
    assert(*у == '#');
    т.вид = ТОК.ХэшСтрочка;
    т.установиФлагПробельные();

    ИДС идс;
    ткст0 ошибкаВКолонке = у;
    ткст0 конецСемы = ++у;

    if (!(у[0] == 'l' && у[1] == 'i' && у[2] == 'n' && у[3] == 'e'))
    {
      идс = ИДС.ОжидалсяИдентификаторСтрокиСпецСем;
      goto Lerr;
    }
    у += 3;
    конецСемы = у + 1;

    // TODO: #строка58"путь/файл" легально. Требуются пробелы?
    //       Состояние.Пробел можно использовать в таких случаях.
    enum Состояние
    { /+Пробел,+/ Целое, Файлспец, Конец }

    Состояние состояние = Состояние.Целое;

    while (!конецСтроки(++у))
    {
      if (пбел(*у))
        continue;
      if (состояние == Состояние.Целое)
      {
        if (!цифра(*у))
        {
          ошибкаВКолонке = у;
          идс = ИДС.ОжидалосьЦелоеПослеСтрокиСпецСем;
          goto Lerr;
        }
        т.номСтрокиСем = new Сема;
        сканируй(*т.номСтрокиСем);
        конецСемы = у;
        if (т.номСтрокиСем.вид != ТОК.Цел32 && т.номСтрокиСем.вид != ТОК.Бцел32)
        {
          ошибкаВКолонке = т.номСтрокиСем.старт;
          идс = ИДС.ОжидалосьЦелоеПослеСтрокиСпецСем;
          goto Lerr;
        }
        --у; // Вернуться на один назад, т.к. сканируй() дошло до у после целого.
        состояние = Состояние.Файлспец;
      }
      else if (состояние == Состояние.Файлспец && *у == '"')
      { // ИДС.ОжидалсяФайлспец депрекировано.
        // if (*у != '"')
        // {
        //   ошибкаВКолонке = у;
        //   идс = ИДС.ОжидалсяФайлспец;
        //   goto Lerr;
        // }
        т.семаФайлспецСтроки = new Сема;
        т.семаФайлспецСтроки.старт = у;
        т.семаФайлспецСтроки.вид = ТОК.Файлспец;
        т.семаФайлспецСтроки.установиФлагПробельные();
        while (*++у != '"')
        {
          if (конецСтроки(у))
          {
            ошибкаВКолонке = т.семаФайлспецСтроки.старт;
            идс = ИДС.НеоконченоеУказаниеФайла;
            т.семаФайлспецСтроки.конец = у;
            конецСемы = у;
            goto Lerr;
          }
          аски(*у) || раскодируйЮ8();
        }
        auto старт = т.семаФайлспецСтроки.старт +1; // +1 пропускает '"'
        т.семаФайлспецСтроки.ткт = старт[0 .. у - старт];
        т.семаФайлспецСтроки.конец = у + 1;
        конецСемы = у + 1;
        состояние = Состояние.Конец;
      }
      else/+ if (состояние == Состояние.Конец)+/
      {
        идс = ИДС.НеоконченыйОсобыйТокен;
        goto Lerr;
      }
    }
    assert(конецСтроки(у));

    if (состояние == Состояние.Целое)
    {
      ошибкаВКолонке = у;
      идс = ИДС.ОжидалосьЦелоеПослеСтрокиСпецСем;
      goto Lerr;
    }

    // Оценить #строка только, если она не в сема ткст.
    if (!вСемТкст && т.номСтрокиСем)
    {
      this.номСтр_хлайн = this.номерСтроки - т.номСтрокиСем.бцел_ + 1;
      if (т.семаФайлспецСтроки)
        новыйПутьФ(т.семаФайлспецСтроки.ткт);
    }
    у = конецСемы;
    т.конец = конецСемы;

    return;
  Lerr:
    у = конецСемы;
    т.конец = конецСемы;
    ошибка(ошибкаВКолонке, идс);
  }

  /// Вставляет пустую сему (ТОК.Пусто) перед т.
  ///
  /// Используется в фазе разбора для представления узла в AST,
  /// который не потребляет действительную сему из исходного текста.
  Сема* вставьПустуюСемуПеред(Сема* т)
  {
    assert(т !is пусто && т.предш !is пусто);
    assert(текст.ptr <= т.старт && т.старт < конец, Сема.вТкст(т.вид));
    assert(текст.ptr <= т.конец && т.конец <= конец, Сема.вТкст(т.вид));

    auto предш_t = т.предш;
    auto т_нов = new Сема;
    т_нов.вид = ТОК.Пусто;
    т_нов.старт = т_нов.конец = предш_t.конец;
    // Link in new сема.
    предш_t.следщ = т_нов;
    т_нов.предш = предш_t;
    т_нов.следщ = т;
    т.предш = т_нов;
    return т_нов;
  }

  /// Возвращает номер строки с ошибкой.
  бцел номерСтрокиОшиб(бцел номерСтроки)
  {
    return номерСтроки - this.номСтр_хлайн;
  }

  /// Передаёт параметры ошибки.
  проц  ошибка(ткст0 позВСтолбце, ткст сооб, ...)
  {
    ошибка_(this.номерСтроки, this.началоСтроки, позВСтолбце, сооб, _arguments, _argptr);
  }

  /// определено
  проц  ошибка(ткст0 позВСтолбце, ИДС идс, ...)
  {
    ошибка_(this.номерСтроки, this.началоСтроки, позВСтолбце, ДайСооб(идс), _arguments, _argptr);
  }

  /// определено
  проц  ошибка(бцел номерСтроки, ткст0 началоСтроки, ткст0 позВСтолбце, ИДС идс, ...)
  {
    ошибка_(номерСтроки, началоСтроки, позВСтолбце, ДайСооб(идс), _arguments, _argptr);
  }

  /// Создаёт отчёт об ошибке и добавляет его в список.
  /// Параметры:
  ///   номерСтроки = номер строки.
  ///   началоСтроки = указывает на первый символ текущей строки.
  ///   позВСтолбце = указывает на символ, в котором находится ошибка.
  ///   сооб = сообщение.
  проц  ошибка_(бцел номерСтроки, ткст0 началоСтроки, ткст0 позВСтолбце, ткст сооб,
              ИнфОТипе[] _arguments, base.спис_ва _argptr)
  {
    номерСтроки = this.номерСтрокиОшиб(номерСтроки);
    auto ошибПуть = this.путиКФайлам.устПуть;
    auto положение = new Положение(ошибПуть, номерСтроки, началоСтроки, позВСтолбце);
    сооб = Формат(_arguments, _argptr, сооб);
    auto ошибка = new ОшибкаЛексера(положение, сооб);
    ошибки ~= ошибка;
    if (диаг !is пусто)
      диаг ~= ошибка;
  }

  /// Сканирует весь исходный текст до КФ.
  проц  сканируйВсе()
  {
    while (следщСема() != ТОК.КФ)
    {}
  }

  /// Возвращает первую сему исходного текста.
  /// Может быть семой КФ.
  /// Структура: ГОЛОВА -> Новстр -> Первая Сема
  Сема* перваяСема()
  {
    return this.глава.следщ.следщ;
  }

  /// Возвращает "да", если ткт есть валидный D идентификатор.
  static бул строкаИдентификатора(ткст ткт)
  {
    if (ткт.length == 0 || цифра(ткт[0]))
      return нет;
    т_мера инд;
    do
    {
      auto с = drc.Unicode.раскодируй(ткт, инд);
      if (с == СИМ_ОШИБКИ || !(идент(с) || !аски(с) && униАльфа(с)))
        return нет;
    } while (инд < ткт.length);
    return да;
  }

  /// Возвращает "да", если ткт есть ключевое слово или
  /// особая сема (__FILE__, __LINE__ и т.д.)
  static бул резервныйИдентификатор(ткст ткт)
  {
    if (ткт.length == 0)
      return нет;
    auto ид = ТаблицаИд.вСтатической(ткт);
    if (ид is пусто || ид.вид == ТОК.Идентификатор)
      return нет; // ткт не в таблице или нормальный идентификатор.
    return да;
  }

  /// Возвращает да, если является валидным идентификатором и если не зарезервированный.
  static бул действитНерезИдентификатор(ткст ткт)
  {
    return строкаИдентификатора(ткт) && !резервныйИдентификатор(ткт);
  }

  /// Возвращает "да", если текущий декодируемый символ
  /// является алфавитным символом Юникода.
  ///
  /// Текущий указатель 'у' установлен на последний трейлбайт, если возвращено да.
  бул юАльфа()
  {
    assert(!аски(*у), "проверьте на сим ASCII до вызова раскодируйЮ8().");
    ткст0 у = this.у;
    дим d = *у;
    ++у; // Перейти ко второму байту.
    // Ошибка, если второй байт не трейлбайт.
    if (!ведомыйБайт(*у))
      return нет;
    // Проверка на сверхдлинные последовательности.
    switch (d)
    {
    case 0xE0, 0xF0, 0xF8, 0xFC:
      if ((*у & d) == 0x80)
        return нет;
    default:
      if ((d & 0xFE) == 0xC0) // 1100000x
        return нет;
    }
    const ткст проверьСледующийБайт = "if (!ведомыйБайт(*++у))"
                                 "  return нет;";
    const ткст добавьШестьБит = "d = (d << 6) | *у & 0b0011_1111;";
    // Раскодировка
    if ((d & 0b1110_0000) == 0b1100_0000)
    {
      d &= 0b0001_1111;
      mixin(добавьШестьБит);
    }
    else if ((d & 0b1111_0000) == 0b1110_0000)
    {
      d &= 0b0000_1111;
      mixin(добавьШестьБит ~
            проверьСледующийБайт ~ добавьШестьБит);
    }
    else if ((d & 0b1111_1000) == 0b1111_0000)
    {
      d &= 0b0000_0111;
      mixin(добавьШестьБит ~
            проверьСледующийБайт ~ добавьШестьБит ~
            проверьСледующийБайт ~ добавьШестьБит);
    }
    else
      return нет;

    assert(ведомыйБайт(*у));
    if (!верноСимвол(d) || !униАльфа(d))
      return нет;
    // Только продвинуть указатель, если это алфавитный символ Юникод.
    this.у = у;
    return да;
  }

  /// Раскодирует следщ UTF-8 последовательность.
  дим раскодируйЮ8()
  {
    assert(!аски(*у), "проверка символа ASCII перед вызовом раскодируйЮ8().");
    ткст0 у = this.у;
    дим d = *у;

    ++у; // Перейти ко второму байту.
    // Ошибка, если второй байт не трейлбайт.
    if (!ведомыйБайт(*у))
      goto Lerr2;

    // Проверка на сверхдлинные последовательности.
    switch (d)
    {
    case 0xE0, // 11100000 100xxxxx
         0xF0, // 11110000 1000xxxx
         0xF8, // 11111000 10000xxx
         0xFC: // 11111100 100000xx
      if ((*у & d) == 0x80)
        goto Lerr;
    default:
      if ((d & 0xFE) == 0xC0) // 1100000x
        goto Lerr;
    }

    const ткст проверьСледующийБайт = "if (!ведомыйБайт(*++у))"
                                 "  goto Lerr2;";
    const ткст добавьШестьБит = "d = (d << 6) | *у & 0b0011_1111;";

    // Раскодировка
    if ((d & 0b1110_0000) == 0b1100_0000)
    { // 110xxxxx 10xxxxxx
      d &= 0b0001_1111;
      mixin(добавьШестьБит);
    }
    else if ((d & 0b1111_0000) == 0b1110_0000)
    { // 1110xxxx 10xxxxxx 10xxxxxx
      d &= 0b0000_1111;
      mixin(добавьШестьБит ~
            проверьСледующийБайт ~ добавьШестьБит);
    }
    else if ((d & 0b1111_1000) == 0b1111_0000)
    { // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      d &= 0b0000_0111;
      mixin(добавьШестьБит ~
            проверьСледующийБайт ~ добавьШестьБит ~
            проверьСледующийБайт ~ добавьШестьБит);
    }
    else
      // 5 и 6 байтные последовательности UTF-8 пока недопустимы.
      // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
      // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
      goto Lerr;

    assert(ведомыйБайт(*у));

    if (!верноСимвол(d))
    {
    Lerr:
      // Три случая:
      // *) последовательность UTF-8 была успешно раскодирована, но итоговый
      //    символ неверен.
      //    у указывает на последний трейл-байт в последовательности.
      // *) последовательность UTF-8 больше по длине.
      //    у указывает на второй байт в последовательности.
      // *) последовательность UTF-8 имеет более 4-х байтов и начинается с
      //    трел-байта.
      //    у указывает на второй байт в последовательности.
      assert(ведомыйБайт(*у));
      // Переместиться к следующему ASCII символу или лид-байту последовательности UTF-8.
      while (у < (конец-1) && ведомыйБайт(*у))
        ++у;
      --у;
      assert(!ведомыйБайт(у[1]));
    Lerr2:
      d = СИМ_ЗАМЕНЫ;
      ошибка(this.у, ИДС.НедействительнаяПоследовательностьУТФ8, форматируйБайты(this.у, у));
    }

    this.у = у;
    return d;
  }

  /// Кодирует символ d и добавляет его к ткт.
  static проц  кодируйВЮ8(ref ткст ткт, дим d)
  {
    assert(!аски(d), "проверка на ASCII сим перед вызовом кодируйВЮ8().");
    assert(верноСимвол(d), "проверка валидности символа пред вызовом кодируйВЮ8().");

    сим[6] b = проц;
    if (d < 0x800)
    {
      b[0] = 0xC0 | (d >> 6);
      b[1] = 0x80 | (d & 0x3F);
      ткт ~= b[0..2];
    }
    else if (d < 0x10000)
    {
      b[0] = 0xE0 | (d >> 12);
      b[1] = 0x80 | ((d >> 6) & 0x3F);
      b[2] = 0x80 | (d & 0x3F);
      ткт ~= b[0..3];
    }
    else if (d < 0x200000)
    {
      b[0] = 0xF0 | (d >> 18);
      b[1] = 0x80 | ((d >> 12) & 0x3F);
      b[2] = 0x80 | ((d >> 6) & 0x3F);
      b[3] = 0x80 | (d & 0x3F);
      ткт ~= b[0..4];
    }
    /+ // Пока ещё не существует 5- и 6-байтных последовательностей UTF-8.
    else if (d < 0x4000000)
    {
      b[0] = 0xF8 | (d >> 24);
      b[1] = 0x80 | ((d >> 18) & 0x3F);
      b[2] = 0x80 | ((d >> 12) & 0x3F);
      b[3] = 0x80 | ((d >> 6) & 0x3F);
      b[4] = 0x80 | (d & 0x3F);
      ткт ~= b[0..5];
    }
    else if (d < 0x80000000)
    {
      b[0] = 0xFC | (d >> 30);
      b[1] = 0x80 | ((d >> 24) & 0x3F);
      b[2] = 0x80 | ((d >> 18) & 0x3F);
      b[3] = 0x80 | ((d >> 12) & 0x3F);
      b[4] = 0x80 | ((d >> 6) & 0x3F);
      b[5] = 0x80 | (d & 0x3F);
      ткт ~= b[0..6];
    }
    +/
    else
     assert(0);
  }

  ///Форматирует байты между старт и конец.
  /// Возвращает: напр.: abc -> \x61\x62\x63
  static ткст форматируйБайты(ткст0 старт, ткст0 конец)
  {
    auto длинТкт = конец-старт;
    const длинФмт = `\xXX`.length;
    ткст результат = new сим[длинТкт*длинФмт]; // Reserve space.
    результат.length = 0;
    foreach (с; cast(ббайт[])старт[0..длинТкт])
      результат ~= Формат("\\x{:X}", с);
    return результат;
  }

  /// Ищет поломанную последовательность UTF-8 в ткт.
  /// Возвращает: форматированный ткст поломанной последовательности (напр. \xC0\x80).
  static ткст найдиНедействительнуюПоследовательностьУТФ8(ткст ткт)
  {
    ткст0 у = ткт.ptr, конец = у + ткт.length;
    while (у < конец)
    {
      if (раскодируй(у, конец) == СИМ_ОШИБКИ)
      {
        auto начало = у;
        // Пропустим трейлбайты.
        while (++у < конец && ведомыйБайт(*у))
        {}
        return Лексер.форматируйБайты(начало, у);
      }
    }
    assert(у == конец);
    return "";
  }
}

/// Тестирует лексер списком сем.
unittest
{
  выдай("Тестируем Лексер.\n");
  struct Пара
  {
    ткст текстТокена;
    ТОК вид;
  }
  static Пара[] пары = [
    {"#!äöüß",  ТОК.Шебанг},       {"\n",      ТОК.Новстр},
    {"//çay",   ТОК.Комментарий},       {"\n",      ТОК.Новстр},
                                    {"&",       ТОК.ИБинарное},
    {"/*çağ*/", ТОК.Комментарий},       {"&&",      ТОК.ИЛог},
    {"/+çak+/", ТОК.Комментарий},       {"&=",      ТОК.ИПрисвой},
    {">",       ТОК.Больше},       {"+",       ТОК.Плюс},
    {">=",      ТОК.БольшеРавно},  {"++",      ТОК.ПлюсПлюс},
    {">>",      ТОК.ПСдвиг},        {"+=",      ТОК.ПрибавьПрисвой},
    {">>=",     ТОК.ПСдвигПрисвой},  {"-",       ТОК.Минус},
    {">>>",     ТОК.БПСдвиг},       {"--",      ТОК.МинусМинус},
    {">>>=",    ТОК.БПСдвигПрисвой}, {"-=",      ТОК.ОтнимиПрисвой},
    {"<",       ТОК.Меньше},          {"=",       ТОК.Присвоить},
    {"<=",      ТОК.МеньшеРавно},     {"==",      ТОК.Равно},
    {"<>",      ТОК.МилиБ},          {"~",       ТОК.Тильда},
    {"<>=",     ТОК.МилиРилиБ},       {"~=",      ТОК.СоединиПрисвой},
    {"<<",      ТОК.ЛСдвиг},        {"*",       ТОК.Умножь},
    {"<<=",     ТОК.ЛСдвигПрисвой},  {"*=",      ТОК.УмножьПрисвой},
    {"!",       ТОК.Не},           {"/",       ТОК.Деление},
    {"!=",      ТОК.НеРавно},      {"/=",      ТОК.ДелиПрисвой},
    {"!<",      ТОК.НилиБилиР},       {"^",       ТОК.ИИли},
    {"!>",      ТОК.НилиМилиР},       {"^=",      ТОК.ИИлиПрисвой},
    {"!<=",     ТОК.НилиБ},          {"%",       ТОК.Модуль},
    {"!>=",     ТОК.НилиМ},          {"%=",      ТОК.МодульПрисвой},
    {"!<>",     ТОК.НилиР},          {"(",       ТОК.ЛСкобка},
    {"!<>=",    ТОК.Неупорядоченный},     {")",       ТОК.ПСкобка},
    {".",       ТОК.Точка},           {"[",       ТОК.ЛКвСкобка},
    {"..",      ТОК.Срез},         {"]",       ТОК.ПКвСкобка},
    {"...",     ТОК.Эллипсис},      {"{",       ТОК.ЛФСкобка},
    {"|",       ТОК.ИлиБинарное},      {"}",       ТОК.ПФСкобка},
    {"||",      ТОК.ИлиЛог},     {":",       ТОК.Двоеточие},
    {"|=",      ТОК.ИлиПрисвой},      {";",       ТОК.ТочкаЗапятая},
    {"?",       ТОК.Вопрос},      {",",       ТОК.Запятая},
    {"$",       ТОК.Доллар},        {"cam",     ТОК.Идентификатор},
    {"çay",     ТОК.Идентификатор},    {".0",      ТОК.Плав64},
    {"0",       ТОК.Цел32},         {"\n",      ТОК.Новстр},
    {"\r",      ТОК.Новстр},       {"\r\n",    ТОК.Новстр},
    {"\u2028",  ТОК.Новстр},       {"\u2029",  ТОК.Новстр}
  ];

  ткст ист;

  // Соединить все тексты сем в единый ткст.
  foreach (i, пара; пары)
    if (пара.вид == ТОК.Комментарий && пара.текстТокена[1] == '/' || // Строчный комментарий.
        пара.вид == ТОК.Шебанг)
    {
      assert(пары[i+1].вид == ТОК.Новстр); // Должно сопровождаться нс.
      ист ~= пара.текстТокена;
    }
    else
      ист ~= пара.текстТокена ~ " ";

  // Лексировать построенный исходный текст.
  auto lx = new Лексер(new ИсходныйТекст("", ист));
  lx.сканируйВсе();

  auto сема = lx.перваяСема();

  for (бцел i; i < пары.length && сема.вид != ТОК.КФ;
       ++i, (сема = сема.следщ))
    if (сема.исхТекст != пары[i].текстТокена)
      assert(0, Формат("Найдено '{0}' , но ожидалось '{1}'",
                       сема.исхТекст, пары[i].текстТокена));
}

/// Тестирует у Лексера метод возьми().
unittest
{
  выдай("Тестируем метод Лексер.возьми()\n");
  auto исходныйТекст = new ИсходныйТекст("", "unittest { }");
  auto lx = new Лексер(исходныйТекст, пусто);

  auto следщ = lx.глава;
  lx.возьми(следщ);
  assert(следщ.вид == ТОК.Новстр);
  lx.возьми(следщ);
  assert(следщ.вид == ТОК.Юниттест);
  lx.возьми(следщ);
  assert(следщ.вид == ТОК.ЛФСкобка);
  lx.возьми(следщ);
  assert(следщ.вид == ТОК.ПФСкобка);
  lx.возьми(следщ);
  assert(следщ.вид == ТОК.КФ);

  lx = new Лексер(new ИсходныйТекст("", ""));
  следщ = lx.глава;
  lx.возьми(следщ);
  assert(следщ.вид == ТОК.Новстр);
  lx.возьми(следщ);
  assert(следщ.вид == ТОК.КФ);
}

unittest
{
  // Numbers unittest
  // 0L 0ULi 0_L 0_UL 0x0U 0x0p2 0_Fi 0_e2 0_F 0_i
  // 0u 0U 0uL 0UL 0L 0LU 0Lu
  // 0Li 0f 0F 0fi 0Fi 0i
  // 0b_1_LU 0b1000u
  // 0x232Lu
}
