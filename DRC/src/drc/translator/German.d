/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity average)
module drc.translator.German;

import drc.ast.DefaultVisitor,
       drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Инструкции,
       drc.ast.Types,
       drc.ast.Parameters;
	   
import io.stream.Format;
public alias ФормВывод!(сим) Принт;

private alias Декларация D;

/// Переводит синтактическое дерево на немецкий язык.
class НемецкийПереводчик : ДефолтныйВизитёр
{
  Принт буф; /// Буфер вывода.

  ткст отступ; /// Текущий ткст индентации.
  ткст шагОтступа; /// Добавляется к отступу на каждом уровне индентации.

  Декларация вхАгрегат; /// Текущий агрегат.
  Декларация вхФунк; /// Текущая функция.

  бул воМнЧле_ли; /// Использовать ли множественное число при выводе следующего типа.
  бул указатель; /// Должны ли следующие типы учитывать предыдущий указатель.

  /// Конструировать НемецкийПереводчик.
  /// Параметры:
  ///   буф = буфер для вывода.
  ///   шагОтступа = добавляется на каждом шагу индентации.
  this(Принт буф, ткст шагОтступа)
  {
    this.буф = буф;
    this.шагОтступа = шагОтступа;
  }

  /// Начало перевода.
  проц  переведи(Узел корень)
  {
    посетиУ(корень);
  }

  /// Увеличивает опступ при инстанциации.
  /// Отступ восстанавливается при выходе экземпляром из Масштаба.
  scope class Отступ
  {
    ткст стар_оступ;
    this()
    {
      стар_оступ = this.outer.отступ;
      this.outer.отступ ~= this.outer.шагОтступа;
    }

    ~this()
    { this.outer.отступ = стар_оступ; }

    ткст вТкст()
    { return this.outer.отступ; }
  }

  /// При инстанциации сохраняет член outer.
  /// Восстанавливается при выходе экземпляром из Масштаба.
  scope class Вхождение(T)
  {
    T т_сохр;
    this(T т)
    {
      auto т_сохр = т;
      static if (is(T == ДекларацияКласса) ||
                 is(T == ДекларацияИнтерфейса) ||
                 is(T == ДекларацияСтруктуры) ||
                 is(T == ДекларацияСоюза))
        this.outer.вхАгрегат = т;
      static if (is(T == ДекларацияФункции) ||
                 is(T == ДекларацияКонструктора))
        this.outer.вхФунк = т;
    }

    ~this()
    {
      static if (is(T == ДекларацияКласса) ||
                 is(T == ДекларацияИнтерфейса) ||
                 is(T == ДекларацияСтруктуры) ||
                 is(T == ДекларацияСоюза))
        this.outer.вхАгрегат = т_сохр;
      static if (is(T == ДекларацияФункции) ||
                 is(T == ДекларацияКонструктора))
        this.outer.вхФунк = т_сохр;
    }
  }

  alias Вхождение!(ДекларацияКласса) ВхождКласс;
  alias Вхождение!(ДекларацияИнтерфейса) ВхождИнтерфейс;
  alias Вхождение!(ДекларацияСтруктуры) ВхождСтрукт;
  alias Вхождение!(ДекларацияСоюза) ВхождСоюз;
  alias Вхождение!(ДекларацияФункции) ВхождФункция;
  alias Вхождение!(ДекларацияКонструктора) ВхождКонструктор;

  /// Выводит положение узла: @(lin,столб)
  проц  выведиЛок(Узел узел)
  {
    auto место = узел.начало.дайРеальноеПоложение();
    буф(отступ).форматнс("@({},{})",/+ место.путьКФайлу,+/ место.номерСтроки, место.номСтолб);
  }

override:
  D посети(ДекларацияМодуля n)
  {
    выведиЛок(n);
    буф.форматируй("Dies ist das Modul '{}'", n.имяМодуля.ткт);
    if (n.пакеты.length)
      буф.форматируй(" im Paket '{}'", n.дайИмяПакета('.'));
    буф(".").нс;
    return n;
  }

  D посети(ДекларацияИмпорта n)
  {
    выведиЛок(n);
    буф("Importiert Symbole aus einem anderen Modul bzw. Module.").нс;
    return n;
  }

  D посети(ДекларацияКласса n)
  {
    выведиЛок(n);
    scope E = new ВхождКласс(n);
    буф(отступ).форматнс("'{}' is eine Klasse mit den Eigenschaften:", n.имя.ткт);
    scope I = new Отступ();
    n.деклы && посетиД(n.деклы);
    return n;
  }

  D посети(ДекларацияИнтерфейса n)
  {
    выведиЛок(n);
    scope E = new ВхождИнтерфейс(n);
    буф(отступ).форматнс("'{}' is ein Interface mit den Eigenschaften:", n.имя.ткт);
    scope I = new Отступ();
    n.деклы && посетиД(n.деклы);
    return n;
  }

  D посети(ДекларацияСтруктуры n)
  {
    выведиЛок(n);
    scope E = new ВхождСтрукт(n);
    буф(отступ).форматнс("'{}' is eine Datenstruktur mit den Eigenschaften:", n.имя.ткт);
    scope I = new Отступ();
    n.деклы && посетиД(n.деклы);
    return n;
  }

  D посети(ДекларацияСоюза n)
  {
    выведиЛок(n);
    scope E = new ВхождСоюз(n);
    буф(отступ).форматнс("'{}' is eine Datenunion mit den Eigenschaften:", n.имя.ткт);
    scope I = new Отступ();
    n.деклы && посетиД(n.деклы);
    return n;
  }

  D посети(ДекларацияПеременных n)
  {
    выведиЛок(n);
    ткст was;
    if (вхАгрегат)
      was = "member Variable";
    else if (вхФунк)
      was = "lokale Variable";
    else
      was = "globale Variable";
    foreach (имя; n.имена)
    {
      буф(отступ).форматируй("'{}' ist eine {} des Typs: ", имя.ткт, was);
      if (n.узелТипа)
        посетиТ(n.узелТипа);
      else
        буф("auto");
      буф.нс;
    }
    return n;
  }

  D посети(ДекларацияФункции n)
  {
    выведиЛок(n);
    ткст was;
    if (вхАгрегат)
      was = "Methode";
    else if(вхФунк)
      was = "geschachtelte Funktion";
    else
      was = "Funktion";
    scope E = new ВхождФункция(n);
    буф(отступ).форматируй("'{}' ist eine {} ", n.имя.ткт, was);
    if (n.парамы.length == 1)
      буф("mit dem Argument "), посетиУ(n.парамы);
    else if (n.парамы.length > 1)
      буф("mit den Argumenten "), посетиУ(n.парамы);
    else
      буф("ohne Argumente");
    буф(".").нс;
    scope I = new Отступ();
    return n;
  }

  D посети(ДекларацияКонструктора n)
  {
    выведиЛок(n);
    scope E = new ВхождКонструктор(n);
    буф(отступ)("Ein Konstruktor ");
    if (n.парамы.length == 1)
      буф("mit dem Argument "), посетиУ(n.парамы);
    else if (n.парамы.length > 1)
      буф("mit den Argumenten "), посетиУ(n.парамы);
    else
      буф("ohne Argumente");
    буф(".").нс;
    return n;
  }

  D посети(ДекларацияСтатическогоКонструктора n)
  {
    выведиЛок(n);
    буф(отступ)("Ein statischer Konstruktor.").нс;
    return n;
  }

  D посети(ДекларацияДеструктора n)
  {
    выведиЛок(n);
    буф(отступ)("Ein Destruktor.").нс;
    return n;
  }

  D посети(ДекларацияСтатическогоДеструктора n)
  {
    выведиЛок(n);
    буф(отступ)("Ein statischer Destruktor.").нс;
    return n;
  }

  D посети(ДекларацияИнварианта n)
  {
    выведиЛок(n);
    буф(отступ)("Eine Unveränderliche.").нс;
    return n;
  }

  D посети(ДекларацияЮниттеста n)
  {
    выведиЛок(n);
    буф(отступ)("Ein Komponententest.").нс;
    return n;
  }

  Узел посети(Параметр n)
  {
    буф.форматируй("'{}' des Typs \"", n.имя ? n.имя.ткт : "unbenannt");
    n.тип && посетиУ(n.тип);
    буф("\\");
    return n;
  }

  Узел посети(Параметры n)
  {
    if (n.length > 1)
    {
      посетиУ(n.отпрыски[0]);
      foreach (узел; n.отпрыски[1..$])
        буф(", "), посетиУ(узел);
    }
    else
      super.посети(n);
    return n;
  }

  УзелТипа посети(ТМассив n)
  {
    ткст c1 = "s", c2 = "";
    if (воМнЧле_ли)
      (c1 = указатель ? ""[] : "n"), (c2 = "s");
    указатель = нет;
    if (n.ассоцТип)
      буф.форматируй("assoziative{} Massive{} von ", c1, c2);
//       посетиТ(n.ассоцТип);
    else if (n.e1)
    {
      if (n.e2)
        буф.форматируй("gescheibte{} Massive{} von ", c1, c2);
      else
        буф.форматируй("statische{} Massive{} von ", c1, c2);
//       посетиВ(n.в), n.e2 && посетиВ(n.e2);
    }
    else
      буф.форматируй("dynamische{} Massive{} von ", c1, c2);
    // Типы following массивs should be in plural.
    воМнЧле_ли = да;
    посетиТ(n.следщ);
    воМнЧле_ли = нет;
    return n;
  }

  УзелТипа посети(ТУказатель n)
  {
    ткст с = воМнЧле_ли ? (указатель ? ""[] : "n") : "";
    указатель = да;
    буф.форматируй("Zeiger{} auf ", с), посетиТ(n.следщ);
    return n;
  }

  УзелТипа посети(КвалифицированныйТип n)
  {
    посетиТ(n.лв);
    буф(".");
    посетиТ(n.пв);
    return n;
  }

  УзелТипа посети(ТИдентификатор n)
  {
    буф(n.идент.ткт);
    return n;
  }

  УзелТипа посети(ИнтегральныйТип n)
  {
    ткст с = воМнЧле_ли ? "s"[] : "";
    if (n.лекс == ТОК2.Проц) // Avoid pluralizing "проц "
      с = "";
    буф.форматируй("{}{}", n.начало.исхТекст, с);
    return n;
  }
}
