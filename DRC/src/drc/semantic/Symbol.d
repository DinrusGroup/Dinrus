/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity average)
module drc.semantic.Symbol;

import drc.ast.Node;
import drc.lexer.Identifier;
import common;

/// Перечень ИДов символов.
enum СИМ
{
  Модуль,
  Пакет,
  Класс,
  Интерфейс,
  Структура,
  Союз,
  Перечень,
  ЧленПеречня,
  Шаблон,
  Переменная,
  Функция,
  Алиас,
  НаборПерегрузки,
  Масштаб,
//   Тип,
}

/// Символ представляет собой объект с информации о семантике кода.
class Символ
{ /// Перечень состояний символа.
  enum Состояние : бкрат
  {
    Объявлен,   /// Символ был декларирован.
    Обрабатывается, /// Символ обрабатывается.
    Обработан    /// Символ обработан.
  }

  СИМ сид; /// ИД данного символа.
  Состояние состояние; /// Семантическое состояние данного символа.
  Символ родитель; /// Родитель, к которому относится данный символ.
  Идентификатор* имя; /// Название символа.
  /// Узел синтактического дерева, произвёдший данный символ.
  /// Используется для информации о положении в исходном коде и получения комментариев документации.
  Узел узел;

  /// Строит объект Символ.
  /// Параметры:
  ///   сид = идентификатор символа.
  ///   имя = мся символа.
  ///   узел = узел символа.
  this(СИМ сид, Идентификатор* имя, Узел узел)
  {
    this.сид = сид;
    this.имя = имя;
    this.узел = узел;
  }

  /// Изменяет состояние в Состояние.Обрабатывается.
  проц  устОбрабатывается()
  { состояние = Состояние.Обрабатывается; }

  /// Изменяет состояние в Состояние.Обработан.
  проц  устОбработан()
  { состояние = Состояние.Обработан; }

  /// Возвращает "да", если данный символ только завершается.
  бул обрабатывается()
  { return состояние == Состояние.Обрабатывается; }

  /// Возвращает "да", если данный символ завершён.
  бул обработан()
  { return состояние == Состояние.Обработан; }

  /// Шаблонный макрос для построения методов isXYZ().
  private template isX(ткст вид)
  {
    const ткст isX = `бул `~вид~`_ли(){ return сид == СИМ.`~вид~`; }`;
  }
  mixin(isX!("Модуль"));
  mixin(isX!("Пакет"));
  mixin(isX!("Класс"));
  mixin(isX!("Интерфейс"));
  mixin(isX!("Структура"));
  mixin(isX!("Союз"));
  mixin(isX!("Перечень"));
  mixin(isX!("ЧленПеречня"));
  mixin(isX!("Шаблон"));
  mixin(isX!("Переменная"));
  mixin(isX!("Функция"));
  mixin(isX!("Алиас"));
  mixin(isX!("НаборПерегрузки"));
  mixin(isX!("Масштаб"));
//   mixin(isX!("Тип"));

  /// Преобразует данный символ в Класс.
  Класс в(Класс)()
  {
    assert(mixin(`this.сид == mixin("СИМ." ~ Класс.stringof)`));
    return cast(Класс)cast(ук)this;
  }

  /// Возвращает: полное квалифицированное имя данного символ.
  /// Напр.: drc.semantic.Symbol.Символ.дайПКИ
  ткст дайПКИ()
  {
    if (!имя)
      return родитель ? родитель.дайПКИ() : "";
    if (родитель)
      return родитель.дайПКИ() ~ '.' ~ имя.ткт;
    return имя.ткт;
  }
}
