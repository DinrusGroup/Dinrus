<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.atomic</title>
        </head><body>
        <h1>core.atomic</h1>
        <!-- Generated by Ddoc from src\core\atomic.d -->
The <u>atomic</u> module provides basic support for lock-free
 concurrent programming.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<br><br>
<b>Authors:</b><br>
Sean Kelly, Alex RÃ¸nne Petersen
<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="atomicOp"></a>nothrow HeadUnshared!T <u>atomicOp</u>(string op, T, V1)(ref shared T <i>val</i>, V1 <i>mod</i>) if (__traits(compiles, mixin("<i>val</i>" ~ op ~ "<i>mod</i>")));
</big></dt>
<dd>Performs the binary operation 'op' on val using 'mod' as the modifier.
<br><br>
<b>Params:</b><br>
<table><tr><td>T val</td>
<td>The target variable.</td></tr>
<tr><td>V1 mod</td>
<td>The modifier to apply.</td></tr>
</table><br>
<b>Returns:</b><br>
The result of the operation.<br><br>

</dd>
<dt><big><a name="cas"></a>nothrow bool <u>cas</u>(T, V1, V2)(shared(T)* <i>here</i>, const V1 <i>ifThis</i>, const V2 <i>writeThis</i>) if (!is(T == class) &amp;&amp; !is(T U : U*) &amp;&amp; __traits(compiles, ()
{
*<i>here</i> = <i>writeThis</i>;
}
));
<br><a name="cas"></a>nothrow bool <u>cas</u>(T, V1, V2)(shared(T)* <i>here</i>, const shared(V1) <i>ifThis</i>, shared(V2) <i>writeThis</i>) if (is(T == class) &amp;&amp; __traits(compiles, ()
{
*<i>here</i> = <i>writeThis</i>;
}
));
<br><a name="cas"></a>nothrow bool <u>cas</u>(T, V1, V2)(shared(T)* <i>here</i>, const shared(V1)* <i>ifThis</i>, shared(V2)* <i>writeThis</i>) if (is(T U : U*) &amp;&amp; __traits(compiles, ()
{
*<i>here</i> = <i>writeThis</i>;
}
));
</big></dt>
<dd>Stores 'writeThis' to the memory referenced by 'here' if the value
 referenced by 'here' is equal to 'ifThis'.  This operation is both
 lock-free and atomic.
<br><br>
<b>Params:</b><br>
<table><tr><td>shared(T)* here</td>
<td>The address of the destination variable.</td></tr>
<tr><td>V2 writeThis</td>
<td>The value to store.</td></tr>
<tr><td>V1 ifThis</td>
<td>The comparison value.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the store occurred, <b>false</b> if not.<br><br>

</dd>
<dt><big><a name="atomicLoad"></a>nothrow HeadUnshared!T <u>atomicLoad</u>(MemoryOrder ms = MemoryOrder.seq, T)(ref const shared T <i>val</i>);
</big></dt>
<dd>Loads 'val' from memory and returns it.  The memory barrier specified
 by 'ms' is applied to the operation, which is fully sequenced by
 default.
<br><br>
<b>Params:</b><br>
<table><tr><td>T val</td>
<td>The target variable.</td></tr>
</table><br>
<b>Returns:</b><br>
The value of 'val'.<br><br>

</dd>
<dt><big><a name="atomicStore"></a>nothrow void <u>atomicStore</u>(MemoryOrder ms = MemoryOrder.seq, T, V1)(ref shared T <i>val</i>, V1 <i>newval</i>) if (__traits(compiles, ()
{
<i>val</i> = <i>newval</i>;
}
));
</big></dt>
<dd>Writes 'newval' into 'val'.  The memory barrier specified by 'ms' is
 applied to the operation, which is fully sequenced by default.
<br><br>
<b>Params:</b><br>
<table><tr><td>T val</td>
<td>The target variable.</td></tr>
<tr><td>V1 newval</td>
<td>The value to store.</td></tr>
</table><br>

</dd>
<dt><big><a name="MemoryOrder"></a>enum <u>MemoryOrder</u>: int;
</big></dt>
<dd>Specifies the memory ordering semantics of an atomic operation.<br><br>

<dl><dt><big><a name="MemoryOrder.raw"></a><u>raw</u></big></dt>
<dd>Not sequenced.<br><br>

</dd>
<dt><big><a name="MemoryOrder.acq"></a><u>acq</u></big></dt>
<dd>Hoist-load + hoist-store barrier.<br><br>

</dd>
<dt><big><a name="MemoryOrder.rel"></a><u>rel</u></big></dt>
<dd>Sink-load + sink-store barrier.<br><br>

</dd>
<dt><big><a name="MemoryOrder.seq"></a><u>seq</u></big></dt>
<dd>Fully sequenced (acquire + release).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="atomicFence"></a>nothrow void <u>atomicFence</u>();
</big></dt>
<dd>Inserts a full load/store memory fence (on platforms that need it). This ensures
 that all loads and stores before a call to this function are executed before any
 loads and stores after the call.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Sean Kelly 2005 - 2010.
</small>
        </body></html>
