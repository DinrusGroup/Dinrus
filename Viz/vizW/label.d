//Автор Кристофер Миллер. Переработано для Динрус Виталием Кулич.
//Библиотека визуальных конпонентов VIZ (первоначально DFL).


module viz.label;

private import viz.common, viz.control, viz.app;


export class Надпись: УпрЭлт // docmain
{
export:
	this()
	{
		перемерьПерерисуй = да; // Word wrap and center correctly.
		
		тфмт = new ФорматТекста(ФлагиФорматаТекста.ПРЕРВАТЬ_СЛОВО | ФлагиФорматаТекста.ЛИМИТ_СТРОКА);
	}
	
	
		проц стильКромки(ПСтильКромки bs) // setter
	{
		switch(bs)
		{
			case ПСтильКромки.ФИКС_3М:
				_style(_style() & ~WS_BORDER);
				_exStyle(_exStyle() | WS_EX_CLIENTEDGE);
				break;
				
			case ПСтильКромки.ФИКС_ЕДИН:
				_exStyle(_exStyle() & ~WS_EX_CLIENTEDGE);
				_style(_style() | WS_BORDER);
				break;
				
			case ПСтильКромки.НЕУК:
				_style(_style() & ~WS_BORDER);
				_exStyle(_exStyle() & ~WS_EX_CLIENTEDGE);
				break;
		}
		
		if(созданУказатель_ли)
		{
			перерисуйПолностью();
		}
	}
	
	
	ПСтильКромки стильКромки() // getter
	{
		if(_exStyle() & WS_EX_CLIENTEDGE)
			return ПСтильКромки.ФИКС_3М;
		else if(_style() & WS_BORDER)
			return ПСтильКромки.ФИКС_ЕДИН;
		return ПСтильКромки.НЕУК;
	}
	
	
		final проц использоватьМнемонику(бул подтвержд) // setter
	{
		if(подтвержд)
		{
			тфмт.флагиФормата = тфмт.флагиФормата & ~ФлагиФорматаТекста.БЕЗ_ПРЕФИКСОВ;
			_style(_style() & ~SS_NOPREFIX);
		}
		else
		{
			тфмт.флагиФормата = тфмт.флагиФормата | ФлагиФорматаТекста.БЕЗ_ПРЕФИКСОВ;
			_style(_style() | SS_NOPREFIX);
		}
		
		if(созданУказатель_ли)
			инвалидируй();
	}
	
	
	final бул использоватьМнемонику() // getter
	{
		return (тфмт.флагиФормата & ФлагиФорматаТекста.БЕЗ_ПРЕФИКСОВ) == 0;
	}
	
	
		Размер предпочитаемыйРазмер() // getter
	{
		Размер результат;
		Графика з;
		з = созданУказатель_ли ? создайГрафику() : Графика.дайЭкран();
		результат = з.мерьТекст(текст, шрифт, тфмт);
		з.вымести();
		return результат;
	}
		
	private проц выполнитьАвторазмерку(Ткст текст)
	{
		//if(созданУказатель_ли)
		{
			клиентРазм = предпочитаемыйРазмер;
		}
	}
		
	override проц текст(Ткст newText) // setter
	{
		super.текст = newText;
		
		if(autosz)
			выполнитьАвторазмерку(newText);
		
		инвалидируй(нет);
	}
	
	alias УпрЭлт.текст текст; // Overload.
	
	
		проц автоРазмер(бул подтвержд) // setter
	{
		if(подтвержд != autosz)
		{
			autosz = подтвержд;
			
			if(подтвержд)
			{
				выполнитьАвторазмерку(текст);
			}
		}
	}
	
	
	бул автоРазмер() // getter
	{
		return autosz;
	}
	
	
		проц разместиТекст(ПРасположение calign) // setter
	{
		switch(calign)
		{
			case ПРасположение.ВЕРХ_ЛЕВ:
				тфмт.расположение = РасположениеТекста.ВЕРХ | РасположениеТекста.ЛЕВ;
				break;
			
			case ПРасположение.НИЗ_ЦЕНТР:
				тфмт.расположение = РасположениеТекста.НИЗ | РасположениеТекста.ЦЕНТР;
				break;
			
			case ПРасположение.НИЗ_ЛЕВ:
				тфмт.расположение = РасположениеТекста.НИЗ | РасположениеТекста.ЛЕВ;
				break;
			
			case ПРасположение.НИЗ_ПРАВ:
				тфмт.расположение = РасположениеТекста.НИЗ | РасположениеТекста.ПРАВ;
				break;
			
			case ПРасположение.ЦЕНТР:
				тфмт.расположение = РасположениеТекста.СРЕДН | РасположениеТекста.ЦЕНТР;
				break;
			
			case ПРасположение.ЦЕНТР_ЛЕВ:
				тфмт.расположение = РасположениеТекста.СРЕДН | РасположениеТекста.ЛЕВ;
				break;
			
			case ПРасположение.ЦЕНТР_ПРАВ:
				тфмт.расположение = РасположениеТекста.СРЕДН | РасположениеТекста.ПРАВ;
				break;
			
			case ПРасположение.ВЕРХ_ЦЕНТР:
				тфмт.расположение = РасположениеТекста.ВЕРХ | РасположениеТекста.ЦЕНТР;
				break;
			
			case ПРасположение.ВЕРХ_ПРАВ:
				тфмт.расположение = РасположениеТекста.ВЕРХ | РасположениеТекста.ПРАВ;
				break;
		}
		
		инвалидируй(); // ?
	}
	
	
	ПРасположение разместиТекст() // getter
	{
		РасположениеТекста ta;
		ta = тфмт.расположение;
		
		if(ta & РасположениеТекста.НИЗ)
		{
			if(ta & РасположениеТекста.ПРАВ)
			{
				return ПРасположение.НИЗ_ПРАВ;
			}
			else if(ta & РасположениеТекста.ЦЕНТР)
			{
				return ПРасположение.НИЗ_ЦЕНТР;
			}
			else // Left.
			{
				return ПРасположение.НИЗ_ЛЕВ;
			}
		}
		else if(ta & РасположениеТекста.СРЕДН)
		{
			if(ta & РасположениеТекста.ПРАВ)
			{
				return ПРасположение.ЦЕНТР_ПРАВ;
			}
			else if(ta & РасположениеТекста.ЦЕНТР)
			{
				return ПРасположение.ЦЕНТР;
			}
			else // Left.
			{
				return ПРасположение.ЦЕНТР_ЛЕВ;
			}
		}
		else // Top.
		{
			if(ta & РасположениеТекста.ПРАВ)
			{
				return ПРасположение.ВЕРХ_ПРАВ;
			}
			else if(ta & РасположениеТекста.ЦЕНТР)
			{
				return ПРасположение.ВЕРХ_ЦЕНТР;
			}
			else // Left.
			{
				return ПРасположение.ВЕРХ_ЛЕВ;
			}
		}
	}
	
	
	 override Размер дефРазм() // getter
	{
		return Размер(100, 23);
	}
	
	
	 override проц приОтрисовке(АргиСобРис ea)
	{
		цел ш, в, w, h;
		Ткст текст;
		
		текст = this.текст;
		
		if(тфмт.расположение & РасположениеТекста.СРЕДН)
		{
			// Графика.рисуйТекст() does not support middle расположение
			// if the текст is многострок, so need to do extra work.
			Размер разм;
			разм = ea.графика.мерьТекст(текст, шрифт, тфмт);
			ш = 0;
			//if(разм.высота >= this.клиентРазм.высота)
			//	в = 0;
			//else
				в = (this.клиентРазм.высота - разм.высота) / 2;
			w = клиентРазм.ширина;
			h = разм.высота;
		}
		else if(тфмт.расположение & РасположениеТекста.НИЗ)
		{
			// Графика.рисуйТекст() does not support низ расположение
			// if the текст is многострок, so need to do extra work.
			Размер разм;
			разм = ea.графика.мерьТекст(текст, шрифт, тфмт);
			ш = 0;
			//if(разм.высота >= this.клиентРазм.высота)
			//	в = 0;
			//else
				в = this.клиентРазм.высота - разм.высота;
			w = клиентРазм.ширина;
			h = разм.высота;
		}
		else
		{
			ш = 0;
			в = 0;
			w = клиентРазм.ширина;
			h = клиентРазм.высота;
		}
		
		Цвет ктрл;
		//ктрл = цветПП;
		ктрл = цветПП.плотныйЦвет(цветФона);
		
		if(включен)
		{
			ea.графика.рисуйТекст(текст, шрифт, ктрл, Прям(ш, в, w, h), тфмт);
		}
		else
		{
			version(LABEL_GRAYSTRING)
			{
				// GrayString() is pretty ugly.
				GrayStringA(ea.графика.указатель, пусто, &_disabledOutputProc,
					cast(LPARAM)cast(проц*)this, -1, ш, в, w, h);
			}
			else
			{
				ea.графика.рисуйТекстДезакт(текст, шрифт, ктрл, цветФона, Прям(ш, в, w, h), тфмт);
			}
		}
		
		super.приОтрисовке(ea);
	}
	
	
	/+
	 override проц поСозданиюУказателя(АргиСоб ea)
	{
		super.поСозданиюУказателя(ea);
		
		/+
		if(autosz)
			выполнитьАвторазмерку(текст);
		+/
	}
	+/
	
	
	 override проц приИзмененииВключения(АргиСоб ea)
	{
		инвалидируй(нет);
		
		super.приИзмененииВключения(ea);
	}
	
	
	 override проц приИзмененииШрифта(АргиСоб ea)
	{
		if(autosz)
			выполнитьАвторазмерку(текст);
		
		инвалидируй(нет);
		
		super.приИзмененииШрифта(ea);
	}
	
	
	 override проц окПроц(inout Сообщение m)
	{
		switch(m.сооб)
		{
			case WM_GETDLGCODE:
				super.окПроц(m);
				//if(использоватьМнемонику)
					m.результат |= DLGC_STATIC;
				break;
			
			default:
				super.окПроц(m);
		}
	}
	
	
	 override бул обработайМнемонику(дим кодСим)
	{
		if(виден && включен)
		{
			if(мнемоника_ли(кодСим, текст))
			{
				выдели(да, да);
				return да;
			}
		}
		return нет;
	}
	
	
	private:
	ФорматТекста _tfmt;
	бул autosz = нет;
	
	
	final проц тфмт(ФорматТекста tf) // setter
	{
		_tfmt = tf;
	}
	
	
	final ФорматТекста тфмт() // getter
	{
		/+
		// This causes it to invert.
		if(справаНалево)
			_tfmt.флагиФормата = _tfmt.флагиФормата | ФлагиФорматаТекста.DIRECTION_RIGHT_TO_LEFT;
		else
			_tfmt.флагиФормата = _tfmt.флагиФормата & ~ФлагиФорматаТекста.DIRECTION_RIGHT_TO_LEFT;
		+/
		
		return _tfmt;
	}
}


version(LABEL_GRAYSTRING)
{
	private extern(Windows) BOOL _disabledOutputProc(HDC hdc, LPARAM lpData, цел cchData)
	{
		BOOL результат = TRUE;
		try
		{
			scope Графика з = new Графика(hdc, нет);
			Надпись l;
			with(l = cast(Надпись)cast(проц*)lpData)
			{
				з.рисуйТекст(текст, шрифт, цветПП,
					Прям(0, 0, клиентРазм.ширина, клиентРазм.высота), тфмт);
			}
		}
		catch(Объект e)
		{
			Приложение.приИсклНити(e);
			результат = FALSE;
		}
		return результат;
	}
}

